<!DOCTYPE html>
<html lang="en" class="reputify-theme">
<head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reputifly | AI Note Taker</title>
    <link rel="icon" type="image/png" href="https://media.licdn.com/dms/image/v2/D560BAQEScnUkJITXAg/company-logo_200_200/B56ZajOckKHsAI-/0/1746495195792?e=2147483647&v=beta&t=Z7yQpp5jSwm-De46D45WIC5fY_2w0GVgEWLoEOM1aug">
    <meta name="theme-color" id="theme-color-meta" content="#100F1B">
    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://unpkg.com/feather-icons"></script>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css">
    <link rel="manifest" href="manifest.json">
    <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js' defer></script>
    <script src="https://cdn.jsdelivr.net/npm/lunr/lunr.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script> <!-- ADD THIS LINE -->
 
        <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.1/dist/browser-image-compression.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.1/dist/browser-image-compression.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
        

    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    

    <script>
      // Initialize Tailwind CSS custom theme
      
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'accent-primary': 'var(--accent-primary)',
              'accent-primary-dark': 'var(--accent-primary-dark)',
              'bg-main': 'var(--bg-main)',
              'bg-pane-light': 'var(--bg-pane-light)',
              'bg-pane-dark': 'var(--bg-pane-dark)',
              'text-primary': 'var(--text-primary)',
              'text-secondary': 'var(--text-secondary)',
              'text-tertiary': 'var(--text-tertiary)',
              'border-color': 'var(--border-color)',
            }
          }
        }
      }
    </script>

    <style type="text/tailwindcss">
        /* --- Base & Color Variables --- */

        :root {
            --bg-main: #FFFFFF;
            --bg-pane-light: #F9F9F9;
            --bg-pane-dark: #F4F4F4;
            --text-primary: #1a1a1a;
            --text-secondary: #555555;
            --text-tertiary: #888888;
            --accent-primary: #007aff;
            --accent-primary-dark: #007aff;
            --border-color: #EAEAEA;
            --shadow-color: rgba(0, 0, 0, 0.05);
            --brand-grad-from: #007aff;
            --brand-grad-to: #007aff;
        }
        

        .dark {
            --bg-main: #111827;
            --bg-pane-light: #1f2937;
            --bg-pane-dark: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-tertiary: #9ca3af;
            --accent-primary: #3898ff;
            --accent-primary-dark: #007aff;
            --border-color: #374151;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --brand-grad-from: #3898ff;
            --brand-grad-to: #3898ff;
        }

        .reputify-theme {
            --bg-main: #100F1B;
            --bg-pane-light: #181624;
            --bg-pane-dark: #211F30;
            --text-primary: #F0F0F0;
            --text-secondary: #A0A0B8;
            --text-tertiary: #6C6A7E;
            --accent-primary: #E6397F;
            --accent-primary-dark: #FF8A00;
            --border-color: #2A2837;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --brand-grad-from: #E6397F;
            --brand-grad-to: #FF8A00;
        }
        /* --- START: Save Indicator Styles --- */
/* --- START: Save Indicator Styles --- */
#save-indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: var(--accent-primary);
    transition: opacity 0.3s ease, transform 0.3s ease;

    /* Start hidden */
    opacity: 0;
    transform: scale(0) translateY(2px);
}
#save-indicator.visible {
    /* Become visible and move down slightly for perfect centering */
    opacity: 1;
    transform: scale(1) translateY(1px);
    cursor: pointer; /* ADD THIS LINE */
}
/* --- END: Save Indicator Styles --- */
/* --- START: Save Indicator Alignment Fix --- */
#current-view-title {
    /* This removes any default browser margins that can interfere with centering */
    margin-bottom: 0; 
}
/* --- END: Save Indicator Alignment Fix --- */
/* --- END: Save Indicator Styles --- */
        .reputify-theme .prose {
    color: var(--text-secondary);
}
#version-content-viewer.prose {
    color: var(--text-primary);
}
.help-command-row {
    display: grid;
    grid-template-columns: 160px 1fr;
    align-items: center; /* This is the only change */
    gap: 1rem;
}
.reputify-theme .prose {
    color: var(--text-primary); /* This changes the main text to white */
}
.in-note-highlight.current {
    background-color: var(--accent-primary-dark);
    color: var(--bg-main);
}
.reputify-theme .prose h1,
.reputify-theme .prose h2,
.reputify-theme .prose h3,
.reputify-theme .prose strong {
    color: var(--text-primary);
}
.reputify-theme .prose a {
    color: var(--accent-primary);
}
.reputify-theme .prose code {
    color: var(--accent-primary-dark);
}
.reputify-theme .prose blockquote {
    color: var(--text-tertiary);
    border-color: var(--border-color);
}
/* --- START: Notion-Style Mobile Menu CSS --- */
/* --- START: New 'Add Note' Button Styles --- */
/* --- START: New 'Add Note' Button Styles --- */
/* --- START: New 'Add Note' Button Styles --- */
.add-note-btn {
    /* This is now simpler because the flex layout handles positioning */
    padding: 0.25rem; /* 4px */
    border-radius: 0.25rem; /* 4px */
    color: var(--text-tertiary);
    transition: color 150ms ease-in-out, background-color 150ms ease-in-out;
    flex-shrink: 0; /* Prevents the button from being squished */
}

.add-note-btn:hover {
    color: var(--text-primary);
    background-color: var(--bg-pane-dark);
}
/* --- END: New 'Add Note' Button Styles --- */
/* --- END: New 'Add Note' Button Styles --- */
/* --- END: New 'Add Note' Button Styles --- */
/* Add these new rules for folder-specific view buttons */
/* Add this new rule for the slide-in secondary view */
/* Indicator for selected text color */
.toolbar-color-btn.active .color-swatch-indicator {
    box-shadow: 0 0 0 2px var(--accent-primary), 0 0 0 4px var(--bg-main);
}
.toolbar-color-btn.active:hover .color-swatch-indicator {
    box-shadow: 0 0 0 2px var(--accent-primary-dark), 0 0 0 4px var(--bg-main);
}
/* --- START: Calculator Modal Styles --- */
#calculator-modal {
    min-width: 260px;
    min-height: 380px;
}
.calc-btn {
    @apply h-14 rounded-md text-xl font-medium transition-colors duration-150;
    background-color: var(--bg-pane-light);
    color: var(--text-primary);
}
.calc-btn:hover {
    background-color: var(--bg-main);
}
.calc-btn:active {
    transform: scale(0.95);
}
.calc-btn.operator-btn {
    background-color: var(--bg-pane-dark);
    color: var(--accent-primary);
}
.calc-btn.operator-btn:hover {
    background-color: var(--border-color);
}
.calc-btn.equals-btn {
    background-image: linear-gradient(to right, var(--brand-grad-from), var(--brand-grad-to));
    color: white;
}
.calc-btn.equals-btn:hover {
    opacity: 0.9;
}
/* --- END: Calculator Modal Styles --- */
.folder-view-switcher {
    display: flex;
    gap: 0.5rem;
    padding: 0.25rem 0.5rem 0.5rem 2.75rem; /* Aligns with note items */
}
/* --- START: Fullscreen Modal Styles --- */
        #chatbot-modal, #chatbot-context-modal {
            /* On mobile, they will be fullscreen */
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            top: 0;
            left: 0;
            transform: none;
            border-radius: 0;
        }

        /* On desktop, they will be large but not edge-to-edge */
        @media (min-width: 768px) {
            #chatbot-modal, #chatbot-context-modal {
                width: 90vw;
                height: 85vh;
                max-width: 1200px; /* Increased max width for chatbot */
                border-radius: 0.75rem; /* 12px */
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                border: 1px solid var(--border-color);
            }
            #chatbot-context-modal {
                 max-width: 800px; /* Specific larger size for context modal */
            }
        }
        /* --- END: Fullscreen Modal Styles --- */
.folder-view-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.25rem 0.75rem;
    border-radius: 0.375rem; /* 6px */
    font-size: 0.875rem; /* 14px */
    background-color: var(--bg-pane-dark);
    color: var(--text-tertiary);
    transition: all 0.2s ease;
}
.folder-view-btn:hover {
    color: var(--text-primary);
}
.folder-view-btn.active {
    background-color: var(--bg-main);
    color: var(--text-primary);
    font-weight: 500;
}
/* This is the main container for the slide-in menu */
#notion-style-mobile-menu.open {
    transform: translateX(0);
}

/* Section headers like "Jump back in" and "Private" */
.notion-menu-section-header {
    font-size: 0.75rem; /* 12px */
    font-weight: 600;
    color: var(--text-tertiary);
    text-transform: uppercase;
    padding: 1rem 0.5rem 0.5rem;
}
/* --- START: REFINED List View Checklist Preview Styles --- */
.list-view-all-checklists-container {
    padding: 0.75rem 1rem; /* The main container for all checklists in a note */
    border-top: 1px solid var(--border-color);
}
.checklist-preview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    padding: 0.5rem 0.75rem;
    border-radius: 0.375rem; /* 6px */
    background-color: var(--bg-pane-dark);
    color: var(--text-secondary);
    transition: all 0.2s;
}
.checklist-preview-header:hover {
    background-color: var(--bg-main);
    color: var(--text-primary);
}
.checklist-preview-header .feather-chevron-down {
    transition: transform 0.2s ease-in-out;
}
.checklist-preview-body {
    padding: 0.75rem 0.5rem 0.25rem;
    overflow: hidden; /* No scrollbar */
}
.checklist-preview-body ul {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}
.checklist-preview-item {
    font-size: 0.875rem; /* 14px */
    color: var(--text-secondary);
}
.checklist-preview-item.checked span {
    text-decoration: line-through;
    color: var(--text-tertiary);
}
.checklist-preview-item input[type="checkbox"] {
    width: 1rem; /* 16px */
    height: 1rem; /* 16px */
    accent-color: var(--accent-primary);
    flex-shrink: 0;
    cursor: pointer; /* Makes it feel interactive */
}
/* --- END: REFINED List View Checklist Preview Styles --- */
/* Grid layout for the "Jump back in" cards */
.jump-back-in-grid {
    display: flex;
    flex-wrap: nowrap; /* Prevent wrapping */
    gap: 0.5rem;
    overflow-x: auto; /* Enable horizontal scrolling */
    padding-bottom: 0.5rem; /* Add space for the scrollbar */
    /* Hide scrollbar for a cleaner look */
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
}
.jump-back-in-grid::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Opera */
}
.recent-note-card {
    width: 140px; /* Give cards a fixed width */
    flex-shrink: 0; /* Prevent cards from shrinking */
}

/* Individual card for a recent note */
.recent-note-card {
    background-color: var(--bg-pane-dark);
    border-radius: 0.375rem; /* 6px */
    padding: 0.75rem;
    height: 90px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    font-weight: 500;
    font-size: 0.875rem; /* 14px */
    color: var(--text-secondary);
    border: 1px solid var(--border-color);
    overflow: hidden;
    text-decoration: none;
    transition: background-color 0.2s;
}
.recent-note-card:hover {
    background-color: var(--bg-main);
}
.recent-note-card .note-name {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

/* Use the existing sidebar styles for the "Private" section for consistency */
#private-section .collection-item {
    font-size: 1rem; /* 16px */
    padding: 0.6rem 0.5rem;
}
#private-section .collection-item:hover {
    background-color: var(--bg-pane-dark);
}
#private-section .collection-item.bg-bg-pane-dark {
    background-color: var(--bg-main) !important;
}
/* --- END: Notion-Style Mobile Menu CSS --- */
/* --- START: Mobile Settings Popup CSS --- */
#mobile-settings-popup.open {
    transform: translateX(0);
}

.toggle-switch {
    width: 44px;
    height: 24px;
    background-color: var(--bg-pane-dark);
    border-radius: 9999px;
    padding: 2px;
    transition: background-color 0.2s ease-in-out;
    cursor: pointer;
    flex-shrink: 0;
}

.toggle-switch.active {
    background-color: var(--accent-primary);
}

.toggle-knob {
    width: 20px;
    height: 20px;
    background-color: white;
    border-radius: 9999px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    transition: transform 0.2s ease-in-out;
}

.toggle-switch.active .toggle-knob {
    transform: translateX(20px);
}
/* --- END: Mobile Settings Popup CSS --- */
#mobile-tags-popup.open {
    transform: translateX(0);
}
/* Add these styles for checklist items */
/* Add these styles for checklist items */
/* UPDATED: Styles for checklist items in editor AND public view */
/* --- START: Simplified Checklist Styles --- */
/* --- START: Enhanced Checklist Styles --- */
/* --- START: Final Checklist Alignment Fix --- */
/* --- START: Final Checklist Alignment Fix --- */
/* --- START: New Checklist Container Styles --- */
.checklist-container {
    background-color: var(--bg-pane-dark);
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    margin: 1em 0;
    padding: 0.75rem 1rem;
    user-select: none; /* Prevent text selection in view mode */
}
/* Corrects icon colors in menus for dark mode */
.prop-type-option svg, #properties-menu svg {
    stroke: currentColor;
}
/* ADD THIS RULE FOR PROPERTY MENU ICONS */
#properties-menu i {
    color: var(--text-secondary);
}
/* ADD THIS ENTIRE BLOCK FOR THE NEW CALENDAR FEATURES */

/* END OF NEW CALENDAR CSS */
/* ADD THIS CSS FOR THE NEW PROPERTY MODAL */
.prop-type-option {
    display: flex;
    align-items: center;
    padding: 0.5rem 0.75rem;
    border: 1px solid var(--border-color);
    background-color: var(--bg-pane-dark);
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.2s ease;
}
.prop-type-option:hover {
    background-color: var(--bg-main);
}
.prop-type-option input[type="radio"] {
    margin-right: 0.75rem;
}
.prop-type-option input[type="radio"]:checked + span {
    color: var(--accent-primary);
    font-weight: 600;
}
.prop-type-option span {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}
.checklist-header {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 0.25rem;
    /* The margin makes the header span the full width of the parent */
    margin: -0.75rem -1rem 0.75rem -1rem;
    padding: 0.5rem 1rem; /* This is the only line that changed */
    border-bottom: 1px solid var(--border-color);
    /* Make the top corners rounded */
    border-radius: 0.5rem 0.5rem 0 0;
    /* Use a subtle, transparent black for a clean look */
    background-color: rgba(0, 0, 0, 0.1); 
}

.checklist-header-btn {
    padding: 0.25rem;
    border-radius: 0.25rem;
    color: var(--text-tertiary);
    background: none;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;
}
.checklist-header-btn:hover {
    background-color: var(--bg-pane-light);
    color: var(--text-primary);
}
.checklist-header-btn.delete:hover {
    color: #ef4444; /* red-500 */
}

.checklist-body {
    padding-left: 0;
    margin: 0;
    list-style: none;
}

.checklist-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.25rem 0;
    cursor: pointer;
}

.checklist-item-checkbox {
    width: 1.25rem;
    height: 1.25rem;
    flex-shrink: 0;
}

.checklist-item-text {
    flex-grow: 1;
    color: var(--text-secondary);
    transition: color 0.2s;
}

.checklist-item.checked .checklist-item-text {
    text-decoration: line-through;
    color: var(--text-tertiary);
}

/* Styles for the Edit Modal */
.checklist-modal-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}
.checklist-modal-item input[type="text"] {
    flex-grow: 1;
    background-color: var(--bg-pane-dark);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 6px 10px;
    color: var(--text-primary);
    outline: none;
}
.checklist-modal-item input[type="text"]:focus {
    border-color: var(--accent-primary);
}
.checklist-modal-item-btn {
    padding: 0.25rem;
    color: var(--text-tertiary);
    cursor: pointer;
}
.checklist-modal-item-btn:hover {
    color: var(--text-primary);
}
/* --- END: New Checklist Container Styles --- */
.checklist-progress-container {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 0.75rem; 
}

.checklist-progress-bar {
    flex-grow: 1;
    height: 8px;
    background-color: var(--bg-pane-light);
    border-radius: 9999px;
    overflow: hidden;
}

.checklist-progress-fill {
    height: 100%;
    background-color: var(--accent-primary);
    border-radius: 9999px;
    transition: width 0.3s ease-in-out;
}

.checklist-progress-text {
    font-size: 0.75rem;
    color: var(--text-tertiary);
    flex-shrink: 0;
}
/* --- END: Final Checklist Alignment Fix --- */
/* --- START: Share Note Checklist Fix --- */
#public-note-content .task-list-item {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    margin: 0.5rem 0;
    list-style: none;
    padding-left: 0;
}

#public-note-content .task-list-item input[type="checkbox"] {
    flex-shrink: 0;
    width: 1.25rem;
    height: 1.25rem;
    
}

/* --- START: Final Interactive Table CSS --- */
/* --- START: Final Polished Table CSS --- */
#note-editor-body table {
    table-layout: fixed;
    width: 100%;
    border-spacing: 0; /* Ensures borders are clean */
}
#note-editor-body th.sortable-header {
    cursor: pointer;
    position: relative;
    padding-right: 20px;
    user-select: none;
}
#note-editor-body th .sort-indicator {
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 1em;
    color: var(--accent-primary);
}
/* --- START: Modal Click Fix --- */
/* --- START: Modal Click Fix --- */
#modal-backdrop { display: none !important; }
/* --- END: Modal Click Fix --- */

/* --- END: Modal Click Fix --- */
#note-editor-body th.sortable-header:hover::after {
    content: '↕';
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-tertiary);
    font-weight: normal;
    opacity: 0.7;
}
#note-editor-body th.sortable-header[data-sort-dir="asc"]:hover::after,
#note-editor-body th.sortable-header[data-sort-dir="desc"]:hover::after {
    content: '';
}
/* --- NEW: Cell Focus Outline --- */
#note-editor-body td:focus,
#note-editor-body th:focus {
    outline: 2px solid var(--accent-primary) !important;
    outline-offset: -2px; /* Pulls outline inside the cell */
    z-index: 5;
    position: relative;
}
.column-resizer {
    position: absolute;
    top: 0;
    right: -3px;
    width: 6px;
    height: 100%;
    cursor: col-resize;
    z-index: 10;
}
/* --- NEW: Nicer Filter Bar --- */
.table-filter-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    padding: 4px 0;
}
.table-filter-wrapper .filter-icon {
    position: absolute;
    left: 12px; /* Slightly more space from the edge */
    top: 50%;
    transform: translateY(-50%);
    width: 1rem; /* 16px */
    height: 1rem; /* 16px */
    color: var(--text-tertiary);
    pointer-events: none;
    transition: color 0.2s ease; /* Adds a slick transition */
}
.table-filter-input:focus + .filter-icon,
.table-filter-wrapper:focus-within .filter-icon {
    color: var(--accent-primary);
}
.table-filter-input {
    width: 100%;
    background-color: var(--bg-pane-dark);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 6px 10px 6px 36px; /* Left padding for icon */
    font-size: 0.9em;
    color: var(--text-primary);
    transition: border-color 0.2s;
}
.table-filter-input:focus {
    outline: none;
    border-color: var(--accent-primary);
}
/* --- START: NEW CALENDAR & DAY VIEW STYLES --- */
.calendar-grid-wrapper {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.calendar-day-cell {
    position: relative;
    padding: 0.5rem;
    background-color: var(--bg-main);
    min-height: 120px;
    overflow-y: auto;
}
.calendar-day-cell.drag-over {
    background-color: rgba(230, 57, 127, 0.1);
    outline: 2px dashed var(--accent-primary);
    outline-offset: -2px;
}
.calendar-day-number {
    font-weight: 600;
    color: var(--text-secondary);
    cursor: pointer;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 9999px;
    transition: background-color 0.2s;
}
.calendar-day-number:hover {
    background-color: var(--bg-pane-dark);
}
.calendar-event-item {
    font-size: 0.875rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    background-color: var(--bg-pane-dark);
    cursor: grab;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}
.event-color-dot {
    width: 8px;
    height: 8px;
    border-radius: 9999px;
    flex-shrink: 0;
}
.day-view-container {
    flex-grow: 1;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}
.day-view-all-day-section {
    padding: 0.5rem 0 0.5rem 5rem; /* Aligns with timeline */
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}
.day-view-all-day-item {
    padding: 0.25rem 0.5rem;
    background-color: var(--bg-pane-dark);
    border-radius: 0.25rem;
    font-size: 0.875rem;
}
.day-view-timeline-wrapper {
    position: relative;
    flex-grow: 1;
}
.day-view-grid {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: grid;
    grid-template-rows: repeat(24, 48px);
}
.day-view-hour-slot {
    border-bottom: 1px solid var(--border-color);
    padding-left: 5rem; /* Space for time labels */
    position: relative;
}
.day-view-hour-slot::before {
    content: attr(data-time);
    position: absolute;
    left: 0;
    top: -0.5em;
    padding-right: 0.5rem;
    width: 5rem;
    text-align: right;
    font-size: 0.75rem;
    color: var(--text-tertiary);
}
.day-view-event-container {
    position: absolute;
    left: 5rem;
    right: 0.5rem;
    z-index: 10;
}
.day-view-event {
    padding: 0.75rem;
    background-color: var(--bg-pane-dark);
    border-radius: 0.375rem;
    border-left-width: 4px;
}
#now-indicator {
    position: absolute;
    height: 2px;
    background-color: #ef4444; /* red-500 */
    width: 100%;
    z-index: 20;
}
#now-indicator::before {
    content: '';
    position: absolute;
    left: -5px;
    top: -4px;
    width: 12px;
    height: 12px;
    background-color: #ef4444;
    border-radius: 9999px;
}
/* --- END: NEW CALENDAR & DAY VIEW STYLES --- */
/* --- END: NEW CALENDAR & DAY VIEW STYLES --- */
/* ADD THIS ENTIRE BLOCK TO DIFFERENTIATE LINKS */
/* Style for internal note links */
#note-editor-body a.internal-link::before {
    content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-file-text'%3E%3Cpath d='M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z'%3E%3C/path%3E%3Cpolyline points='14 2 14 8 20 8'%3E%3C/polyline%3E%3Cline x1='16' y1='13' x2='8' y2='13'%3E%3C/line%3E%3Cline x1='16' y1='17' x2='8' y2='17'%3E%3C/line%3E%3Cpolyline points='10 9 9 9 8 9'%3E%3C/polyline%3E%3C/svg%3E");
    display: inline-block;
    width: 14px;
    height: 14px;
    margin-right: 4px;
    vertical-align: -2px;
    opacity: 0.7;
}

/* Style for external website links */
#note-editor-body a[target="_blank"]::after {
    content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round' class='feather feather-external-link'%3E%3Cpath d='M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6'%3E%3C/path%3E%3Cpolyline points='15 3 21 3 21 9'%3E%3C/polyline%3E%3Cline x1='10' y1='14' x2='21' y2='3'%3E%3C/line%3E%3C/svg%3E");
    display: inline-block;
    width: 14px;
    height: 14px;
    margin-left: 3px;
    vertical-align: -2px;
    opacity: 0.7;
}
/* END OF BLOCK TO ADD */
.table-filter-clear-btn {
    position: absolute;
    right: 10px;
    color: var(--text-tertiary);
    cursor: pointer;
    background: none;
    border: none;
    padding: 2px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;
}
.table-filter-input:not(:placeholder-shown) + .table-filter-clear-btn {
    opacity: 1;
    pointer-events: auto;
}
/* --- End Filter Bar --- */
.table-menu-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.5rem;
    border-radius: 4px;
    cursor: pointer;
    position: relative;
}
.table-menu-item:hover { background-color: var(--bg-pane-dark); }
.table-menu-item .submenu-arrow { margin-left: auto; }
.table-menu-item .submenu {
    display: none;
    position: absolute;
    left: 100%;
    top: -5px;
    background-color: var(--bg-pane-light);
    border-radius: 6px;
    padding: 0.25rem;
    border: 1px solid var(--border-color);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    width: max-content;
}
.table-menu-item:hover > .submenu { display: block; }
.color-swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
}
.bg-highlight-yellow { background-color: rgba(250, 204, 21, 0.2); }
.bg-highlight-green { background-color: rgba(74, 222, 128, 0.2); }
.bg-highlight-blue { background-color: rgba(96, 165, 250, 0.2); }
.bg-highlight-red { background-color: rgba(248, 113, 113, 0.2); }
.text-color-red { color: #F87171; }
.text-color-orange { color: #FB923C; }
.text-color-green { color: #4ADE80; }
.text-color-blue { color: #007aff; }
#note-editor-body tfoot td {
    font-weight: bold;
    color: var(--text-secondary);
    background-color: var(--bg-pane-dark);
    padding: 8px;
    border-top: 2px solid var(--border-color);
}
/* --- END: Final Polished Table CSS --- */
/* --- END: New Interactive Table CSS --- */

/* --- START: Public Page Code Block Style Fix --- */
/* --- START: FINAL Public Page Code Block Style Fix --- */
#public-note-content .code-block-wrapper {
    background-color: #211F30; /* A dark background matching your reputify theme */
    border: 1px solid #2A2837;
    border-radius: 8px;
    overflow: hidden;
    margin: 1.5em 0;
}
#public-note-content .code-block-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: rgba(0,0,0,0.2);
    padding: 0.5rem 1rem;
    color: #A0A0B8;
    font-size: 0.8rem;
}
/* --- START: Table Filter Toggle CSS --- */

/* New wrapper to hold the filter and the toggle button */
.table-header-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem; /* 8px */
}

/* Makes the filter input container grow to fill available space */
.table-header-controls .table-filter-wrapper {
    flex-grow: 1;
}

/* Styles for the new collapse/expand button */
.toggle-filter-btn {
    padding: 0.25rem; /* 4px */
    border-radius: 0.25rem; /* 4px */
    background: none;
    border: none;
    color: var(--text-tertiary);
    cursor: pointer;
    flex-shrink: 0; /* Prevents the button from shrinking */
    transition: all 0.2s ease;
}

.toggle-filter-btn:hover {
    background-color: var(--bg-pane-dark);
    color: var(--text-primary);
}

/* The transition for the icon's rotation */
.toggle-filter-btn > i {
    transition: transform 0.2s ease-in-out;
}

/* Hides the filter input when the table is collapsed */
table.filter-collapsed .table-filter-wrapper {
    display: none;
}

/* Rotates the chevron icon down when the table is collapsed */
table.filter-collapsed .toggle-filter-btn > i {
    transform: rotate(180deg);
}

/* --- END: Table Filter Toggle CSS --- */
.exit-code-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 0.25rem 0.5rem;
    border-radius: 5px;
    transition: background-color 0.2s, color 0.2s;
}
.exit-code-btn:hover {
    background-color: var(--bg-pane-light);
    color: var(--accent-primary);
}
#public-note-content .code-block-wrapper pre {
    margin: 0 !important;
    padding: 1em !important;
}
/* This is the most important part: it makes the inner code block transparent */
#public-note-content .code-block-wrapper pre code.hljs {
    background: transparent !important;
    padding: 0 !important;
}
/* --- START: Checklist Interaction Fix --- */
/* Prevents direct text editing of checklist items in the main editor */
#note-editor-body .checklist-item-text {
    pointer-events: none;
    user-select: none;
    cursor: default; /* Reinforces non-interactive nature */
}
/* --- START: Checklist Modal Handle Style --- */
/* --- START: Checklist Modal Handle Style --- */
.checklist-modal-item .handle {
    display: inline-flex;
    touch-action: none;
    cursor: grab;
}

/* Style for the item being dragged */
.checklist-modal-item.dragging {
    opacity: 0.5;
    background-color: var(--bg-pane-dark);
}
/* --- END: Checklist Modal Handle Style --- */
/* --- START: Version History Modal Styles --- */
/* --- START: Version History Modal Styles --- */
#version-sidebar .version-item {
    padding: 0.5rem 0.75rem;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.2s;
    border: 1px solid var(--border-color);
    background-color: var(--bg-main);
    margin-bottom: 0.5rem;
}
#version-sidebar .version-item:hover {
    background-color: var(--bg-pane-light);
}
#version-sidebar .version-item.active {
    background-color: var(--bg-main);
    border-color: var(--accent-primary);
    font-weight: 600;
    box-shadow: 0 0 8px -2px var(--accent-primary);
}
.version-timestamp {
    color: var(--text-primary);
    font-size: 0.875rem;
}
.version-fulldate {
    font-size: 0.75rem;
    color: var(--text-tertiary);
    font-weight: 400;
}
.version-message {
    font-size: 0.8rem;
    color: var(--text-primary);
    background-color: var(--bg-main);
    border: 1px solid var(--border-color);
    border-radius: 9999px;
    padding: 2px 8px;
    margin-top: 6px;
    display: inline-block;
}

/* Styles for the visual diff viewer */
#version-content-viewer ins {
    background-color: rgba(16, 185, 129, 0.2); /* Green for additions */
    text-decoration: none;
}
#version-content-viewer del {
    background-color: rgba(239, 68, 68, 0.2); /* Red for deletions */
}
/* --- END: Version History Modal Styles --- */
/* --- END: Version History Modal Styles --- */
/* --- END: Checklist Modal Handle Style --- */
/* --- END: Checklist Modal Handle Style --- */
/* --- END: Checklist Interaction Fix --- */
/* --- END: FINAL Public Page Code Block Style Fix --- */
/* --- END: Share Note Checklist Fix --- */
.version-group-header {
    font-size: 0.75rem; /* 12px */
    font-weight: 600;
    text-transform: uppercase;
    color: var(--text-tertiary);
    padding: 1rem 0.5rem 0.25rem;
    position: sticky;
    top: 0;
    background-color: var(--bg-pane-dark);
    z-index: 1;
}

.version-item .version-message {
    margin-top: 0.375rem; /* 6px */
    display: inline-block;
    max-width: 100%;
    white-space: normal;
    word-break: break-word;
    border-radius: 6px; /* Less rounded corners */
    line-height: 1.4;
}

        .brand-button {
    background-image: linear-gradient(to right, var(--brand-grad-from), var(--brand-grad-to));
    color: white;
    border: none;
    padding: 0.5rem 1rem; /* 8px top/bottom, 16px left/right */
    border-radius: 0.375rem; /* 6px rounded corners */
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-weight: 500;
    transition: opacity 0.2s;
}

.brand-button:hover {
    opacity: 0.9;
}
.brand-button.confirm-state {
    background-image: none;
    background-color: #ef4444; /* red-500 */
}
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-main);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        #flashcard-container.flipped #flashcard {
    transform: rotateY(180deg);
}
.flashcard-face {
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
}
.transform-style-3d {
    transform-style: preserve-3d;
}
.perspective-1000 {
    perspective: 1000px;
}
.rotate-y-180 {
    transform: rotateY(180deg);
}
/* --- START: Modal Scroll Fix --- */
#global-ai-modal .modal-content-area {
    overflow-y: auto;
    max-height: 65vh; /* Sets a max height relative to the viewport */
}

/* --- END: Modal Scroll Fix --- */
        
        /* --- UI Polish & Animations --- */
        #note-editor-body {
    overflow-wrap: break-word;
    word-wrap: break-word; /* For older browser compatibility */
}
#command-prompt-container {
    transition: opacity 200ms ease-out, transform 200ms ease-out;
}

#command-prompt-container.hidden {
    opacity: 0;
    transform: translate(-50%, 20px) scale(0.95);
    pointer-events: none;
}

.command-suggestion-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem;
    border-radius: 0.25rem;
    cursor: pointer;
}
.command-suggestion-item:hover {
    background-color: var(--bg-pane-light);
}
.command-suggestion-item.active {
    background-color: var(--accent-primary);
    color: white;
}
.command-suggestion-item .cmd-name {
    font-weight: 600;
}
.command-suggestion-item .cmd-alias {
    font-size: 0.75rem;
    background-color: var(--bg-pane-light);
    color: var(--text-secondary);
    border-radius: 0.25rem;
    padding: 2px 6px;
}
.command-suggestion-item.active .cmd-alias {
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
}
.command-suggestion-item .cmd-desc {
    font-size: 0.875rem;
    color: var(--text-secondary);
}
.command-suggestion-item.active .cmd-desc {
    color: rgba(255, 255, 255, 0.8);
}
#note-editor-title {
    overflow-wrap: break-word;
    word-wrap: break-word;
}
        #notes-list-pane {
            transition: width 300ms ease-in-out, transform 300ms ease-in-out;
            overflow: hidden;
        }
        #toggle-settings-btn.collapsed .feather-chevron-down {
    transform: rotate(-90deg);
}
#settings-list-container.collapsed {
    max-height: 0;
    opacity: 0;
    margin-top: 0;
    overflow: hidden;
}
/* Find and replace the old #command-suggestions CSS with this */

/* Find and replace the old #command-suggestions rule with this one */

/* Replace your existing #command-suggestions rule with this one */
#command-suggestions {
    /* We remove max-height here because JavaScript will now control it */
    overflow-y: auto;
    display: grid;
    grid-template-columns: 100%;
}

/* Add this new rule to style the content-match suggestions */
.command-suggestion-item.content-match {
    display: block; /* Overrides the default flex layout to allow stacking */
    padding: 0.5rem;
}

/* This is the new reusable class for all custom scrollbars */
/* Find and replace the old .custom-scrollbar CSS with this */

.custom-scrollbar {
    /* This makes the scrollbar float over content in compatible browsers (Chrome/Edge) */
    overflow-y: overlay;
    /* Fallback for other browsers like Firefox */
    overflow-y: auto;
    
    scrollbar-width: thin;
    scrollbar-color: var(--bg-pane-dark) transparent;
}

.custom-scrollbar::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.custom-scrollbar::-webkit-scrollbar-track {
    background: transparent;
}

/* Make the scrollbar thumb transparent by default, effectively hiding it */
.custom-scrollbar::-webkit-scrollbar-thumb {
    background-color: transparent;
    border-radius: 10px;
    border: 2px solid transparent;
}

/* ONLY show the scrollbar thumb when you hover over the scrollable container */
.custom-scrollbar:hover::-webkit-scrollbar-thumb {
    background-color: var(--bg-pane-dark);
    border-color: var(--bg-pane-light);
}

/* Hides the default scrollbar and styles a new one for Chrome/Safari/Edge */
#command-suggestions::-webkit-scrollbar {
    width: 8px;
}

#command-suggestions::-webkit-scrollbar-track {
    background: transparent;
}

#command-suggestions::-webkit-scrollbar-thumb {
    background-color: var(--bg-pane-dark);
    border-radius: 10px;
    border: 2px solid var(--bg-pane-light);
}
        #flashcard-front p,
#flashcard-back p {
    color: var(--text-primary) !important;
    margin: 0;
}
#main-content-area {
    min-height: 0;
}
#backlinks-pane {
    background-color: var(--bg-pane-light);
}
/* --- START: Scrollbar Hiding Utility --- */
.no-scrollbar::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
}
.no-scrollbar {
    -ms-overflow-style: none;  /* For Internet Explorer and Edge */
    scrollbar-width: none;  /* For Firefox */
}
/* --- END: Scrollbar Hiding Utility --- */
.backlink-item {
    background-color: var(--bg-main);
    border: 1px solid var(--border-color);
    transition: box-shadow 0.2s;
}
.backlink-item:hover {
    box-shadow: 0 4px 12px var(--shadow-color);
}
#toggle-backlinks-btn.collapsed .feather-chevron-down {
    transform: rotate(-90deg);
}
#current-view-title {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
#backlinks-list.collapsed {
    max-height: 0;
    opacity: 0;
    margin-top: 0;
    overflow: hidden;
}
/* --- START: Selection-based Hide Checkboxes --- */
.task-list-item.checkbox-hidden input[type="checkbox"] {
    display: none;
}
/* --- END: Selection-based Hide Checkboxes --- */
/* Add these styles for the mobile toolbar fix */

        
        #notes-list-pane .sidebar-content-wrapper {
            transition: opacity 150ms ease-in-out;
        }
        #notes-list-pane.collapsed {
            width: 0px !important;
            border-right-width: 0px;
        }
        #notes-list-pane.collapsed .sidebar-content-wrapper {
            opacity: 0;
            pointer-events: none;
        }
        #tag-list-container.collapsed {
    max-height: 0;
    opacity: 0;
    margin-top: 0;
    overflow: hidden;
}
/* --- START: AI Response Copy Button Style --- */
.ai-response-copy-btn {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    padding: 0.35rem;
    border-radius: 0.375rem;
    background-color: var(--bg-pane-light);
    color: var(--text-tertiary);
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    cursor: pointer;
    z-index: 10;
}
.relative:hover .ai-response-copy-btn {
    opacity: 1;
}
.ai-response-copy-btn:hover {
    color: var(--text-primary);
}
/* --- END: AI Response Copy Button Style --- */
/* Add these styles for tables in the editor */
/* UPDATED: Styles for tables in editor AND public view */
/* UPDATED: Styles for tables in editor AND public view */
/* --- START: Public Note Table Scroll Fix --- */
/* --- START: Public Note Table Scroll Fix --- */
#note-editor-body table,
#public-note-content table {
    display: block;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch; /* For smoother scrolling on mobile */
}
#editor-pane {
    min-width: 0;
}
.card-content {
    word-break: break-all;
}
/* --- END: Public Note Table Scroll Fix --- */
/* --- END: Public Note Table Scroll Fix --- */
#note-editor-body table, #public-note-content table {
    width: 100%;
    border-collapse: collapse;
    margin: 1em 0;
}
#note-editor-body th, #note-editor-body td,
#public-note-content th, #public-note-content td {
    border: 1px solid var(--border-color);
    padding: 0.5rem; /* 8px */
    text-align: left;
}
#note-editor-body th, #public-note-content th {
    background-color: var(--bg-pane-dark);
    font-weight: 600;
    color: var(--text-primary); /* This is the fix for the text color */
}

#toggle-tags-btn.collapsed .feather-chevron-down {
    transform: rotate(-90deg);
}

        #sidebar-toggle-btn {
            transition: left 300ms ease-in-out, background-color 0.2s ease;
        }
        #flashcard-front, #flashcard-back {
    color: var(--text-primary);
    font-size: 1.25rem; /* Makes the text a bit bigger */
    line-height: 1.5;
}
        #sidebar-toggle-btn .feather-chevron-left {
            transition: transform 0.3s ease;
        }
        #sidebar-toggle-btn:hover {
            background-color: var(--accent-primary);
            color: white;
        }
        body.sidebar-collapsed #sidebar-toggle-btn .feather-chevron-left {
            transform: rotate(180deg);
        }

        .collection-item .chevron { transition: transform 0.15s ease; }
        .collection-item.open > .chevron { transform: rotate(90deg); }
        .collection-item-wrapper.drop-target-folder { background-color: rgba(230, 57, 127, 0.1); border: 1px dashed var(--accent-primary); }
        .file-attachment-widget {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    background-color: var(--bg-pane-dark);
    border: 1px solid var(--border-color);
    padding: 0.75rem;
    border-radius: 0.5rem;
    margin: 1em 0;
}
.file-attachment-widget .file-info {
    flex-grow: 1;
    min-width: 0;
}
.file-attachment-widget .file-name {
    font-weight: 600;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.file-attachment-widget .file-size {
    font-size: 0.75rem;
    color: var(--text-tertiary);
}
.file-attachment-widget .download-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background-color: var(--accent-primary);
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
    font-size: 0.875rem;
    font-weight: 500;
    text-decoration: none;
    transition: opacity 0.2s;
}
.file-attachment-widget .download-btn:hover {
    opacity: 0.8;
}
.file-attachment-widget {
    position: relative; /* Needed for the delete button */
}
.attachment-delete-btn {
    position: absolute;
    top: 0.25rem; /* 4px */
    right: 0.25rem; /* 4px */
    padding: 0.125rem; /* 2px */
    border-radius: 9999px;
    background-color: var(--bg-pane-light);
    color: var(--text-tertiary);
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    cursor: pointer;
}
.file-attachment-widget:hover .attachment-delete-btn {
    opacity: 1;
}
.attachment-delete-btn:hover {
    color: #ef4444; /* A standard red color */
}
        .kanban-card {
            background-color: var(--bg-main);
            height: 140px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .kanban-card:hover { transform: translateY(-4px); box-shadow: 0 10px 15px -3px var(--shadow-color), 0 4px 6px -4px var(--shadow-color); }
        .kanban-card.dragging { opacity: 0.5; transform: rotate(3deg); }

        .kanban-card.pinned, .list-note-item.pinned {
            border-color: var(--accent-primary);
            box-shadow: 0 0 8px -2px var(--accent-primary);
        }
        .kanban-card.pinned { transform: scale(1.02); }
        .kanban-card.pinned:hover { transform: scale(1.02) translateY(-4px); }
        
        .drop-target-column { background-color: var(--bg-pane-dark) !important; opacity: 0.5; }
        .drop-indicator { height: 2px; background-color: var(--accent-primary); margin: 0; padding: 0; pointer-events: none; }
        
        .context-menu, .dropdown-menu { transition: opacity 100ms ease, transform 100ms ease; }
        
        #note-editor-body:empty:before {
            content: attr(data-placeholder);
            color: var(--text-tertiary);
            pointer-events: none;
            display: block;
        }
        #note-editor-body a, #markdown-preview a, #summary-content a, .chat-bubble a {
            color: var(--accent-primary);
            text-decoration: underline;
            cursor: pointer;
        }
        .internal-link-broken {
            color: #ef4444; /* red-500 */
            text-decoration: underline;
            text-decoration-style: dotted;
            cursor: help;
        }
        #note-editor-body ul:not(.checklist-body), #markdown-preview ul, #summary-content ul, .chat-bubble ul, .ai-summary ul { list-style: disc; padding-left: 2rem; margin-top: 0.5rem; margin-bottom: 0.5rem; }
        #note-editor-body ol, #markdown-preview ol, #summary-content ol, .chat-bubble ol, .ai-summary ol { list-style: decimal; padding-left: 2rem; margin-top: 0.5rem; margin-bottom: 0.5rem; }
        #note-editor-body h1, #note-editor-body h2, #note-editor-body h3,
        #markdown-preview h1, #markdown-preview h2, #markdown-preview h3 #public-note-content h1, #public-note-content h2, #public-note-content h3 {

             font-weight: 700;
             line-height: 1.2;
             margin-top: 1em;
             margin-bottom: 0.5em;
             padding-bottom: 0.3em;
             border-bottom: 1px solid var(--border-color);
        }
        #note-editor-body h1, #markdown-preview h1 { font-size: 2.25rem; }
        #note-editor-body h2, #markdown-preview h2 { font-size: 1.875rem; }
        #note-editor-body h3, #markdown-preview h3 { font-size: 1.5rem; }
        #note-editor-body img, #markdown-preview img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 0.5em 0;
            cursor: default;
        }
        #note-editor-body blockquote, #markdown-preview blockquote, #summary-content blockquote, .chat-bubble blockquote, .ai-summary blockquote {
            border-left: 4px solid var(--border-color);
            padding-left: 1em;
            margin-left: 0;
            color: var(--text-secondary);
        }
        
        /* Inline code and Monospace */
        #note-editor-body code, #markdown-preview code {
            background-color: var(--bg-pane-dark);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9em;
        }

        #note-editor-body pre code, #markdown-preview pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            font-size: 1em;
        }
        
        #markdown-preview pre {
            background-color: var(--bg-pane-dark);
            padding: 1em;
            border-radius: 8px;
            overflow-x: auto;
        }
        #markdown-preview pre code.hljs {
            padding: 0;
            background-color: transparent;
        }
        
        /* Editor Code Block Styles */
        #note-editor-body .code-block-wrapper, #markdown-preview .code-block-wrapper, #public-note-content .code-block-wrapper {
            background-color: #211F30;
            border-radius: 8px;
            margin: 1.5em 0;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }
        html.light #note-editor-body .code-block-wrapper, html.dark #note-editor-body .code-block-wrapper {
             background-color: #1f2937; /* A consistent dark background */
        }
        .code-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(0,0,0,0.2);
            padding: 0.5rem 1rem;
            color: var(--text-secondary);
            font-size: 0.8rem;
            text-transform: uppercase;
        }
        .copy-code-btn, .delete-block-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 5px;
            transition: background-color 0.2s, color 0.2s;
        }
        .copy-code-btn:hover, .delete-block-btn:hover {
            background-color: var(--bg-pane-light);
        }
        .copy-code-btn:hover { color: var(--text-primary); }
        .delete-block-btn:hover { color: #ef4444; }

        #note-editor-body .code-block-wrapper pre, #markdown-preview .code-block-wrapper pre, #public-note-content .code-block-wrapper pre {
            margin: 0 !important;
            padding: 1em !important;
            background-color: transparent !important;
            white-space: pre-wrap;
            /** change to pre if you want horizontal scroll but need fix **/
            word-wrap: break-word;
        }
        #note-editor-body .code-block-wrapper pre code, #markdown-preview .code-block-wrapper pre code, #public-note-content .code-block-wrapper pre code {
            padding: 0 !important;
            background-color: transparent !important;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace !important;
            font-size: 1em !important;
        }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        #search-results-view mark {
            background-color: var(--accent-primary-dark);
            border-radius: 3px;
            padding: 1px 2px;
            color: var(--bg-main);
        }
        
        .column-header:hover .delete-column-btn { opacity: 1; }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .summarize-btn {
    transition: opacity 0.2s ease-in-out;
}
        .list-note-item:hover .summarize-btn { opacity: 1; }

        .chat-bubble { max-width: 80%; }
        .chat-bubble.user { background-image: linear-gradient(to right, var(--brand-grad-from), var(--brand-grad-to)); color: white; }
        .chat-bubble.model { background-color: var(--bg-pane-dark); }
        .chat-bubble.thinking {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: .5; }
        }

        .truncate-multiline {
            display: -webkit-box;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .kanban-card .card-content { -webkit-line-clamp: 3; }
        .list-note-item .card-content { -webkit-line-clamp: 2; }
        
        .view-btn {
             color: var(--text-secondary);
             transition: all 0.2s ease-in-out;
        }
        .view-btn.active {
             background-color: var(--bg-main);
             color: var(--text-primary);
             box-shadow: 0 1px 3px 0 var(--shadow-color);
        }
        .reputify-theme .view-btn.active {
             box-shadow: 0 1px 5px 0 rgba(0,0,0,0.2);
        }

        .settings-footer-item {
            @apply w-full text-left px-3 py-2 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-3 text-text-secondary hover:text-text-primary;
        }
        
        #dictate-btn.recording {
            color: #ef4444; /* red-500 */
            animation: pulse-red 1.5s infinite;
        }
        @keyframes pulse-red {
          0%, 100% { opacity: 1; }
          50% { opacity: .6; }
        }
        
        #tag-list-container .tag-filter-item.active {
            background-color: var(--accent-primary);
            color: white;
            font-weight: 600;
        }
        /* --- START: Full Page Mobile Menu CSS --- */
#mobile-menu-fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: var(--bg-main);
    z-index: 100;
    display: flex;
    flex-direction: column;
    padding: 1rem;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    pointer-events: none;
}

#mobile-menu-fullscreen.open {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
}

#mobile-menu-fullscreen-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem;
    flex-shrink: 0;
}

#mobile-menu-fullscreen-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--text-primary);
}

#mobile-menu-fullscreen-content {
    flex-grow: 1;
    overflow-y: auto;
    padding-top: 1rem;
}

/* Style for the individual menu items */
#mobile-menu-fullscreen-content button {
    display: flex;
    align-items: center;
    gap: 1rem;
    width: 100%;
    padding: 1rem;
    text-align: left;
    font-size: 1rem;
    border-radius: 0.5rem;
    color: var(--text-secondary);
    transition: background-color 0.2s, color 0.2s;
}

#mobile-menu-fullscreen-content button:hover {
    background-color: var(--bg-pane-dark);
    color: var(--text-primary);
}

#mobile-menu-fullscreen-content hr {
    border-color: var(--border-color);
    margin: 0.5rem 0;
}

#mobile-menu-fullscreen-content .text-red-500 {
    color: #ef4444; /* red-500 */
}
/* --- END: Full Page Mobile Menu CSS --- */
        /* --- START: Mobile Inline Toolbar Scroll --- */
        /* --- START: Mobile Header Spacing Fix --- */
body.mobile-editor-active #mobile-sticky-toolbar {
    top: 0 !important;
}
/* --- END: Mobile Header Spacing Fix --- */
@media (max-width: 767px) {
    #inline-toolbar {
        display: none !important; /* This completely hides the old toolbar on mobile */
        max-width: 200px; /* Limit the width on mobile */
    }
    #inline-toolbar-buttons {
        scroll-behavior: smooth;
    }
    .toolbar-scroll-btn {
        display: flex; /* Show the scroll buttons on mobile */
        align-items: center;
        justify-content: center;
        cursor: pointer;
    }
}
/* --- END: Mobile Inline Toolbar Scroll --- */

        /* Mobile-specific overrides */
        @media (max-width: 767px) {
            #notes-list-pane {
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                z-index: 40; /* Higher z-index for mobile overlay */
                transform: translateX(-100%);
                width: 280px !important; /* Fixed width for mobile overlay */
                border-right-width: 1px;
            }
            #search-bar-container {
        padding-left: 0.75rem;  /* 12px */
        padding-right: 0.75rem; /* 12px */
    }

    /* Target the inner div that holds the icons and input */
    #search-bar-container > div {
        padding-left: 1rem;     /* 16px padding for the search icon */
        padding-right: 0.5rem;  /* 8px padding for the 'X' icon */
    }

    /* Remove the negative margin on the close button that causes it to protrude */
    #search-bar-container #search-close-btn {
        margin-right: 0;
    }
            #highlight-controls {
        padding-right: 0.75rem; /* Pushes the 'X' icon inward */
    }

    /* START: In-Note Search Bar Mobile Fix */
    /* --- START: In-Note Search Bar Mobile Polish --- */
/* Controls the container to ensure centering and spacing from screen edges */
#highlight-controls {
    padding: 0.5rem 0.75rem; /* 8px top/bottom, 12px left/right for symmetry */
}

/* Main search bar styling */
#in-note-search-bar {
    height: 44px;           /* Reduced height for better proportions */
    gap: 0.25rem;           /* Reduces space between all items */
    padding-left: 0.75rem;   /* 12px padding on the left */
    padding-right: 0.25rem;  /* 4px padding on the right to hug the 'X' button */
}

/* Target the text counter ("1 of 2") to make it narrower */
#in-note-search-bar #in-note-search-count {
    width: auto;        /* Let it size to its content */
    padding: 0 0.25rem; /* Add a little horizontal space */
}

/* Rely on flexbox 'items-center' for vertical alignment of input text */
#in-note-search-bar #in-note-search-input {
    padding-top: 0;
    padding-bottom: 0;
}
/* --- END: In-Note Search Bar Mobile Polish --- */
            #main-header {
           @apply z-10; /* Ensures the header stays above the content area */
        }

        #notes-list-pane .sidebar-content-wrapper {
            transition: opacity 150ms ease-in-out;
        }
            #notes-list-pane.open {
                transform: translateX(0);
                box-shadow: 0 0 20px rgba(0,0,0,0.2);
            }
            #pane-resizer, #sidebar-toggle-btn { display: none; }
            #mobile-menu-button { display: block; }
            #desktop-new-note-btn { display: none; }
            #mobile-new-note-fab { display: flex; }
            #desktop-header-controls { display: none; }
            #mobile-header-controls { display: flex; }
            
        }

        #app-container {
    display: none; /* Hide the main app by default */
}
    </style>
    
    <script>
      try {
        const defaultTheme = 'reputify';
        const theme = localStorage.getItem('codex-notes-theme') || defaultTheme;
        if (theme === 'dark') {
          document.documentElement.classList.add('dark');
        } else if (theme === 'reputify') {
           document.documentElement.classList.add('reputify-theme');
        }
      } catch (e) {}
    </script>
    <script type="module">
  // Import the functions you need from the SDKs
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import {
    getAuth,
    onAuthStateChanged,
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
  import { getFirestore, enableIndexedDbPersistence } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
  import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-functions.js";

  // Your web app's Firebase configuration
  const firebaseConfig = {
  apiKey: "AIzaSyB5GkZzQaHF9WLBpHIzgTbUDshtb0-TsFM",
  authDomain: "reputifly-notes.firebaseapp.com",
  projectId: "reputifly-notes",
  storageBucket: "reputifly-notes.firebasestorage.app",
  messagingSenderId: "1085743658227",
  appId: "1:1085743658227:web:d90ba48b3b2df9fe1d3386"
};

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  
  // CORRECTED PART: Make auth and db globally available
  // CORRECTED PART: Make auth and db globally available
window.auth = getAuth(app);

// --- ADD THIS BLOCK TO ENABLE OFFLINE ---
const db = getFirestore(app);
enableIndexedDbPersistence(db)
  .catch((err) => {
    if (err.code == 'failed-precondition') {
      // This can happen if you have multiple tabs open.
      console.warn("Firestore persistence failed: multiple tabs open.");
    } else if (err.code == 'unimplemented') {
      // The browser is likely too old to support this feature.
      console.error("Firestore persistence is not supported in this browser.");
    }
  });
// --- END OF NEW BLOCK ---

window.db = db; // This now uses the offline-enabled db instance
window.functions = getFunctions(app,);
    

  // This is our new entry point!
  // This is our new entry point!
  // This is our new entry point!
  onAuthStateChanged(window.auth, (user) => {
    // --- ADD THESE TWO LINES ---
    const params = new URLSearchParams(window.location.search);
    if (params.has('view')) return; // If it's a share link, STOP here.

    const authContainer = document.getElementById('auth-container');
    const appContainer = document.getElementById('app-container');
    
    // START: MODIFIED SECTION
    const chatbotFab = document.getElementById('chatbot-fab');
    const mobileFab = document.getElementById('mobile-new-note-fab');
    // END: MODIFIED SECTION

    if (user) {
          // User is signed in.
          console.log('User is logged in:', user.uid);
          if (authContainer) authContainer.style.display = 'none';
          if (appContainer) appContainer.style.display = 'flex';
          
          // START: MODIFIED SECTION
          // Restore button visibility
          if (chatbotFab) chatbotFab.style.display = 'flex';
          if (mobileFab) mobileFab.style.display = 'flex'; // CSS will handle hiding on desktop
          // END: MODIFIED SECTION

          // --- START: PROFILE LOGIC ---
          const userInitial = document.getElementById('user-initial');
          const userEmailDisplay = document.getElementById('user-email-display');
          const profileButton = document.getElementById('profile-button');
          const profileDropdown = document.getElementById('profile-dropdown');
          const signOutLink = document.getElementById('sign-out-link');

          if (user.email) {
              userInitial.textContent = user.email.charAt(0).toUpperCase();
              userEmailDisplay.textContent = user.email;
              userEmailDisplay.title = user.email;
          }

          if(profileButton) { // Check if button exists before adding listener
            profileButton.addEventListener('click', (e) => {
                e.stopPropagation();
                if(profileDropdown) profileDropdown.classList.toggle('hidden');
                // Re-render icons if the dropdown is shown
                if (profileDropdown && !profileDropdown.classList.contains('hidden')) {
                  feather.replace();
                }
            });
          }

          if(signOutLink) { // Check if link exists
  signOutLink.addEventListener('click', async (e) => {
      e.preventDefault();
      try {
          // Import the necessary functions from Firebase SDKs
          const { signOut } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js");
          const { terminate } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");

          // 1. Terminate the Firestore instance to clear the local IndexedDB cache
          if (window.db) {
              await terminate(window.db);
              console.log("Firestore instance terminated and cache cleared.");
          }

          // 2. Sign the user out
          await signOut(window.auth);

          // 3. Reload the page to ensure a completely clean state for the next user
          window.location.reload();

      } catch (error) {
          console.error('Sign out process failed:', error);
          // As a fallback, still try to sign out and reload to be safe
          const { signOut } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js");
          await signOut(window.auth).catch(e => console.error("Fallback signout failed", e));
          window.location.reload();
      }
  });
}
          // --- END: PROFILE LOGIC ---
          
          // Make sure init() is defined before calling it
          if (window.appInit) {
              window.appInit();
          }
      } else {
      // User is signed out.
      console.log('User is logged out.');
      if (authContainer) authContainer.style.display = 'flex';
      if (appContainer) appContainer.style.display = 'none';

      // START: MODIFIED SECTION
      // Hide buttons on login/signup page
      if (chatbotFab) chatbotFab.style.display = 'none';
      if (mobileFab) mobileFab.style.display = 'none';
      // END: MODIFIED SECTION
    }
  });
</script>
</head>
<body class="overflow-hidden">
    <div id="auth-container" class="flex items-center justify-center h-screen bg-bg-main">
    <div class="w-full max-w-sm p-8 space-y-6 bg-bg-pane-light rounded-lg shadow-xl">
        <div>
            <h2 id="auth-title" class="text-2xl font-bold text-center text-text-primary">Login to Your Notes</h2>
        </div>
        <form id="login-form" class="space-y-4">
            <div>
                <label for="login-email" class="text-sm font-medium text-text-secondary">Email address</label>
                <input id="login-email" name="email" type="email" required class="w-full px-3 py-2 mt-1 bg-bg-pane-dark border border-border-color rounded-md focus:outline-none focus:ring-2 focus:ring-accent-primary">
            </div>
            <div>
                <label for="login-password" class="text-sm font-medium text-text-secondary">Password</label>
                <input id="login-password" name="password" type="password" required class="w-full px-3 py-2 mt-1 bg-bg-pane-dark border border-border-color rounded-md focus:outline-none focus:ring-2 focus:ring-accent-primary">
            </div>
            <p id="auth-error" class="text-sm text-red-500 h-5"></p>
            <button type="submit" class="w-full brand-button text-white font-semibold py-2 rounded-lg hover:opacity-90 transition-opacity">Login</button>
        </form>
        <p class="text-sm text-center text-text-secondary">
            <span id="login-text-link">Don't have an account? <a href="#" id="show-signup" class="font-medium text-accent-primary hover:underline">Sign up</a></span>
            <span id="signup-text-link" class="hidden">Already have an account? <a href="#" id="show-login" class="font-medium text-accent-primary hover:underline">Login</a></span>
        </p>
    </div>
</div>

    <div id="app-container" class="flex h-screen">

        <aside id="notes-list-pane" class="w-[280px] bg-bg-pane-light border-r border-border-color flex flex-col flex-shrink-0">
            <div class="sidebar-content-wrapper flex flex-col h-full min-w-[280px]">
                <header class="flex justify-between items-center p-4 border-b border-border-color flex-shrink-0 gap-2 h-[65px]">
                    <div class="flex items-center gap-3">
                        <div id="profile-section" class="relative">
                            <button id="profile-button" title="Account Settings" class="w-8 h-8 rounded-full bg-gradient-to-r from-[var(--brand-grad-from)] to-[var(--brand-grad-to)] flex items-center justify-center font-bold text-white hover:opacity-90 transition-opacity">
                                <div id="user-initial">R</div>
                            </button>
                            <div id="profile-dropdown" class="dropdown-menu hidden absolute top-full left-0 mt-2 w-52 bg-bg-pane-light shadow-2xl rounded-md p-1 border border-border-color origin-top-left z-20">
                                <div class="px-2 py-2 border-b border-border-color">
                                    <p class="text-sm font-semibold text-text-primary">Signed in as</p>
                                    <p id="user-email-display" class="text-sm text-text-secondary truncate" title="user-email"></p>
                                </div>
                                <div class="p-1">
                                    <a href="#" id="sign-out-link" class="w-full text-left px-2 py-1.5 text-sm hover:bg-bg-pane-dark text-red-500 rounded flex items-center gap-2">
                                        <i data-feather="log-out" class="w-4 h-4"></i>
                                        <span>Sign Out</span>
                                    </a>
                                </div>
                            </div>
                        </div>
                        <h1 class="text-lg font-bold text-text-primary">Notes</h1>
                    </div>
                    <div class="flex items-center gap-2 flex-shrink-0">
                        <div id="view-switcher-container" class="view-switcher bg-bg-pane-dark p-1 rounded-lg flex">

                            <button class="view-btn px-2.5 py-1 rounded" title="Calendar View" data-view="calendar"><i data-feather="calendar" class="w-4 h-4"></i></button>

                          <button class="view-btn px-2.5 py-1 rounded hidden md:flex" title="Board View" data-view="board"><i data-feather="trello" class="w-4 h-4"></i></button>
                          <button class="view-btn px-2.5 py-1 rounded" title="List View" data-view="list"><i data-feather="list" class="w-4 h-4"></i></button>
                        </div>
                        <button id="new-collection-btn" class="text-text-secondary hover:text-accent-primary transition-colors flex-shrink-0"><i data-feather="plus"></i></button>
                    </div>
                </header>
                <div id="collections-list-container" class="flex-grow p-2 overflow-y-auto custom-scrollbar"></div>


                
                <div id="tag-panel" class="p-2 border-t border-border-color flex-shrink-0">
    <div class="flex justify-between items-center px-2">
        <h3 class="font-bold text-sm uppercase tracking-wider py-1 text-text-secondary">Tags</h3>
        <button id="toggle-tags-btn" class="p-1 rounded-full hover:bg-bg-pane-dark">
            <i data-feather="chevron-down" class="w-4 h-4 transition-transform duration-200"></i>
        </button>
    </div>
    <div id="tag-list-container" class="mt-1 space-y-1 max-h-32 overflow-y-auto transition-all duration-300 custom-scrollbar"></div>
</div>

                <footer class="p-2 border-t border-border-color flex-shrink-0">
                    <div id="settings-panel">
                        <div class="flex justify-between items-center px-2">
                            <h3 class="font-bold text-sm uppercase tracking-wider py-1 text-text-secondary">Settings</h3>
                            <button id="toggle-settings-btn" class="p-1 rounded-full hover:bg-bg-pane-dark">
                                <i data-feather="chevron-down" class="w-4 h-4 transition-transform duration-200"></i>
                            </button>
                        </div>
                        <div id="settings-list-container" class="mt-1 space-y-1 transition-all duration-300">
                             <button id="theme-toggle" class="settings-footer-item">
                               <i data-feather="star" id="theme-reputify-icon" class="hidden w-5 h-5"></i>
                               <i data-feather="sun" id="theme-sun-icon" class="hidden w-5 h-5"></i>
                               <i data-feather="moon" id="theme-moon-icon" class="hidden w-5 h-5"></i>
                               <span id="theme-text">Reputify Theme</span>
                            </button>
                            <button data-action="import" class="settings-footer-item">
                                <i data-feather="upload" class="w-5 h-5"></i>
                                <span>Import Data</span>
                            </button>
                            <button data-action="export" class="settings-footer-item">
                                <i data-feather="download" class="w-5 h-5"></i>
                                <span>Export Data</span>
                            </button>
                            <button id="chatbot-toggle-btn" class="settings-footer-item">
        <i data-feather="message-square" class="w-5 h-5"></i>
        <span>Show Chatbot Button</span>
    </button>

                            <button id="bookmarklet-info-btn" class="settings-footer-item">
                                <i data-feather="book" class="w-5 h-5"></i>
                                <span>Web Clipper</span>
                            </button>
                            <button id="toggle-properties-btn" class="settings-footer-item">
                            <i data-feather="eye" class="w-5 h-5"></i>
                            <span>Hide Properties</span>
                        </button>
                        <button id="manage-sharing-btn" class="settings-footer-item">
    <i data-feather="share-2" class="w-5 h-5"></i>
    <span>Manage Sharing</span>
</button>
                        </div>
                    </div>
                    <input type="file" id="import-file-input" class="hidden" accept=".json">
                </footer>
            </div>
        </aside>
        
        <div id="pane-resizer" class="w-1.5 h-full cursor-col-resize z-10 bg-transparent hover:bg-accent-primary hidden md:block"></div>
        
        <button id="sidebar-toggle-btn" title="Toggle Sidebar" class="absolute top-1/2 -translate-y-1/2 w-6 h-12 bg-bg-pane-dark text-text-secondary flex items-center justify-center rounded-r-lg z-20 hidden md:flex">
            <i data-feather="chevron-left" class="w-5 h-5"></i>
        </button>

        <main id="editor-pane" class="flex-grow bg-bg-main flex flex-col">
           <header id="main-header" class="flex justify-between items-center p-4 border-b border-border-color flex-shrink-0 relative h-[65px]">
   <div id="header-main-content" class="flex justify-between items-center w-full transition-opacity duration-200">
       <div class="flex items-center gap-2 flex-shrink min-w-0">
         <button id="mobile-menu-button" class="md:hidden p-1 -ml-1"><i data-feather="menu" class="w-6 h-6"></i></button>
         <div class="flex items-center gap-2">
    <h2 id="current-view-title" class="text-lg font-semibold"></h2>
    <div id="save-indicator" title="Unsaved Changes"></div>
</div>
       </div>
       
       <div id="desktop-header-controls" class="hidden md:flex items-center gap-4">
           <div class="flex-grow"></div>
           <div class="flex items-center gap-2">
               <button id="header-search-icon" class="p-2 hover:bg-bg-pane-dark rounded-lg text-text-secondary" title="Search (Cmd+F)"><i data-feather="search" class="w-4 h-4"></i></button>
               <button id="global-ai-btn" class="p-2 hover:bg-bg-pane-dark rounded-lg text-text-secondary" title="Ask Your Notes (AI Search)"><i data-feather="message-circle" class="w-4 h-4"></i></button>
               <div id="list-view-controls" class="hidden items-center gap-2">
                 <label for="sort-order" class="text-sm text-text-secondary">Sort by:</label>
                 <select id="sort-order" class="bg-bg-pane-dark text-text-primary text-sm rounded-md p-1 border-0 focus:ring-2 focus:ring-accent-primary">
                     <option value="modifiedAt-desc">Last Modified</option>
                     <option value="createdAt-desc">Date Created</option>
                     <option value="name-asc">Title (A-Z)</option>
                 </select>
               </div>
               <div class="editor-toolbar flex items-center bg-bg-pane-dark p-1 rounded-lg">
                   <button id="header-summarize-btn" class="p-2 hover:bg-bg-main rounded-l-md" title="AI Summary"><i data-feather="zap" class="w-4 h-4"></i></button>
<button id="header-quiz-btn" class="p-2 hover:bg-bg-main" title="MCQ Quiz"><i data-feather="help-circle" class="w-4 h-4"></i></button>
<button id="header-share-btn" class="p-2 hover:bg-bg-main" title="Share Note (Read-only)"><i data-feather="share-2" class="w-4 h-4"></i></button>
<button id="header-collaborate-btn" class="p-2 hover:bg-bg-main" title="Share & Collaborate"><i data-feather="users" class="w-4 h-4"></i></button>

                   <div id="expandable-toolbar-buttons" class="hidden items-center">
                        <button id="dictate-btn" class="p-2 hover:bg-bg-main" title="Dictate Text"><i data-feather="mic" class="w-4 h-4"></i></button>
                        <button id="header-flashcard-btn" class="p-2 hover:bg-bg-main" title="Flashcard Mode"><i data-feather="copy" class="w-4 h-4"></i></button>
                        <button id="graph-btn" class="p-2 hover:bg-bg-main" title="Show Note Graph"><i data-feather="git-merge" class="w-4 h-4"></i></button>
                        <button id="header-checkpoint-btn" class="p-2 hover:bg-bg-main" title="Save Checkpoint"><i data-feather="flag" class="w-4 h-4"></i></button>
                        <button id="header-template-btn" class="p-2 hover:bg-bg-main" title="Save as Template"><i data-feather="save" class="w-4 h-4"></i></button>

                        <button id="history-btn" class="p-2 hover:bg-bg-main" title="Version History"><i data-feather="clock" class="w-4 h-4"></i></button>
                        <button id="editor-mode-toggle" class="p-2 hover:bg-bg-main disabled:opacity-50 disabled:cursor-not-allowed" title="Toggle Markdown Preview"><i data-feather="eye" class="w-4 h-4"></i></button>
                        <button data-command="ocr" class="p-2 hover:bg-bg-main" title="Scan Image for Text"><i data-feather="camera" class="w-4 h-4"></i></button>
                        <input type="file" id="ocr-file-input" class="hidden" accept="image/*">
                   </div>

                   <button id="toggle-toolbar-btn" class="p-2 hover:bg-bg-main rounded-r-md">
                       <i id="toolbar-toggle-icon" data-feather="chevron-right" class="w-4 h-4"></i>
                   </button>
               </div>
               <div class="relative" id="new-note-dropdown-container">
    <button id="desktop-new-note-btn" class="brand-button text-white px-4 py-2 rounded-lg font-semibold text-sm flex items-center gap-2 hover:opacity-90 transition-opacity" title="New Note (Cmd+N)">New Note <i data-feather="chevron-down" class="w-4 h-4"></i></button>
    <div id="new-note-dropdown" class="dropdown-menu hidden absolute top-full right-0 mt-2 w-48 bg-bg-pane-light shadow-2xl rounded-md p-1 border border-border-color origin-top-right z-20">
        <button data-action="new-blank-note" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="file" class="w-4 h-4"></i>New Blank Note</button>
        <button data-action="new-from-template" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="file-plus" class="w-4 h-4"></i>New from Template</button>
    </div>
</div>
           </div>
       </div>

       <div id="mobile-header-controls" class="flex md:hidden items-center gap-2 relative">
         <button id="mobile-search-icon" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="search" class="w-5 h-5"></i></button>
         <button id="mobile-global-ai-btn" class="p-2 rounded-full hover:bg-bg-pane-dark" title="Ask Your Notes"><i data-feather="message-circle" class="w-5 h-5"></i></button>
         <button id="mobile-more-button" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="more-vertical" class="w-5 h-5"></i></button>
         <div id="mobile-controls-dropdown" class="dropdown-menu hidden absolute top-full right-0 mt-2 w-48 bg-bg-pane-light shadow-2xl rounded-md p-2 border-border-color origin-top-right scale-95 opacity-0 z-30">
</div>

<div id="mobile-menu-fullscreen" class="">
    <div id="mobile-menu-fullscreen-header">
        <h2 id="mobile-menu-fullscreen-title">Actions</h2>
        <button id="mobile-menu-fullscreen-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark">
            <i data-feather="x" class="w-6 h-6"></i>
        </button>
    </div>
    <div id="mobile-menu-fullscreen-content" class="custom-scrollbar">
        </div>
</div>
       </div>
   </div>

    <div id="search-bar-container" class="hidden md:absolute md:top-1/2 md:left-1/2 md:-translate-x-1/2 md:-translate-y-1/2 z-10 w-full md:w-[95%] md:max-w-[500px]">
         <div class="bg-bg-pane-dark rounded-full shadow-lg flex items-center px-4 w-full">
             <i data-feather="search" class="text-text-tertiary"></i>
             <input id="search-input" type="text" placeholder="Search notes and folders..." class="w-full bg-transparent p-3 focus:outline-none text-text-primary">
             <button id="search-close-btn" class="p-2 -mr-2 rounded-full text-text-tertiary hover:bg-bg-main">
                <i data-feather="x" class="w-5 h-5"></i>
             </button>
         </div>
     </div>
</header>
<input type="file" id="file-upload-input" class="hidden" accept=".csv, application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, image/*, .pdf, .txt, .md" />

           
           <div id="mobile-sticky-toolbar" class="hidden md:hidden sticky top-[65px] z-20 bg-bg-pane-dark p-2 border-b border-border-color">
    <div class="flex items-center gap-1 overflow-x-auto no-scrollbar">
        <button data-command="bold" class="p-2 hover:bg-bg-main rounded flex-shrink-0"><i data-feather="bold" class="w-4 h-4"></i></button>
        <button data-command="italic" class="p-2 hover:bg-bg-main rounded flex-shrink-0"><i data-feather="italic" class="w-4 h-4"></i></button>
        <button data-command="createLink" class="p-2 hover:bg-bg-main rounded flex-shrink-0"><i data-feather="link" class="w-4 h-4"></i></button>
        <button data-command="insertImage" class="p-2 hover:bg-bg-main rounded flex-shrink-0"><i data-feather="image" class="w-4 h-4"></i></button>
        <button id="mobile-attach-file-btn" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Attach File"><i data-feather="paperclip" class="w-4 h-4"></i></button>
        <button data-command="formatBlock" data-value="code" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Code Block"><i data-feather="code" class="w-4 h-4"></i></button>
        <button data-command="formatBlock" data-value="blockquote" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Quote"><strong>&ldquo;</strong></button>
        <button data-command="insertTable" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Insert Table"><i data-feather="grid" class="w-4 h-4"></i></button>
        <button data-command="monospace" class="p-2 hover:bg-bg-main rounded font-mono font-bold flex-shrink-0" title="Monospace">M</button>
        <button data-command="insertChecklist" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Checklist"><i data-feather="check-square" class="w-4 h-4"></i></button>
        <div class="w-px h-5 bg-border-color mx-1 flex-shrink-0"></div>
        <button data-command="textColor" data-value="red" class="p-1.5 hover:bg-bg-main rounded-full flex-shrink-0 toolbar-color-btn" title="Text Color Red"><span class="block w-4 h-4 rounded-full color-swatch-indicator" style="background-color: #F87171;"></span></button>
<button data-command="textColor" data-value="orange" class="p-1.5 hover:bg-bg-main rounded-full flex-shrink-0 toolbar-color-btn" title="Text Color Orange"><span class="block w-4 h-4 rounded-full color-swatch-indicator" style="background-color: #FB923C;"></span></button>
<button data-command="textColor" data-value="green" class="p-1.5 hover:bg-bg-main rounded-full flex-shrink-0 toolbar-color-btn" title="Text Color Green"><span class="block w-4 h-4 rounded-full color-swatch-indicator" style="background-color: #4ADE80;"></span></button>
<button data-command="textColor" data-value="blue" class="p-1.5 hover:bg-bg-main rounded-full flex-shrink-0 toolbar-color-btn" title="Text Color Blue"><span class="block w-4 h-4 rounded-full color-swatch-indicator" style="background-color: #60A5FA;"></span></button>

        <div class="w-px h-5 bg-border-color mx-1 flex-shrink-0"></div>
        <button data-command="formatBlock" data-value="h1" class="p-2 hover:bg-bg-main rounded font-bold text-sm flex-shrink-0">H1</button>
        <button data-command="formatBlock" data-value="h2" class="p-2 hover:bg-bg-main rounded font-bold text-sm flex-shrink-0">H2</button>
        <button data-command="formatBlock" data-value="h3" class="p-2 hover:bg-bg-main rounded font-bold text-sm flex-shrink-0">H3</button>
    </div>
</div>
<div id="main-content-area" class="flex-grow overflow-y-auto relative flex flex-col custom-scrollbar">

            
                <div id="board-view" class="notes-view active flex-grow p-4 md:p-5 overflow-x-auto no-scrollbar h-full">
                    

                    <div id="kanban-board" class="flex gap-4 min-h-full"></div>
                </div>
                <div id="calendar-view" class="notes-view hidden flex-grow p-4 pb-24 md:p-5 flex flex-col"></div>
                <div id="gallery-view" class="notes-view hidden flex-grow p-4 md:p-5"></div>

                <div id="list-view" class="notes-view hidden flex-grow p-4 pb-24 md:p-5">
                    <div id="notes-list-content" class="space-y-4"></div>
                </div>
                <div id="note-editor-view" class="notes-view hidden flex-grow flex flex-col pb-24 md:pb-1">
                    <div id="highlight-controls" class="hidden sticky top-0 z-20 p-2 bg-bg-main">
<div id="in-note-search-bar" class="w-full mx-auto bg-bg-pane-dark shadow-lg rounded-full p-1 flex items-center gap-1 text-base border border-border-color px-4">
        <input id="in-note-search-input" type="text" placeholder="Find in note..." class="flex-grow bg-transparent rounded-full px-3 py-1 focus:outline-none">
        <span id="in-note-search-count" class="text-text-tertiary w-20 text-center flex-shrink-0">No results</span>
        <div class="h-5 w-px bg-border-color"></div>
        <button id="in-note-search-prev" title="Previous" class="p-1 hover:bg-bg-main rounded-full text-text-secondary disabled:opacity-50" disabled><i data-feather="chevron-up" class="w-5 h-5"></i></button>
        <button id="in-note-search-next" title="Next" class="p-1 hover:bg-bg-main rounded-full text-text-secondary disabled:opacity-50" disabled><i data-feather="chevron-down" class="w-5 h-5"></i></button>
        <div class="h-5 w-px bg-border-color"></div>
        <button id="clear-search-btn" title="Close Search & Clear Highlights" class="p-1 hover:bg-bg-main rounded-full text-text-tertiary mr-1">
            <i data-feather="x" class="w-5 h-5"></i>
        </button>
    </div>
</div>
                    <div class="p-4 md:p-8 md:pb-4 flex-shrink-0">
    <div id="note-properties-container" class="text-sm text-text-tertiary mb-4 py-2"></div>


    <textarea id="note-editor-title" placeholder="Untitled Note" class="text-3xl md:text-4xl font-bold bg-transparent focus:outline-none mb-4 w-full overflow-hidden resize-none" rows="1"></textarea>
</div>
                    <div id="note-editor-body" contenteditable="true" class="flex-grow text-lg leading-relaxed focus:outline-none px-4 md:px-8 pt-2 md:pt-4 pb-4 md:pb-8" data-placeholder="Start writing or drop an image..."></div>
                    <div id="markdown-preview" class="hidden flex-grow text-lg leading-relaxed focus:outline-none p-4 md:p-8 prose"></div>
                    <div id="backlinks-pane" class="hidden p-4 md:px-8 border-t border-border-color">
    <div class="flex justify-between items-center mb-3">
        <div class="flex items-center gap-2">
            <h4 class="font-semibold text-sm uppercase tracking-wider text-text-secondary">Linked Here</h4>
            <button id="toggle-backlinks-btn" class="p-1 rounded-full hover:bg-bg-pane-dark">
                <i data-feather="chevron-down" class="w-4 h-4 transition-transform duration-200"></i>
            </button>
        </div>
        <button id="summarize-backlinks-btn" class="flex items-center gap-2 text-sm text-accent-primary hover:opacity-80 transition-opacity" title="Summarize all linked notes with AI">
            <i data-feather="zap" class="w-4 h-4"></i>
            <span>AI Summary</span>
        </button>
    </div>
    <div id="backlinks-list" class="space-y-3 transition-all duration-300"></div>
</div>
                    <div id="editor-footer" class="p-4 text-xs text-text-tertiary text-left border-t border-border-color flex-shrink-0">
                        <div id="backlinks-pane" class="hidden p-4 md:px-8 border-t border-border-color">
    <h4 class="font-semibold text-sm uppercase tracking-wider text-text-secondary mb-3">Linked here</h4>
    <div id="backlinks-list" class="space-y-2"></div>
</div>
                       <span id="word-count">0</span> Words | <span id="char-count">0</span> Characters
                    </div>
                </div>
                <div id="search-results-view" class="notes-view hidden p-4 md:p-8">
                    <h2 class="text-2xl font-bold mb-6">Search Results</h2>
                    <div id="search-results-list"></div>
                </div>
           </div>
        </main>
        <div id="table-creator-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-sm z-50 transition-all duration-300 transform scale-95 opacity-0">
    <h3 class="text-lg font-semibold mb-4">Create Table</h3>
    <div class="grid grid-cols-2 gap-4">
        <div>
            <label for="table-rows" class="text-sm font-medium text-text-secondary">Rows</label>
            <input id="table-rows" type="number" value="3" min="1" class="w-full px-3 py-2 mt-1 bg-bg-pane-dark border border-border-color rounded-md focus:outline-none focus:ring-2 focus:ring-accent-primary">
        </div>
        <div>
            <label for="table-cols" class="text-sm font-medium text-text-secondary">Columns</label>
            <input id="table-cols" type="number" value="2" min="1" class="w-full px-3 py-2 mt-1 bg-bg-pane-dark border border-border-color rounded-md focus:outline-none focus:ring-2 focus:ring-accent-primary">
        </div>
    </div>
    <div class="flex justify-end gap-3 mt-6">
        <button id="table-cancel-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Cancel</button>
        <button id="table-create-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Create</button>
    </div>
</div>
    </div><div id="public-note-view" class="hidden min-h-screen bg-bg-main text-text-primary">
    <!-- START: NEW HEADER FOR PUBLIC PAGE -->
    <header class="sticky top-0 z-10 bg-bg-main py-4 px-4 md:px-8 border-b border-border-color shadow-sm">
        
        <div class="max-w-4xl mx-auto flex justify-between items-center">
            <a href="https://reputifly.org/note" title="Back to Reputifly">
                <img src="https://reputifly.com/wp-content/uploads/2025/05/cropped-reputifly-new-e1746390492876.png" alt="Reputifly Logo" class="h-8 w-auto">
            </a>
            <a href="https://reputifly.org/note" class="brand-button text-white font-semibold px-4 py-2 rounded-lg text-sm hover:opacity-90 transition-opacity">
                Sign Up Free
            </a>
        </div>
    </header>
    <!-- END: NEW HEADER FOR PUBLIC PAGE -->

    <main class="max-w-4xl mx-auto p-4 md:p-8">
        <!-- Title will be populated by JS -->
        <h1 id="public-note-title" class="text-3xl md:text-4xl font-bold mb-6 border-b border-border-color pb-4"></h1>
        
        <button id="copy-note-btn" class="flex items-center gap-2 mb-4 text-sm text-text-secondary hover:text-text-primary transition">
            <i data-feather="copy" class="w-4 h-4"></i>
            <span>Copy Content</span>
        </button>
        
        <!-- Note content will be populated by JS. `max-w-none` ensures content fills the container. -->
        <div id="public-note-content" class="prose max-w-none"></div>

        <!-- Call to action section -->
        <div class="mt-16 p-6 bg-bg-pane-dark rounded-lg text-center">
            <h3 class="font-bold text-xl text-text-primary">Enjoying this note?</h3>
            <p class="text-text-secondary mt-2 mb-4">Create your own smart notes with AI summaries, quizzes, and more.</p>
            <a href="https://reputifly.org/signup" class="brand-button inline-block text-white font-semibold px-5 py-2.5 rounded-lg hover:opacity-90 transition-opacity">
                Create a Free Account
            </a>
        </div>

        <!-- Footer -->
        <footer class="text-center mt-12 text-sm text-text-tertiary">
            <p>Published with Reputifly AI Note Taker</p>
        </footer>
    </main>
</div>
    
    <button id="chatbot-fab" title="Ask Chatbot" class="bg-gradient-to-r from-[var(--brand-grad-from)] to-[var(--brand-grad-to)] fixed bottom-6 right-6 text-white w-14 h-14 rounded-full shadow-lg flex items-center justify-center z-20 hover:opacity-90 transition-opacity">
        <i data-feather="message-square" class="w-7 h-7"></i>
    </button>
    
    
    <div id="modal-backdrop" class="fixed inset-0 bg-black/50 z-[998] transition-opacity duration-300 opacity-0 pointer-events-none"></div>
    <div id="mobile-sidebar-overlay" class="fixed inset-0 bg-black/30 z-30 hidden md:hidden transition-opacity duration-300 opacity-0 pointer-events-none"></div>
    
    <div id="api-key-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-md z-50 transition-all duration-300 transform scale-95 opacity-100">
        <h3 class="text-lg font-semibold mb-2">Gemini API Key Required</h3>
        <p class="text-sm text-text-secondary mb-4">Please enter your Gemini API key to enable AI features. Your key is stored only in your browser's local storage.</p>
        <label for="api-key-input" class="text-xs font-semibold text-text-secondary">API Key</label>
        <input id="api-key-input" type="password" class="w-full text-sm bg-bg-pane-dark border border-border-color rounded-md py-1 px-2 focus:ring-2 focus:ring-accent-primary focus:outline-none" placeholder="Enter your key here...">
        <p id="api-key-error" class="text-red-500 text-sm mt-1 h-5"></p>
        <div class="flex justify-end gap-3 mt-4">
            <button id="api-key-confirm-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Save and Continue</button>
        </div>
    </div>
    
    <div id="prompt-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-md z-50 transition-all duration-300 transform scale-95 opacity-0">
        <h3 id="prompt-title" class="text-lg font-semibold mb-4">Input Required</h3>
        <p id="prompt-message" class="text-sm text-text-secondary mb-3"></p>
        <input id="prompt-input" type="text" autocomplete="off" class="w-full bg-bg-pane-dark border border-border-color rounded-md p-2 focus:ring-2 focus:ring-accent-primary focus:outline-none">
        <p id="prompt-error" class="text-red-500 text-sm mt-1 h-5"></p>
        <div class="flex justify-end gap-3 mt-4">
            <button id="prompt-cancel-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Cancel</button>
            <button id="prompt-confirm-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Confirm</button>
        </div>
    </div>
    <div id="confirm-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-md z-60 transition-all duration-300 transform scale-95 opacity-0">
        <h3 id="confirm-title" class="text-lg font-semibold mb-4">Are you sure?</h3>
        <p id="confirm-message" class="text-sm text-text-secondary mb-6"></p>
        <div class="flex justify-end gap-3 mt-4">
            <button id="confirm-cancel-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Cancel</button>
            <button id="confirm-confirm-btn" class="px-4 py-2 rounded-md bg-red-600 text-white hover:opacity-90">Delete</button>
        </div>
    </div>
    <div id="bookmarklet-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-lg z-50 transition-all duration-300 transform scale-95 opacity-0">
        <h3 class="text-lg font-semibold mb-2 flex items-center gap-2"><i data-feather="book" class="w-5 h-5 text-accent-primary"></i>Web Clipper Bookmarklet</h3>
        <p class="text-sm text-text-secondary mb-4">Drag the link below to your browser's bookmarks bar to create a web clipper. When you're on any website, click the bookmarklet to clip selected text into a new note.</p>
        <a id="bookmarklet-link" href="#" class="inline-block brand-button text-white font-semibold px-4 py-2 rounded-lg text-sm">Clip to Reputifly Notes</a>
        <div class="mt-4 flex justify-end">
            <button id="bookmarklet-close-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Close</button>
        </div>
    </div>
    <div id="graph-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-4 rounded-lg shadow-2xl w-[90vw] max-w-3xl h-[60vh] z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
        <header class="flex justify-between items-center mb-2 flex-shrink-0">
            <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="git-merge" class="w-5 h-5 text-accent-primary"></i>Note Graph</h3>
            <button id="graph-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
        </header>
        <div id="graph-container" class="border border-border-color rounded-md flex-grow bg-bg-main"></div>
    </div>
    <div id="ai-prompt-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-lg z-50 transition-all duration-300 transform scale-95 opacity-0">
        <h3 class="text-lg font-semibold mb-4 flex items-center gap-2"><i data-feather="sparkles" class="w-5 h-5 text-accent-primary"></i>Ask AI</h3>
        <p class="text-sm text-text-secondary mb-3">Enter your prompt below. The AI-generated content will be inserted into your note.</p>
        <textarea id="ai-prompt-input" rows="4" class="w-full bg-bg-pane-dark border border-border-color rounded-md p-2 focus:ring-2 focus:ring-accent-primary focus:outline-none" placeholder="e.g., 'Write a short poem about the moon'"></textarea>
        <p id="ai-prompt-error" class="text-red-500 text-sm mt-1 h-5"></p>
        <div class="flex justify-end gap-3 mt-4">
            <button id="ai-cancel-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Cancel</button>
            <button id="ai-generate-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90 flex items-center gap-2">
                <i data-feather="play" class="w-4 h-4"></i>
                <span id="ai-generate-btn-text">Generate</span>
            </button>
        </div>
    </div>
    <div id="summary-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-xl z-50 transition-all duration-300 transform scale-95 opacity-0">
    <h3 class="text-lg font-semibold mb-2 flex items-center gap-2"><i data-feather="align-left" class="w-5 h-5 text-accent-primary"></i>AI Summary</h3>
    
    <div class="relative">
        <div id="summary-content" class="text-sm text-text-secondary mb-4 bg-bg-pane-dark p-4 rounded-md max-h-[50vh] overflow-y-auto"></div>
        <button id="summary-copy-btn" class="ai-response-copy-btn hidden" title="Copy Summary">
            <i data-feather="copy" class="w-4 h-4"></i>
        </button>
    </div>
    <footer class="flex justify-end gap-3 mt-4">
        <button id="summary-close-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Close</button>
    </footer>
</div>
    <div id="chatbot-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light rounded-lg shadow-2xl w-[90vw] max-w-2xl h-[70vh] z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
        <header class="p-4 border-b border-border-color flex justify-between items-center flex-shrink-0">
            <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="message-square" class="w-5 h-5 text-accent-primary"></i>Chat with AI</h3>
            <div class="flex items-center">
                <button id="chatbot-clear-btn" class="p-2 rounded-full hover:bg-bg-pane-dark" title="Clear Chat History"><i data-feather="trash-2" class="w-5 h-5"></i></button>
                <button id="chatbot-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
            </div>
        </header>
        <div id="chatbot-history" class="flex-grow p-4 space-y-4 overflow-y-auto">
        </div>
        <footer class="p-4 border-t border-border-color flex-shrink-0">
            <div id="chatbot-error" class="text-red-500 text-sm mb-2 h-5"></div>
            <div id="chatbot-context-pills" class="flex flex-wrap gap-1 mb-2"></div>
            <div class="flex items-center gap-2">
                <button id="chatbot-add-context-btn" title="Add Note Context" class="text-text-secondary hover:text-accent-primary p-2 rounded-full hover:bg-bg-main flex-shrink-0"><i data-feather="plus-circle" class="w-5 h-5"></i></button>
                <input id="chatbot-input" type="text" class="w-full bg-bg-pane-dark border border-border-color rounded-full py-2 px-4 focus:ring-2 focus:ring-accent-primary focus:outline-none" placeholder="Ask anything...">
                <button id="chatbot-send-btn" class="bg-gradient-to-r from-[var(--brand-grad-from)] to-[var(--brand-grad-to)] text-white rounded-full w-10 h-10 flex-shrink-0 flex items-center justify-center hover:opacity-90">
                    <i data-feather="arrow-up" class="w-5 h-5"></i>
                </button>
            </div>
        </footer>
    </div>
    
    <div id="toast-container" class="fixed top-4 left-1/2 -translate-x-1/2 z-[1000] transition-all duration-300 ease-in-out origin-top flex flex-col items-center gap-2" style="pointer-events: none;"></div>    
    <div id="inline-toolbar" class="absolute z-30 bg-bg-pane-dark p-1 rounded-lg shadow-md flex items-center gap-1 transition-all duration-150 transform scale-95 opacity-0" style="pointer-events: none;">
    <button id="toolbar-scroll-left" class="toolbar-scroll-btn hidden p-2"><i data-feather="chevron-left" class="w-4 h-4"></i></button>
    
    <div id="inline-toolbar-buttons" class="flex items-center gap-1 overflow-x-auto no-scrollbar">
        <button data-command="bold" class="p-2 hover:bg-bg-main rounded flex-shrink-0"><i data-feather="bold" class="w-4 h-4"></i></button>
        <button data-command="italic" class="p-2 hover:bg-bg-main rounded flex-shrink-0"><i data-feather="italic" class="w-4 h-4"></i></button>
        <button data-command="createLink" class="p-2 hover:bg-bg-main rounded flex-shrink-0"><i data-feather="link" class="w-4 h-4"></i></button>
        <button data-command="insertImage" class="p-2 hover:bg-bg-main rounded flex-shrink-0"><i data-feather="image" class="w-4 h-4"></i></button>
        <button id="attach-file-btn" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Attach File"><i data-feather="paperclip" class="w-4 h-4"></i></button>
        <button data-command="formatBlock" data-value="code" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Code Block"><i data-feather="code" class="w-4 h-4"></i></button>
        <button data-command="formatBlock" data-value="blockquote" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Quote"><strong>&ldquo;</strong></button>
        <button data-command="insertTable" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Insert Table"><i data-feather="grid" class="w-4 h-4"></i></button>
        <button data-command="monospace" class="p-2 hover:bg-bg-main rounded font-mono font-bold flex-shrink-0" title="Monospace">M</button>
        <button data-command="insertChecklist" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Checklist"><i data-feather="check-square" class="w-4 h-4"></i></button>
        <div class="w-px h-5 bg-border-color mx-1 flex-shrink-0"></div>
        
        <button data-command="textColor" data-value="red" class="p-1.5 hover:bg-bg-main rounded-full flex-shrink-0 toolbar-color-btn" title="Text Color Red"><span class="block w-4 h-4 rounded-full color-swatch-indicator" style="background-color: #F87171;"></span></button>
<button data-command="textColor" data-value="orange" class="p-1.5 hover:bg-bg-main rounded-full flex-shrink-0 toolbar-color-btn" title="Text Color Orange"><span class="block w-4 h-4 rounded-full color-swatch-indicator" style="background-color: #FB923C;"></span></button>
<button data-command="textColor" data-value="green" class="p-1.5 hover:bg-bg-main rounded-full flex-shrink-0 toolbar-color-btn" title="Text Color Green"><span class="block w-4 h-4 rounded-full color-swatch-indicator" style="background-color: #4ADE80;"></span></button>
<button data-command="textColor" data-value="blue" class="p-1.5 hover:bg-bg-main rounded-full flex-shrink-0 toolbar-color-btn" title="Text Color Blue"><span class="block w-4 h-4 rounded-full color-swatch-indicator" style="background-color: #60A5FA;"></span></button>

        <div class="w-px h-5 bg-border-color mx-1 flex-shrink-0"></div>
        <button data-command="formatBlock" data-value="h1" class="p-2 hover:bg-bg-main rounded font-bold text-sm flex-shrink-0">H1</button>
        <button data-command="formatBlock" data-value="h2" class="p-2 hover:bg-bg-main rounded font-bold text-sm flex-shrink-0">H2</button>
        <button data-command="formatBlock" data-value="h3" class="p-2 hover:bg-bg-main rounded font-bold text-sm flex-shrink-0">H3</button>
        
    </div>

    <button id="toolbar-scroll-right" class="toolbar-scroll-btn hidden p-2"><i data-feather="chevron-right" class="w-4 h-4"></i></button>
</div>

    <div id="context-menu" class="context-menu fixed z-50 bg-bg-pane-light shadow-2xl rounded-md p-2 w-48 border border-border-color hidden origin-top-left scale-95 opacity-0">
        <button data-action="new-note" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="file-plus" class="w-4 h-4"></i>New Note</button>
        <button data-action="new-folder" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="folder-plus" class="w-4 h-4"></i>New Folder</button>
        <hr class="my-1 border-border-color">
        <button data-action="toggle-pin" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="paperclip" class="w-4 h-4"></i><span id="pin-action-text">Pin</span></button>
        <button data-action="duplicate" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="copy" class="w-4 h-4"></i>Duplicate</button>
        <button data-action="save-as-template" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="save" class="w-4 h-4"></i>Save as Template</button>
        <button data-action="rename" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="edit-2" class="w-4 h-4"></i>Rename</button>
        <button data-action="delete" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark text-red-500 rounded flex items-center gap-2"><i data-feather="trash-2" class="w-4 h-4"></i>Delete</button>
    </div>
    <div id="quiz-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-2xl z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="help-circle" class="w-5 h-5 text-accent-primary"></i>MCQ Quiz</h3>
        <button id="quiz-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div id="quiz-content" class="text-text-secondary mb-4 p-1 rounded-md max-h-[60vh] overflow-y-auto custom-scrollbar">
        </div>
    <footer class="flex justify-end gap-3 mt-4 flex-shrink-0">
        <button id="quiz-done-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Done</button>
    </footer>
</div>
<div id="flashcard-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-xl z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="copy" class="w-5 h-5 text-accent-primary"></i>Flashcards</h3>
        <button id="flashcard-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div id="flashcard-content" class="flex-grow flex flex-col items-center justify-center">
        <div id="flashcard-container" class="w-full h-64 perspective-1000">
            <div id="flashcard" class="relative w-full h-full text-center transition-transform duration-700 transform-style-3d">
                <div id="flashcard-front" class="flashcard-face absolute w-full h-full backface-hidden bg-bg-pane-dark rounded-lg p-4 flex items-center justify-center"></div>
                <div id="flashcard-back" class="flashcard-face absolute w-full h-full backface-hidden bg-bg-pane-dark rounded-lg p-4 flex items-center justify-center transform rotate-y-180"></div>
            </div>
        </div>
    </div>
    <footer class="flex justify-between items-center mt-4 flex-shrink-0">
        <div id="flashcard-progress" class="text-sm text-text-secondary"></div>
        <div class="flex gap-3">
            <button id="flashcard-prev-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Previous</button>
            <button id="flashcard-next-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Next</button>
        </div>
    </footer>
</div>
<div id="global-ai-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-2xl z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="message-circle" class="w-5 h-5 text-accent-primary"></i>Ask Your Notes</h3>
        <button id="global-ai-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    
    <div class="modal-content-area custom-scrollbar flex-grow flex flex-col gap-4 p-1">
        <div>
            <label for="global-ai-input" class="text-sm font-medium text-text-secondary">Your Question</label>
            <textarea id="global-ai-input" rows="3" class="w-full mt-1 bg-bg-pane-dark border border-border-color rounded-md p-2 focus:ring-2 focus:ring-accent-primary focus:outline-none" placeholder="e.g., What was the design strategy for Project Centauri?"></textarea>
        </div>
        
        <div id="global-ai-answer-container" class="hidden">
            <label class="text-sm font-medium text-text-secondary">Answer from your notes</label>
            <div class="relative">
                <div id="global-ai-answer" class="text-text-secondary mt-1 bg-bg-pane-dark p-4 rounded-md prose max-w-none"></div>
                <button id="global-ai-copy-btn" class="ai-response-copy-btn hidden" title="Copy Answer">
                    <i data-feather="copy" class="w-4 h-4"></i>
                </button>
            </div>
        </div>

        <div id="global-ai-sources-container" class="hidden">
             <label class="text-sm font-medium text-text-secondary">Sources</label>
             <div id="global-ai-sources" class="mt-1 space-y-2"></div>
        </div>
    </div>
    <footer class="flex justify-between items-center mt-6 flex-shrink-0 pt-4 border-t border-border-color">
    <button id="global-ai-copy-btn-footer" class="hidden flex items-center gap-2 px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">
        <i data-feather="copy" class="w-4 h-4"></i>Copy Answer
    </button>
    <button id="global-ai-ask-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90 flex items-center gap-2 ml-auto">
        <span id="global-ai-btn-text">Ask</span>
    </button>
</footer>
</div>


    <script type="module">
        feather.replace();

        document.addEventListener('DOMContentLoaded', async () => {
            // PASTE THIS ENTIRE BLOCK RIGHT AFTER the 'DOMContentLoaded' line

// ==================================================================
//  START: CORRECT FUNCTION BLOCK
// ==================================================================
// ==================================================================
//  START: UPGRADED FUNCTION BLOCK
// ==================================================================
// ==================================================================
//  START: CORRECT FUNCTION BLOCK
// ==================================================================
// ==================================================================
//  START: UPGRADED FUNCTION BLOCK
// ==================================================================
const formatRelativeTime = (isoString) => {
    const date = new Date(isoString);
    const now = new Date();
    const seconds = Math.round((now - date) / 1000);
    const minutes = Math.round(seconds / 60);
    const hours = Math.round(minutes / 60);
    const days = Math.round(hours / 24);

    if (seconds < 60) return `${seconds}s ago`;
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    if (days < 7) return `${days}d ago`;
    return date.toLocaleDateString();
};

const displayVersionDiff = (selectedVersionContent) => {
    const viewer = document.getElementById('version-content-viewer');
    
    // Sanitize the historical content before adding it to the viewer
    viewer.innerHTML = DOMPurify.sanitize(selectedVersionContent);
    
    // Re-render Feather icons inside the new preview content.
    feather.replace();
};
// --- Manual Checkpoint Listener ---
// --- Manual Checkpoint Listener ---
// --- Manual Checkpoint Listener ---
document.getElementById('header-checkpoint-btn').addEventListener('click', async () => {
    const noteId = state.settings.activeNoteId;
    if (!noteId) return showToast('Please select a note first.', 'info');

    const message = await showPrompt({
        title: 'Save Checkpoint',
        message: 'Add a short message to describe this version:',
        placeholder: 'e.g., Initial draft completed'
    });

    if (message) {
        // FIX: Get the full note data from the cache, which includes the content.
        const noteData = window.noteCache[noteId];
        if (noteData) {
            saveNoteVersion(noteId, noteData.content, message);
            saveState(); // Persist the new version
            showToast('✅ Checkpoint saved!', 'success');
        }
    }
});
/**
 * Opens the redesigned Version History modal and sets up interactions.
 */
const closeVersionHistoryModal = () => {
    closeModal(document.getElementById('version-history-modal'));
};

const openVersionHistoryModal = () => {
    const noteId = state.settings.activeNoteId;
    if (!noteId) return;

    const modal = document.getElementById('version-history-modal');
    const listContainer = document.getElementById('version-list-container');
    const searchInput = document.getElementById('version-search-input');
    const allVersions = state.versions?.[noteId] || [];

    const formatDateHeader = (isoString) => {
        const date = new Date(isoString);
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);

        today.setHours(0, 0, 0, 0);
        yesterday.setHours(0, 0, 0, 0);
        date.setHours(0, 0, 0, 0);

        if (date.getTime() === today.getTime()) return 'Today';
        if (date.getTime() === yesterday.getTime()) return 'Yesterday';
        
        return date.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
    };

    // Located inside the init() function
const renderVersionList = (filteredVersions) => {
        if (filteredVersions.length === 0) {
            listContainer.innerHTML = `<p class="p-4 text-sm text-center text-text-tertiary">No matching versions found.</p>`;
            document.getElementById('version-content-viewer').innerHTML = '';
            document.getElementById('version-restore-btn').style.display = 'none';
            return;
        }

        const groupedVersions = {};
        filteredVersions.forEach(version => {
            const header = formatDateHeader(version.savedAt);
            if (!groupedVersions[header]) groupedVersions[header] = [];
            const originalIndex = allVersions.indexOf(version);
            groupedVersions[header].push({ ...version, originalIndex });
        });

        let finalHTML = '';
        for (const header in groupedVersions) {
            finalHTML += `<h4 class="version-group-header">${header}</h4>`;
            finalHTML += groupedVersions[header].map(versionData => {
                const { savedAt, message, content, originalIndex } = versionData;
                const formattedDate = new Date(savedAt).toLocaleString();
                const relativeTime = formatRelativeTime(savedAt);
                
                return `
                <div class="version-item group flex items-center justify-between" data-version-index="${originalIndex}" title="${formattedDate}">
                    <div class="version-item-content flex-grow cursor-pointer p-2 -m-2">
                        <div class="version-timestamp">${relativeTime}</div>
                        <div class="version-fulldate">${formattedDate}</div>
                        ${message ? `<div class="version-message">${message.replace(/</g, "&lt;")}</div>` : ''}
                    </div>
                    <button class="delete-version-btn p-1.5 rounded-full text-text-tertiary hover:text-red-500 hover:bg-bg-pane-dark opacity-0 group-hover:opacity-100 transition-opacity" data-action="delete-version" data-version-index="${originalIndex}" title="Delete this version">
                        <i data-feather="trash-2" class="w-4 h-4 pointer-events-none"></i>
                    </button>
                </div>
                `;
            }).join('');
        }
        
        document.getElementById('version-restore-btn').style.display = 'inline-flex';
        listContainer.innerHTML = finalHTML;
        
        const firstItem = listContainer.querySelector('.version-item');
        if (firstItem) {
            displayVersionDiff(filteredVersions[0].content);
            firstItem.classList.add('active');
        }
        feather.replace();
    };

    searchInput.value = '';
    renderVersionList(allVersions);

    const handleSearch = () => {
        const query = searchInput.value.toLowerCase().trim();
        const filtered = query ? allVersions.filter(v => 
            (v.content || '').toLowerCase().includes(query) || 
            (v.message || '').toLowerCase().includes(query)
        ) : allVersions;
        renderVersionList(filtered);
    };

    if (!searchInput.hasAttribute('data-listener-added')) {
        searchInput.addEventListener('input', debounce(handleSearch, 200));
        searchInput.setAttribute('data-listener-added', 'true');
    }
    
    openModal(modal);
    feather.replace();
};

const saveNoteVersion = (noteId, content, message = null) => {
    if (!state.versions) state.versions = {};
    if (!state.versions[noteId]) state.versions[noteId] = [];

    const newVersion = {
        savedAt: new Date().toISOString(),
        content: content,
        message: message
    };

    state.versions[noteId].unshift(newVersion);

    const MAX_VERSIONS = 50; // Increased limit
    if (state.versions[noteId].length > MAX_VERSIONS) {
        state.versions[noteId] = state.versions[noteId].slice(0, MAX_VERSIONS);
    }
};

document.getElementById('version-history-close-btn').addEventListener('click', closeVersionHistoryModal);

// Located inside the init() function
// Located inside the init() function
document.getElementById('version-sidebar').addEventListener('click', async (e) => {
    // Handle Delete Action
    const deleteBtn = e.target.closest('.delete-version-btn');
    if (deleteBtn) {
        e.stopPropagation(); // Prevent item selection from firing

        const versionIndex = parseInt(deleteBtn.dataset.versionIndex, 10);
        const noteId = state.settings.activeNoteId;
        const versions = state.versions?.[noteId] || [];
        const versionToDelete = versions[versionIndex];

        if (!versionToDelete) return;

        // Directly delete without confirmation
        state.versions[noteId].splice(versionIndex, 1);
        await saveState();
        openVersionHistoryModal(); // Refresh the modal to show the updated list
        showToast('Version deleted successfully.', 'success');
        
        return; // Stop after handling delete
    }

    // Handle Item Selection Action
    const versionItemContent = e.target.closest('.version-item-content');
    if (versionItemContent) {
        const versionItem = versionItemContent.closest('.version-item');
        if (!versionItem || versionItem.classList.contains('active')) return;

        document.querySelectorAll('#version-sidebar .version-item.active').forEach(el => el.classList.remove('active'));
        versionItem.classList.add('active');

        const noteId = state.settings.activeNoteId;
        const versions = state.versions?.[noteId] || [];
        const selectedIndex = parseInt(versionItem.dataset.versionIndex);
        const selectedVersion = versions[selectedIndex];

        if (selectedVersion) {
            displayVersionDiff(selectedVersion.content);
        }
    }
});

// Find and replace the version history close button listener
document.getElementById('version-history-close-btn').addEventListener('click', closeVersionHistoryModal);


// Remove the old listener on 'version-list-container' and add these new ones
document.getElementById('version-sidebar').addEventListener('click', (e) => {
    const versionItem = e.target.closest('.version-item');
    if (!versionItem || versionItem.classList.contains('active')) return;

    // Remove active class from any other item
    document.querySelectorAll('#version-sidebar .version-item.active').forEach(el => el.classList.remove('active'));
    // Add active class to the clicked item
    versionItem.classList.add('active');

    const noteId = state.settings.activeNoteId;
    const versions = state.versions?.[noteId] || [];
    const selectedIndex = parseInt(versionItem.dataset.versionIndex);
    const selectedVersion = versions[selectedIndex];

    if (selectedVersion) {
        displayVersionDiff(selectedVersion.content);
    }
});

// --- Integrated Version Restore Logic ---
// --- Integrated Version Restore Logic ---
let restoreConfirmTimeout; 

document.getElementById('version-restore-btn').addEventListener('click', async (e) => {
    const restoreBtn = e.currentTarget;
    const noteId = state.settings.activeNoteId;
    const activeItem = document.querySelector('#version-sidebar .version-item.active');

    if (!noteId || !activeItem) return;

    if (restoreBtn.classList.contains('confirm-state')) {
        clearTimeout(restoreConfirmTimeout);

        const versions = state.versions?.[noteId] || [];
        const selectedIndex = parseInt(activeItem.dataset.versionIndex);
        const versionToRestore = versions[selectedIndex];
        const noteData = window.noteCache[noteId]; // FIX: Get current note data from the cache

        if (versionToRestore && noteData) {
            // 1. (NEW) Create a checkpoint of the current content BEFORE overwriting it.
            saveNoteVersion(
                noteId,
                noteData.content, // The current content being replaced
                `Automatic checkpoint before restore`
            );

            // 2. Overwrite the note's content in the cache with the restored version.
            noteData.content = versionToRestore.content;
            noteData.modifiedAt = new Date().toISOString();
            updateNoteLinks(noteData);
            updateNoteTags(noteData);

            // 3. (NEW) Create a log to show that a restore happened.
            saveNoteVersion(
                noteId,
                noteData.content, // The newly restored content
                `Restored from version ${formatRelativeTime(versionToRestore.savedAt)}`
            );

            // 4. Update the UI and save everything.
            app.elements.noteEditorBody.innerHTML = noteData.content;
            await performImmediateSave(); // Use immediate save
            buildLunrIndex();

            closeVersionHistoryModal();
            showToast('Note restored successfully!', 'success');
        }

        restoreBtn.classList.remove('confirm-state');
        restoreBtn.innerHTML = 'Restore';

    } else {
        restoreBtn.classList.add('confirm-state');
        restoreBtn.innerHTML = 'Confirm Restore?';

        restoreConfirmTimeout = setTimeout(() => {
            restoreBtn.classList.remove('confirm-state');
            restoreBtn.innerHTML = 'Restore';
        }, 3000);
    }
});
const updateChecklistProgress = (checklistContainer) => {
    if (!checklistContainer) return;
    const items = checklistContainer.querySelectorAll('.checklist-item');
    const checkedItems = checklistContainer.querySelectorAll('.checklist-item.checked');
    const total = items.length;
    const checkedCount = checkedItems.length;
    const percentage = total > 0 ? Math.round((checkedCount / total) * 100) : 0;
    const fillEl = checklistContainer.querySelector('.checklist-progress-fill');
    const textEl = checklistContainer.querySelector('.checklist-progress-text');
    if (fillEl) fillEl.style.width = `${percentage}%`;
    if (textEl) textEl.textContent = `${percentage}% Complete`;
};

// --- 1. HELPER FUNCTIONS (Lowest Level) ---
// These are needed by other functions, so they must come first.

function findItem(itemId, tree = state.collections) {
    if (!itemId) return null;
    for (let i = 0; i < tree.length; i++) {
        const item = tree[i];
        if (item.id === itemId) return {item, parent: tree, index: i};
        if (item.children) {
            const result = findItem(itemId, item.children);
            if(result) {
               const parentObject = tree.find(parentItem => parentItem.children === result.parent);
               return { ...result, parent: parentObject || tree };
            }
        }
    }
    return null;
}
const handleSpreadsheetUpload = (file) => {
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

            if (json.length === 0) {
                showToast('Spreadsheet is empty.', 'error');
                return;
            }

            const [headers, ...rows] = json;
            const cols = headers.length;

            let tableHTML = '<table style="width:100%"><thead>';
            tableHTML += `<tr><th colspan="${cols}" contenteditable="false"><div class="table-header-controls"><div class="table-filter-wrapper"><i data-feather="search" class="filter-icon"></i><input class="table-filter-input" placeholder="Filter table..."/></div><button class="toggle-filter-btn" title="Toggle Filter"><i data-feather="chevrons-up" class="w-4 h-4"></i></button></div></th></tr>`;
            tableHTML += '<tr>';
            headers.forEach(header => {
                tableHTML += `<th class="sortable-header" data-sort-dir="none" contenteditable="true">${header}</th>`;
            });
            tableHTML += '</tr></thead><tbody>';

            rows.forEach(row => {
                tableHTML += '<tr>';
                for (let i = 0; i < cols; i++) {
                    tableHTML += `<td contenteditable="true">${row[i] || ''}</td>`;
                }
                tableHTML += '</tr>';
            });

            tableHTML += '</tbody></table><p><br></p>';

            restoreSelectionAndExec(() => document.execCommand('insertHTML', false, tableHTML));
            feather.replace();
            showToast(`✅ Table imported from ${file.name}`);

        } catch (err) {
            console.error("Spreadsheet parsing error:", err);
            showToast("Failed to parse the spreadsheet file.", "error");
        }
    };
    reader.readAsArrayBuffer(file);
};
/**
 * Renders the flashcard data into the modal and handles the UI logic.
 * @param {Array<Object>} cards - An array of flashcard objects [{front, back}].
 */
function renderFlashcardModal(cards) {
    // Get fresh references to all modal elements each time
    const modal = document.getElementById('flashcard-modal');
    const container = document.getElementById('flashcard-container');
    const frontEl = document.getElementById('flashcard-front');
    const backEl = document.getElementById('flashcard-back');
    const progressEl = document.getElementById('flashcard-progress');
    const prevBtn = document.getElementById('flashcard-prev-btn');
    const nextBtn = document.getElementById('flashcard-next-btn');
    const closeBtn = document.getElementById('flashcard-close-btn');

    let currentIndex = 0;

    // --- All event logic is handled by this one function ---
    const handleModalClick = (e) => {
        // Use .closest() to see if a specific button was clicked
        const targetButton = e.target.closest('button');

        if (targetButton === prevBtn) {
            if (currentIndex > 0) {
                currentIndex--;
                updateCard();
            }
        } else if (targetButton === nextBtn) {
            if (currentIndex < cards.length - 1) {
                currentIndex++;
                updateCard();
            } else {
                cleanupAndClose(); // Finish on the last card
            }
        } else if (targetButton === closeBtn) {
            cleanupAndClose();
        } else {
            // If any other part of the modal is clicked, flip the card
            container.classList.toggle('flipped');
        }
    };

    // This function updates the card's content
    const updateCard = () => {
        container.classList.remove('flipped'); // Always show the front first

        // Use marked.parse to correctly render potential markdown from the AI
        frontEl.innerHTML = marked.parse(cards[currentIndex].front || '');
        backEl.innerHTML = marked.parse(cards[currentIndex].back || '');

        progressEl.textContent = `Card ${currentIndex + 1} of ${cards.length}`;
        prevBtn.disabled = currentIndex === 0;
        nextBtn.textContent = (currentIndex === cards.length - 1) ? 'Finish' : 'Next';
    };

    // This function removes the event listener to prevent future bugs
    const cleanupAndClose = () => {
        modal.removeEventListener('click', handleModalClick);
        closeModal(modal);
    };

    // --- Setup ---
    modal.addEventListener('click', handleModalClick); // Add the single listener
    updateCard(); // Display the first card
    openModal(modal);
    feather.replace();
}

/**
 * Handles the AI call to generate flashcards from note content, with caching.
 * @param {Object} note - The full note object from the state.
 */
const handleFlashcardMode = async (note) => {
    // Step 1: Check for a valid cached result first.
    if (note.cachedFlashcards && note.cachedFlashcards.sourceModifiedAt === note.modifiedAt) {
        showToast('Loading Flashcards!', 'info');
        renderFlashcardModal(note.cachedFlashcards.data);
        return;
    }

    // Step 2: If no cache, call the AI.
    const noteContent = (note.content || '').replace(/<[^>]*>?/gm, '').trim();
    if (!noteContent) {
        showToast("Note is empty, cannot generate flashcards.", "info");
        return;
    }

    const toastId = showToast('Generating Flashcards...', 'loading');
    const prompt = `Analyze the following text and identify the key concepts. Create a series of flashcards based on these concepts. For each flashcard, provide a "front" (a question or term) and a "back" (the answer or definition). Return the result as a single, valid JSON object with a key "flashcards" which is an array of objects. Each object in the array must have two keys: "front" (string) and "back" (string). Do not include any text or markdown formatting outside of the JSON object.
    Text:
    ---
    ${noteContent}`;

    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    const jsonResponse = await callGeminiAPI(payload);
    dismissToast(toastId);

    if (jsonResponse) {
        try {
    // Find the start and end of the JSON object
    const startIndex = jsonResponse.indexOf('{');
    const endIndex = jsonResponse.lastIndexOf('}');

    // Extract only the JSON part of the string
    const jsonString = jsonResponse.substring(startIndex, endIndex + 1);

    const flashcardData = JSON.parse(jsonString);

    if (flashcardData.flashcards && Array.isArray(flashcardData.flashcards)) {
         renderFlashcardModal(flashcardData.flashcards);

         // Cache the new result in the note object.
         note.cachedFlashcards = {
             sourceModifiedAt: note.modifiedAt,
             data: flashcardData.flashcards
         };
         saveState(); // Save the note with the cached data.
    } else {
        throw new Error("Invalid flashcard data structure in JSON.");
    }
} catch (err) {
    console.error("Failed to parse flashcard JSON:", err, "Raw response:", jsonResponse);
    showToast('Failed to generate valid flashcards.', 'error');
}
    }
};
const getAllNotes = (items) => {
    let notes = [];
    for (const item of items) {
        if (item.type === 'note') {
            notes.push(item);
        }
        if (item.type === 'folder' && item.children) {
            notes = notes.concat(getAllNotes(item.children));
        }
    }
    return notes;
};
const getAllFolders = (items = state.collections) => {
    let folders = [];
    for (const item of items) {
        if (item.type === 'folder') {
            folders.push(item);
            if (item.children) {
                folders = folders.concat(getAllFolders(item.children));
            }
        }
    }
    return folders;
};
/**
 * Finds all HTML tables in a string and converts them to a plain-text Markdown format.
 * @param {string} htmlString - The HTML content of a note.
 * @returns {string} The content with tables converted to Markdown.
 */
function convertTablesToMarkdown(htmlString) {
    if (!htmlString || !htmlString.includes('<table')) return htmlString;

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlString;

    tempDiv.querySelectorAll('table').forEach(table => {
        let markdownTable = '\n';
        // Process Header
        const headers = table.querySelectorAll('thead tr:last-child th');
        if (headers.length > 0) {
            markdownTable += `| ${Array.from(headers).map(th => th.innerText.trim()).join(' | ')} |\n`;
            markdownTable += `| ${Array(headers.length).fill('---').join(' | ')} |\n`;
        }
        
        // Process Body
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            markdownTable += `| ${Array.from(cells).map(td => td.innerText.trim()).join(' | ')} |\n`;
        });

        table.outerHTML = markdownTable; // Replace the HTML table with the Markdown version
    });

    return tempDiv.innerHTML;
}
const handleGlobalAIQuery = async () => {
    const askBtn = document.getElementById('global-ai-ask-btn');
    const answerContainer = document.getElementById('global-ai-answer-container');
    const answerEl = document.getElementById('global-ai-answer');
    const inputEl = document.getElementById('global-ai-input');
    const sourcesContainer = document.getElementById('global-ai-sources-container');
    const copyBtnFooter = document.getElementById('global-ai-copy-btn-footer');
    const query = inputEl.value.trim();

    if (!query) return;

    askBtn.disabled = true;
    askBtn.querySelector('span').textContent = 'Thinking...';
    answerContainer.classList.add('hidden');
    sourcesContainer.classList.add('hidden');
    copyBtnFooter.classList.add('hidden');
    answerEl.innerHTML = '';

    const searchResults = lunrIndex.search(query);

    // --- FIX STARTS HERE ---
    // The original code used findItem(), which only returns a data stub.
    // This now correctly pulls the FULL note data from the global note cache.
    const topNotes = searchResults.slice(0, 5).map(res => {
        const fullNoteData = window.noteCache[res.ref];
        return fullNoteData ? { id: res.ref, ...fullNoteData } : null;
    }).filter(Boolean);
    // --- FIX ENDS HERE ---

    if (topNotes.length === 0) {
        showToast('No relevant notes found.', 'info');
        askBtn.disabled = false;
        askBtn.querySelector('span').textContent = 'Ask';
        return;
    }

    // This part now works correctly because note.content is available.
    const context = topNotes.map(note => {
        const contentWithMarkdownTables = convertTablesToMarkdown(note.content);
        return `--- Note: "${note.name}" ---\n${contentWithMarkdownTables.replace(/<[^>]*>?/gm, '')}`;
    }).join('\n\n');

    const historyContext = askYourNotesHistory.map(item => `Previous Question: ${item.question}\nPrevious Answer: ${item.answer}`).join('\n\n');

    const prompt = `You are a helpful assistant.
${historyContext ? `For context, here is the previous turn of our conversation:\n${historyContext}\n\n` : ''}
Based ONLY on the context from the provided notes below, answer the user's new question. If the answer cannot be found in the notes, say "I could not find an answer in your notes." Do not use any external knowledge.

User's Question: "${query}"

Context from Notes:
${context}`;

    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    const aiResponse = await callGeminiAPI(payload);

    if (aiResponse) {
        answerEl.innerHTML = marked.parse(aiResponse);
        answerContainer.classList.remove('hidden');
        copyBtnFooter.classList.remove('hidden');

        findAndDisplaySourceSnippets(aiResponse, topNotes);

        askYourNotesHistory.push({ question: query, answer: aiResponse });
    } else {
        showToast('The AI could not provide an answer.', 'error');
    }

    askBtn.disabled = false;
    askBtn.querySelector('span').textContent = 'Ask';
    feather.replace();
};
const findAndDisplaySourceSnippets = (aiAnswer, sourceNotes) => {
    const sourcesEl = document.getElementById('global-ai-sources');
    const sourcesContainer = document.getElementById('global-ai-sources-container');
    sourcesEl.innerHTML = '';

    const stopWords = new Set(['a', 'an', 'the', 'is', 'was', 'are', 'in', 'on', 'of', 'to', 'and', 'it', 'for', 'from', 'your', 'notes']);
    const keywords = [...new Set(aiAnswer.toLowerCase().match(/\b(\w+)\b/g) || [])]
        .filter(word => word.length > 3 && !stopWords.has(word));

    if (keywords.length === 0) {
        sourcesContainer.classList.add('hidden');
        return;
    }

    // Calculate raw scores first
    const scoredNotes = sourceNotes.map(note => {
        const noteText = note.content.replace(/<[^>]*>?/gm, ' ').toLowerCase();
        let score = 0;
        keywords.forEach(kw => {
            if (noteText.includes(kw)) score++;
        });
        return { note, score };
    });

    const RELEVANCE_THRESHOLD_SCORE = 1; // Note must contain at least 1 keyword
    let relevantNotes = scoredNotes.filter(item => item.score > RELEVANCE_THRESHOLD_SCORE);
    
    // Calculate the total score for normalization
    const totalScore = relevantNotes.reduce((sum, item) => sum + item.score, 0);

    if (totalScore === 0) {
        sourcesContainer.classList.add('hidden');
        return;
    }

    let snippetsHTML = '';
    relevantNotes
      .sort((a, b) => b.score - a.score) // Sort by highest score
      .forEach(item => {
        // --- NEW: Normalization Logic ---
        const normalizedPercentage = Math.round((item.score / totalScore) * 100);

        let relevanceClass = 'bg-gray-600';
        if (normalizedPercentage > 40) relevanceClass = 'bg-green-500';
        else if (normalizedPercentage > 15) relevanceClass = 'bg-yellow-500';

        const noteText = item.note.content.replace(/<[^>]*>?/gm, ' ');
        let bestSnippet = `..."${noteText.substring(0, 120)}"...`;
        for (const kw of keywords) {
            const regex = new RegExp(`[^.!?]*\\b${kw}\\b[^.!?]*[.!?]`, 'i');
            const match = noteText.match(regex);
            if (match) {
                bestSnippet = `..."${match[0].trim()}"...`;
                break;
            }
        }
        keywords.forEach(kw => {
            bestSnippet = bestSnippet.replace(new RegExp(`\\b(${kw})\\b`, 'gi'), `<strong class="text-accent-primary">$1</strong>`);
        });

        // --- NEW: Snippet is now wrapped in an <a> tag ---
        snippetsHTML += `
            <a href="#" class="source-snippet-link block p-2 border border-border-color bg-bg-pane-dark rounded-md text-xs hover:bg-bg-pane-light" data-note-id="${item.note.id}">
                <div class="font-semibold text-text-primary mb-1 flex justify-between items-center">
                    <span>🧾 From: “${item.note.name}”</span>
                    <span class="text-xs text-white font-medium px-1.5 py-0.5 rounded-full ${relevanceClass}">${normalizedPercentage}% Relevant</span>
                </div>
                <div class="text-text-secondary italic pointer-events-none">${bestSnippet}</div>
            </a>
        `;
    });

    sourcesEl.innerHTML = snippetsHTML;
    sourcesContainer.classList.remove('hidden');
    feather.replace();
};
function parseInternalLinks(htmlContent) {
    // This check prevents the function from running if state or state.collections is missing.
    if (!htmlContent || !state || !state.collections) return htmlContent;

    const allNotes = getAllNotes(state.collections);
    return htmlContent.replace(/\[\[(.*?)\]\]/g, (match, noteName) => {
        const trimmedName = noteName.trim();
        
        // --- THIS IS THE FIX ---
        // We now trim the note name from the state data (n.name.trim()) before comparing.
        // This protects against invisible leading/trailing spaces from bad data.
        const foundNote = allNotes.find(n => n.name.trim().toLowerCase() === trimmedName.toLowerCase());
        
        if (foundNote) {
            return `<a href="#" class="internal-link" title="Link to '${foundNote.name.trim()}'" data-note-id="${foundNote.id}">${trimmedName}</a>`;
        } else {
            return `<span class="internal-link-broken" title="Note not found: '${trimmedName}'">${trimmedName}</span>`;
        }
    });
}

// --- 2. HANDLER FUNCTIONS (Higher Level) ---
// These functions use the helpers defined above.

const handleShareNote = async (noteToShare) => {
    // If a note object is passed (e.g., from a command), use it. Otherwise, find the active note.
    const noteStub = noteToShare || findItem(state.settings.activeNoteId)?.item;
    if (!noteStub) {
        showToast('❌ No note selected to share.', 'error');
        return;
    }

    // FIX: Get the full note data, including content, from the cache using the note's ID.
    const noteData = window.noteCache[noteStub.id];
    if (!noteData) {
        showToast('❌ Could not load note content to share.', 'error');
        return;
    }

    const toastId = showToast('Creating share link...', 'loading');

    try {
        const { doc, setDoc, collection } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
        const publicNotesCol = collection(window.db, "publishedNotes");
        const publicNoteRef = doc(publicNotesCol);

        await setDoc(publicNoteRef, {
            name: noteData.name,         // FIX: Use name from the full cached data
            content: noteData.content,   // FIX: Use content from the full cached data
            originalAuthor: window.auth.currentUser.uid,
            sharedAt: new Date().toISOString()
        });

        const shareUrl = `${window.location.origin}${window.location.pathname}?view=${publicNoteRef.id}`;
        dismissToast(toastId);

        // This will now be called correctly.
        await showPrompt({
            title: 'Share Link Created',
            message: 'Anyone with this link can view a read-only version of this note.',
            initialValue: shareUrl,
            isReadOnly: true
        });

    } catch (error) {
        console.error("Error creating share link:", error);
        dismissToast(toastId);
        showToast('Could not create share link.', 'error');
    }
};

const handlePublicNoteView = async (noteId) => {
    // --- Initial Setup ---
    document.getElementById('theme-color-meta')?.setAttribute('content', '#100F1B');
    document.body.classList.remove('overflow-hidden');
    document.getElementById('app-container').style.display = 'none';
    document.getElementById('auth-container').style.display = 'none';
    const publicView = document.getElementById('public-note-view');
    publicView.classList.remove('hidden');
    document.getElementById('chatbot-fab').style.display = 'none';

    try {
        const { doc, getDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
        const docRef = doc(window.db, "publishedNotes", noteId);
        const docSnap = await getDoc(docRef);

        if (docSnap.exists()) {
            const noteData = docSnap.data();
            document.getElementById('public-note-title').textContent = noteData.name;
            document.title = `${noteData.name} | Reputifly Notes`;

            const noteContentDiv = document.getElementById('public-note-content');
            let html = noteData.content || '';

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            
            // **THIS IS THE FIX TO REMOVE THE FILTER BAR**
            tempDiv.querySelectorAll('table').forEach(table => {
                // Find and remove the filter row, which is the first row in the table head
                const filterRow = table.querySelector('thead tr:first-child');
                if (filterRow && filterRow.querySelector('.table-filter-input')) {
                    filterRow.remove();
                }

                // Add sortable class to the actual header row
                table.querySelectorAll('thead tr th').forEach(th => {
                    th.classList.add('sortable-header');
                    th.dataset.sortDir = 'none';
                });
                
                const tbody = table.querySelector('tbody');
                if (tbody) {
                    table._originalRows = Array.from(tbody.querySelectorAll('tr'));
                }
            });
            html = tempDiv.innerHTML.replace(/ contenteditable="true"/g, '');
            // CRITICAL: Sanitize all public-facing content to prevent XSS
noteContentDiv.innerHTML = DOMPurify.sanitize(html);

            // Delegated Click Listener for Sorting and Code Copying
            noteContentDiv.addEventListener('click', (e) => {
                const header = e.target.closest('th.sortable-header');
                if (header) {
                    const table = header.closest('table');
                    const tbody = table.querySelector('tbody');
                    if (!tbody) return;
                    const rowsToSort = Array.from(tbody.querySelectorAll('tr'));
                    const headers = Array.from(header.parentElement.children);
                    const colIndex = headers.indexOf(header);
                    const currentDir = header.dataset.sortDir;
                    const newDir = currentDir === 'asc' ? 'desc' : (currentDir === 'desc' ? 'none' : 'asc');
                    headers.forEach(h => { h.dataset.sortDir = 'none'; h.querySelector('.sort-indicator')?.remove(); });

                    if (newDir === 'none') {
                        if(table._originalRows) tbody.append(...table._originalRows);
                    } else {
                        const isNumeric = rowsToSort.every(row => { const cellText = row.children[colIndex]?.innerText.trim() || ''; return cellText === '' || !isNaN(parseFloat(cellText.replace(/[^0-9.-]+/g, ""))); });
                        rowsToSort.sort((rowA, rowB) => {
                            const cellA = rowA.children[colIndex]?.innerText.trim() || '';
                            const cellB = rowB.children[colIndex]?.innerText.trim() || '';
                            if (isNumeric) { const numA = parseFloat(cellA.replace(/[^0-9.-]+/g, "")) || 0; const numB = parseFloat(cellB.replace(/[^0-9.-]+/g, "")) || 0; return newDir === 'asc' ? numA - numB : numB - numA; }
                            return newDir === 'asc' ? cellA.localeCompare(cellB) : cellB.localeCompare(cellA);
                        });
                        tbody.append(...rowsToSort);
                        header.dataset.sortDir = newDir;
                        header.insertAdjacentHTML('beforeend', `<span class="sort-indicator">${newDir === 'asc' ? '▲' : '▼'}</span>`);
                    }
                    return;
                }
                const checklistItem = e.target.closest('.checklist-item');
if (checklistItem) {
    e.preventDefault();
    const checkbox = checklistItem.querySelector('.checklist-item-checkbox');
    const isCheckedNow = !checklistItem.classList.contains('checked');

    if (checkbox) {
        checkbox.checked = isCheckedNow;
    }
    checklistItem.classList.toggle('checked', isCheckedNow);
    return; // Stop further processing for this click
}
                const copyBtn = e.target.closest('.copy-code-btn');
                if (copyBtn) {
                    const codeBlock = copyBtn.closest('.code-block-wrapper')?.querySelector('pre, code');
                    if (codeBlock) { navigator.clipboard.writeText(codeBlock.innerText).then(() => showToast('Code copied!', 'success')).catch(() => showToast('Failed to copy code.', 'error')); }
                }
            });

            // Other existing listeners
            noteContentDiv.addEventListener('change', (e) => {
                if (e.target.matches('.task-list-item input[type="checkbox"]')) {
                    const item = e.target.closest('.task-list-item');
                    if (item) item.classList.toggle('checked', e.target.checked);
                }
            });
            document.getElementById('copy-note-btn').addEventListener('click', () => {
                navigator.clipboard.writeText(noteContentDiv.innerText).then(() => showToast('Note content copied!', 'success')).catch(() => showToast('Failed to copy content.', 'error'));
            });

            hljs.highlightAll();

        } else {
            document.getElementById('public-note-title').textContent = 'Note Not Found';
            document.getElementById('public-note-content').innerHTML = '<p>The link you followed may be broken or the note may have been deleted.</p>';
        }
    } catch (error) {
        console.error("Error fetching public note:", error);
        document.getElementById('public-note-title').textContent = 'Error';
        document.getElementById('public-note-content').innerHTML = '<p>Could not load the note due to an error.</p>';
    } finally {
        feather.replace();
    }
};
// --- START: NEW RESEARCH AGENT LOGIC ---
// --- START: NEW RESEARCH AGENT LOGIC ---
// Add this new function
const updateAllLinksAgent = async () => {
    const toastId = showToast('🔗 Scanning all notes for link updates...', 'loading');
    const { doc, writeBatch, getDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");

    try {
        // Step 1: Ensure all notes are loaded into the cache
        const allNoteStubs = getAllNotes(state.collections);
        const notesToLoad = allNoteStubs.filter(stub => !window.noteCache[stub.id]);
        if (notesToLoad.length > 0) {
            const fetchPromises = notesToLoad.map(stub => getDoc(doc(db, "notes", stub.id)).then(snap => {
                if (snap.exists()) window.noteCache[stub.id] = snap.data();
            }));
            await Promise.all(fetchPromises);
        }

        const batch = writeBatch(db);
        let updatedCount = 0;
        const allNotes = Object.values(window.noteCache);
        const nameToIdMap = new Map(allNoteStubs.map(n => [n.name.toLowerCase(), n.id]));

        // Step 2: Iterate through every note and update its links
        for (const note of allNotes) {
            let contentChanged = false;
            let newContent = note.content;

            newContent = newContent.replace(/\[\[(.*?)\]\]/g, (match, noteName) => {
                const trimmedName = noteName.trim();
                const targetId = nameToIdMap.get(trimmedName.toLowerCase());
                if (targetId) {
                    return `[[${trimmedName}]]`; // Link is valid, keep it
                }
                // If link is broken, try to find note by old name (more complex) or leave as is for now.
                // This basic implementation focuses on ensuring valid links are preserved.
                return match; // For now, we leave broken links as they are.
            });
            
            // This regex is for already-parsed links (<a> tags)
            newContent = newContent.replace(/<a[^>]*class="internal-link"[^>]*data-note-id="([^"]+)"[^>]*>(.*?)<\/a>/g, (match, noteId, linkText) => {
                const targetNote = findItem(noteId)?.item;
                if (targetNote && targetNote.name !== linkText) {
                    contentChanged = true;
                    return `<a href="#" class="internal-link" title="Link to '${targetNote.name}'" data-note-id="${noteId}">${targetNote.name}</a>`;
                }
                return match; // No change needed
            });


            if (contentChanged) {
                updatedCount++;
                const noteRef = doc(db, "notes", note.id);
                batch.update(noteRef, { content: newContent });
            }
        }

        if (updatedCount > 0) {
            await batch.commit();
            dismissToast(toastId);
            showToast(`✅ Updated links in ${updatedCount} note(s).`, 'success');
        } else {
            dismissToast(toastId);
            showToast('👍 All links are already up to date.', 'info');
        }
    } catch (error) {
        console.error("Link update failed:", error);
        dismissToast(toastId);
        showToast('❌ Failed to update links.', 'error');
    }
};
const researchAgent = async (topic) => {
    const toastId = showToast(`🔬 Researching "${topic}"...`, 'loading');

    // STEP 1: FIND RELEVANT NOTE IDs
    const searchResults = lunrIndex.search(topic);
    const sourceNoteIds = searchResults.slice(0, 5).map(res => res.ref);

    if (sourceNoteIds.length === 0) {
        dismissToast(toastId);
        showToast(`No relevant notes found for "${topic}".`, 'info');
        return;
    }

    // STEP 2: ENSURE REQUIRED NOTES ARE LOADED INTO THE CACHE
    const notesToLoad = sourceNoteIds.filter(id => !window.noteCache[id]);
    if (notesToLoad.length > 0) {
        try {
            const { doc, getDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
            const fetchPromises = notesToLoad.map(id => {
                const noteRef = doc(db, "notes", id);
                return getDoc(noteRef).then(noteSnap => {
                    if (noteSnap.exists()) {
                        window.noteCache[id] = noteSnap.data(); // Add to cache
                    }
                });
            });
            await Promise.all(fetchPromises);
        } catch (error) {
            dismissToast(toastId);
            console.error("Error loading notes for research:", error);
            showToast("Failed to load source notes.", "error");
            return;
        }
    }

    // STEP 3: READ & PREPARE CONTEXT FROM CACHED NOTES
    const context = sourceNoteIds
        .map(id => window.noteCache[id]) // Get full note data from cache
        .filter(Boolean) // Filter out any notes that failed to load
        .map(noteData => {
            return `--- Note Source: "${noteData.name}" ---\n${(noteData.content || '').replace(/<[^>]*>?/gm, '')}`;
        }).join('\n\n');

    // STEP 4: SYNTHESIZE WITH AI
    const prompt = `You are a research assistant. Based ONLY on the provided notes, write a comprehensive research brief about "${topic}". Structure your response in well-written Markdown. At the end of your response, include a "Sources" section listing the names of the notes you used, like this:\n## Sources\n- [[Note Name 1]]\n- [[Note Name 2]]`;
    const finalPrompt = `${prompt}\n\nContext from Notes:\n${context}`;
    const payload = { contents: [{ parts: [{ text: finalPrompt }] }] };
    const aiBrief = await callGeminiAPI(payload);
    dismissToast(toastId);

    if (!aiBrief) {
        showToast('The AI could not generate a research brief.', 'error');
        return;
    }

    // STEP 5: CREATE & LINK THE NEW NOTE
    // STEP 5: CREATE & LINK THE NEW NOTE
const newNoteName = `Research Brief: ${topic}`;

// Convert markdown to HTML, then find and convert [[links]] to clickable <a> tags
const initialHtml = marked.parse(aiBrief);
const finalHtmlWithLinks = parseInternalLinks(initialHtml);

const newNote = await createNewNote(true, { name: newNoteName, content: finalHtmlWithLinks }, null);

    // After creation, the note is active. We need to update its links and save again.
    const activeNoteFullData = window.noteCache[newNote.id];
    if (activeNoteFullData) {
        updateNoteLinks(activeNoteFullData);
        await performImmediateSave(); // Save the link updates
    }
    
    showToast(`✅ Research brief created!`, 'success');
};
// --- START: NEW MEETING ASSISTANT LOGIC ---
const meetingAssistantAgent = async (noteId) => {
    const toastId = showToast('🤝 Processing meeting notes...', 'loading');
    const { item: note } = findItem(noteId);

    if (!note || !note.content) {
        dismissToast(toastId);
        return showToast('Note is empty.', 'info');
    }

    const plainContent = note.content.replace(/<[^>]*>?/gm, ' ').trim();

    // STEP 1: ANALYZE & EXTRACT (with a JSON-focused prompt)
    const prompt = `Analyze the following meeting minutes.
    1.  Provide a concise summary of the key decisions made.
    2.  Extract all action items and identify who is assigned to each task.
    
    Return your response as a single, valid JSON object with two keys: "summary" (a string) and "actionItems" (an array of objects, where each object has "task" and "assignee" keys).
    
    Example: {"summary": "The team decided...", "actionItems": [{"task": "Draft the report", "assignee": "Alice"}, {"task": "Update the slides", "assignee": "Bob"}]}
    
    Meeting Minutes:
    ---
    ${plainContent}`;

    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    let aiResponse;
    try {
        const rawResponse = await callGeminiAPI(payload);
        // Clean up the response to ensure it's valid JSON
        const jsonString = rawResponse.match(/{[\s\S]*}/)[0];
        aiResponse = JSON.parse(jsonString);
    } catch (error) {
        dismissToast(toastId);
        console.error("Failed to parse AI response:", error);
        return showToast('AI response was not valid. Could not process meeting.', 'error');
    }
    
    if (!aiResponse || !aiResponse.summary || !aiResponse.actionItems) {
        dismissToast(toastId);
        return showToast('AI failed to extract required information.', 'error');
    }

    // STEP 2: UPDATE THE ORIGINAL NOTE
    const summaryHTML = `<h2>Meeting Summary</h2>${marked.parse(aiResponse.summary)}`;
    note.content = summaryHTML + '<hr>' + note.content;

    // STEP 3: CREATE & LINK ACTION ITEMS
    const taskLinks = [];
    const tasksFolder = getAllFolders().find(f => f.name.toLowerCase() === 'tasks');
    const parentId = tasksFolder ? tasksFolder.id : null;

    for (const item of aiResponse.actionItems) {
        // createNewNote(switchToIt, initialContent, parentId)
        const newTask = createNewNote(false, `From meeting: [[${note.name}]]`, parentId);
        newTask.name = item.task;
        
        // Add assignee as a property
        if (item.assignee) {
            newTask.properties['Assignee'] = { type: 'select', value: item.assignee, options: [{name: item.assignee}] };
        }
        taskLinks.push(`[[${newTask.name}]]`);
    }

    if (taskLinks.length > 0) {
        note.content += `<h2>Action Items</h2><ul>${taskLinks.map(link => `<li>${link}</li>`).join('')}</ul>`;
    }

    note.modifiedAt = new Date().toISOString();
    updateNoteLinks(note); // This makes all the [[links]] clickable

    dismissToast(toastId);
    saveState();
    render(); // Re-render the UI to show all the changes
    showToast('✅ Meeting processed successfully!', 'success');
};
// --- END: NEW MEETING ASSISTANT LOGIC ---
// --- END: NEW RESEARCH AGENT LOGIC ---
// ==================================================================
//  END: CORRECT FUNCTION BLOCK
// ==================================================================
            const params = new URLSearchParams(window.location.search);
    const publicNoteId = params.get('view');
    if (publicNoteId) {
        handlePublicNoteView(publicNoteId);
        return; // Stop the normal app from loading
    }
            
            // --- START: FINAL AUTHENTICATION LOGIC ---

            // Import the functions we need at the top of the module.
            const {
                createUserWithEmailAndPassword,
                signInWithEmailAndPassword,
                sendEmailVerification
            } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js");

            // ADD THIS NEW LINE:
            const { doc, setDoc, getDoc, getDocFromServer, collection, query, where } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
            

            const authContainer = document.getElementById('auth-container');
            const loginForm = document.getElementById('login-form');
            const authTitle = document.getElementById('auth-title');
            const authError = document.getElementById('auth-error');
            const showSignup = document.getElementById('show-signup');
            const showLogin = document.getElementById('show-login');
            const loginTextLink = document.getElementById('login-text-link');
            const signupTextLink = document.getElementById('signup-text-link');

            // Function to toggle between login and signup views
            const setAuthView = (isLoginView) => {
                authError.textContent = '';
                if (isLoginView) {
                    authTitle.textContent = 'Login to Your Notes';
                    loginForm.dataset.authMode = 'login';
                    loginForm.querySelector('button').textContent = 'Login';
                    loginTextLink.classList.remove('hidden');
                    signupTextLink.classList.add('hidden');
                } else {
                    authTitle.textContent = 'Create an Account';
                    loginForm.dataset.authMode = 'signup';
                    loginForm.querySelector('button').textContent = 'Sign Up';
                    loginTextLink.classList.add('hidden');
                    signupTextLink.classList.remove('hidden');
                }
            };
            
            showSignup.addEventListener('click', (e) => {
                e.preventDefault();
                setAuthView(false);
            });

            showLogin.addEventListener('click', (e) => {
                e.preventDefault();
                setAuthView(true);
            });

            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                authError.textContent = '';
                const email = loginForm['login-email'].value;
                const password = loginForm['login-password'].value;
                const mode = loginForm.dataset.authMode || 'login';

                try {
                    if (mode === 'signup') {
    // Use the globally available 'window.auth'
    const userCredential = await createUserWithEmailAndPassword(window.auth, email, password);
    await sendEmailVerification(userCredential.user); // ADD THIS LINE
    console.log('Sign up successful! Verification email sent.');
} else {
                        await signInWithEmailAndPassword(window.auth, email, password);
                        console.log('Login successful!');
                    }
                } catch (error) {
                    console.error('Authentication error:', error.code, error.message);
                    // Provide a more user-friendly error message
                    switch (error.code) {
                        case 'auth/weak-password':
                            authError.textContent = 'Password should be at least 6 characters.';
                            break;
                        case 'auth/email-already-in-use':
                            authError.textContent = 'This email is already in use. Please login.';
                            break;
                        case 'auth/invalid-credential':
                             authError.textContent = 'Invalid email or password.';
                             break;
                        default:
                            authError.textContent = 'An error occurred. Please try again.';
                            break;
                    }
                }
            });

            // We need to expose the init function to the global scope so our module script can call it
            window.appInit = init;
            
            // --- END: FINAL AUTHENTICATION LOGIC ---

            const app = {
                containers: {
                    app: document.getElementById('app-container'),
                    collectionsList: document.getElementById('collections-list-container'),
                    tagList: document.getElementById('tag-list-container'),
                    kanbanBoard: document.getElementById('kanban-board'),
                    notesListContent: document.getElementById('notes-list-content'),
                    noteEditor: document.getElementById('note-editor-view'),
                    toast: document.getElementById('toast-container'),
                    mainContentArea: document.getElementById('main-content-area'),
                    searchResultsList: document.getElementById('search-results-list'),
                    mobileControlsDropdown: document.getElementById('mobile-controls-dropdown'),
                    desktopHeaderControls: document.getElementById('desktop-header-controls'),
                },
                elements: {
                    body: document.body,
                    notesListPane: document.getElementById('notes-list-pane'),
                    paneResizer: document.getElementById('pane-resizer'),
                    sidebarToggleBtn: document.getElementById('sidebar-toggle-btn'),
                    themeToggle: document.getElementById('theme-toggle'),
                    themeReputifyIcon: document.getElementById('theme-reputify-icon'),
                    themeSunIcon: document.getElementById('theme-sun-icon'),
                    themeMoonIcon: document.getElementById('theme-moon-icon'),
                    themeText: document.getElementById('theme-text'),
                    newCollectionBtn: document.getElementById('new-collection-btn'),
                    desktopNewNoteBtn: document.getElementById('desktop-new-note-btn'),
                    chatbotFab: document.getElementById('chatbot-fab'),
                    currentViewTitle: document.getElementById('current-view-title'),
                    noteEditorTitle: document.getElementById('note-editor-title'),
                    noteEditorBody: document.getElementById('note-editor-body'),
                    markdownPreview: document.getElementById('markdown-preview'),
                    wordCount: document.getElementById('word-count'),
                    charCount: document.getElementById('char-count'),
                    mobileMenuBtn: document.getElementById('mobile-menu-button'),
                    mobileSidebarOverlay: document.getElementById('mobile-sidebar-overlay'),
                    sortOrderSelect: document.getElementById('sort-order'),
                    listViewControls: document.getElementById('list-view-controls'),
                    viewSwitcher: document.getElementById('view-switcher-container'),
                    importFileInput: document.getElementById('import-file-input'),
                    mobileMoreButton: document.getElementById('mobile-more-button'),
                    headerMainContent: document.getElementById('header-main-content'),
                    toggleTagsBtn: document.getElementById('toggle-tags-btn'), // Add this line
                },
                modals: {
                    // Add these new lines for the quiz modal
quiz: document.getElementById('quiz-modal'),
quizContent: document.getElementById('quiz-content'),
quizCloseBtn: document.getElementById('quiz-close-btn'),
quizDoneBtn: document.getElementById('quiz-done-btn'),
                    backdrop: document.getElementById('modal-backdrop'),
                    apiKey: document.getElementById('api-key-modal'),
                    apiKeyInput: document.getElementById('api-key-input'),
                    apiKeyConfirmBtn: document.getElementById('api-key-confirm-btn'),
                    apiKeyError: document.getElementById('api-key-error'),
                    prompt: document.getElementById('prompt-modal'),
                    promptTitle: document.getElementById('prompt-title'),
                    promptMessage: document.getElementById('prompt-message'),
                    promptInput: document.getElementById('prompt-input'),
                    promptError: document.getElementById('prompt-error'),
                    promptConfirmBtn: document.getElementById('prompt-confirm-btn'),
                    promptCancelBtn: document.getElementById('prompt-cancel-btn'),
                    confirm: document.getElementById('confirm-modal'),
                    confirmTitle: document.getElementById('confirm-title'),
                    confirmMessage: document.getElementById('confirm-message'),
                    confirmConfirmBtn: document.getElementById('confirm-confirm-btn'),
                    confirmCancelBtn: document.getElementById('confirm-cancel-btn'),
                    bookmarklet: document.getElementById('bookmarklet-modal'),
                    bookmarkletLink: document.getElementById('bookmarklet-link'),
                    bookmarkletCloseBtn: document.getElementById('bookmarklet-close-btn'),
                    graph: document.getElementById('graph-modal'),
                    graphContainer: document.getElementById('graph-container'),
                    graphCloseBtn: document.getElementById('graph-close-btn'),
                    aiPrompt: document.getElementById('ai-prompt-modal'),
                    aiPromptInput: document.getElementById('ai-prompt-input'),
                    aiPromptError: document.getElementById('ai-prompt-error'),
                    aiGenerateBtn: document.getElementById('ai-generate-btn'),
                    aiCancelBtn: document.getElementById('ai-cancel-btn'),
                    aiGenerateBtnText: document.getElementById('ai-generate-btn-text'),
                    summary: document.getElementById('summary-modal'),
                    summaryContent: document.getElementById('summary-content'),
                    summaryCloseBtn: document.getElementById('summary-close-btn'),
                    chatbot: document.getElementById('chatbot-modal'),
                    chatbotHistory: document.getElementById('chatbot-history'),
                    chatbotInput: document.getElementById('chatbot-input'),
                    chatbotSendBtn: document.getElementById('chatbot-send-btn'),
                    chatbotCloseBtn: document.getElementById('chatbot-close-btn'),
                    chatbotClearBtn: document.getElementById('chatbot-clear-btn'),
                    chatbotError: document.getElementById('chatbot-error'),
                },
                search: {
                    icon: document.getElementById('header-search-icon'),
                    mobileIcon: document.getElementById('mobile-search-icon'),
                    container: document.getElementById('search-bar-container'),
                    input: document.getElementById('search-input'),
                    closeBtn: document.getElementById('search-close-btn'),
                },
                toolbar: {
                    inline: document.getElementById('inline-toolbar'),
                    editorModeToggle: document.getElementById('editor-mode-toggle'),
                    ocrBtn: document.querySelector('[data-command="ocr"]'),
                    ocrFileInput: document.getElementById('ocr-file-input'),
                    dictateBtn: document.getElementById('dictate-btn'),
                    graphBtn: document.getElementById('graph-btn'),
                },
                views: {
                    board: document.getElementById('board-view'),
                    list: document.getElementById('list-view'),
                    searchResults: document.getElementById('search-results-view'),
                },
                contextMenu: {
                    menu: document.getElementById('context-menu'),
                    targetId: null,
                    targetIsContainer: false,
                    pinActionText: document.getElementById('pin-action-text'),
                    togglePinBtn: document.querySelector('[data-action="toggle-pin"]'),
                    renameBtn: document.querySelector('[data-action="rename"]'),
                    deleteBtn: document.querySelector('[data-action="delete"]'),
                    duplicateBtn: document.querySelector('[data-action="duplicate"]'),
                }
            };

            let state = {};
            let isNoteDirty = false; // Tracks if the current note has unsaved changes
let activeNoteCleanCopy = ''; // Stores the last saved version of the content
            let isSearchActive = false;
            let editorSelectionRange = null;
            let speechRecognizer = null;
            let isDictating = false;
            let saveNoteContent;
            let performImmediateSave;
            const restoreSelectionAndExec = (execFn) => {
                        app.elements.noteEditorBody.focus();
                        if (editorSelectionRange) {
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(editorSelectionRange);
                        }
                        execFn();
                        saveNoteContent();
                        if (window.getSelection().rangeCount > 0) {
                           editorSelectionRange = window.getSelection().getRangeAt(0).cloneRange();
                        }
                    };
            let lunrIndex;
            let hasInitialized = false;
            let isExecutingCommand = false; // ADD THIS LINE
            let activeNoteListener = null; // Unsubscribe function for the real-time listener
window.noteCache = {}; // Global cache for all note contents
const listenToActiveNote = () => {
    if (activeNoteListener) {
        activeNoteListener();
        activeNoteListener = null;
    }

    const noteId = state.settings.activeNoteId;
    if (!noteId) return;

    import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js").then(({ doc, onSnapshot }) => {
        const noteRef = doc(db, "notes", noteId);

        activeNoteListener = onSnapshot(noteRef, (docSnap) => {
            if (docSnap.metadata.hasPendingWrites) {
                return;
            }

            if (docSnap.exists()) {
                const serverNoteData = docSnap.data();
                window.noteCache[noteId] = serverNoteData; 

                // Find the sidebar data and update its name if it changed.
                const noteStub = findItem(noteId)?.item;
                if (noteStub && noteStub.name !== serverNoteData.name) {
                    noteStub.name = serverNoteData.name;
                    // Re-render the sidebar to show the new name.
                    renderCollectionsList();
                }

                // Update the main editor view if it's the active note.
                if (noteId === state.settings.activeNoteId) {
                    const editorTitle = app.elements.noteEditorTitle;
                    const editorBody = app.elements.noteEditorBody;

                    if (editorTitle.value !== serverNoteData.name) {
                        editorTitle.value = serverNoteData.name;
                    }
                    if (editorBody.innerHTML !== serverNoteData.content) {
                        editorBody.innerHTML = serverNoteData.content;
                        updateEditorStats();
                        feather.replace();
                    }
                }
            } else {
                if (activeNoteListener) activeNoteListener();
                state.settings.activeNoteId = null;
                showToast("This note has been deleted.", "info");
                render();
            }
        }, (error) => {
            console.error("Error listening to note:", error);
            showToast("Connection to note lost.", "error");
        });
    });
};

            let askYourNotesHistory = [];
            const showToast = (message, type = 'info') => {
                const id = generateId('toast');
                const toast = document.createElement('div');
                const colors = {
                    info: 'bg-bg-pane-dark text-text-primary',
                    success: 'bg-green-500 text-white',
                    error: 'bg-red-500 text-white',
                    loading: 'bg-blue-500 text-white animate-pulse'
                }
                toast.id = id;
                toast.className = `toast-item ${colors[type]} rounded-full px-4 py-2 text-sm shadow-lg transition-all duration-300 transform translate-y-[-20px] opacity-0`;
                toast.textContent = message;
                
                app.containers.toast.appendChild(toast);
                app.containers.toast.style.pointerEvents = 'auto';

                setTimeout(() => {
                    toast.classList.remove('translate-y-[-20px]', 'opacity-0');
                }, 10);
                
                if (type !== 'loading') {
                    setTimeout(() => {
                        toast.classList.add('opacity-0', 'scale-90');
                        toast.addEventListener('transitionend', () => {
                             if(toast.parentElement) toast.parentElement.removeChild(toast);
                             if (app.containers.toast.childElementCount === 0) {
                                app.containers.toast.style.pointerEvents = 'none';
                             }
                        });
                    }, 3000);
                }
                return id;
            };
            
            const dismissToast = (toastId) => {
                const toast = document.getElementById(toastId);
                if (toast) {
                    toast.classList.add('opacity-0', 'scale-90');
                    toast.addEventListener('transitionend', () => {
                         if(toast.parentElement) toast.parentElement.removeChild(toast);
                         if (app.containers.toast.childElementCount === 0) {
                            app.containers.toast.style.pointerEvents = 'none';
                         }
                    });
                }
            };
            function saveCurrentNoteImmediately() {
    if (!state.settings.activeNoteId) return;
    const findResult = findItem(state.settings.activeNoteId);
    if (findResult && findResult.item) {
        const note = findResult.item;
        const newName = app.elements.noteEditorTitle.value;
        const newContent = app.elements.noteEditorBody.innerHTML;

        // Update the state object in memory right away
        note.name = newName;
        note.content = newContent;
        note.modifiedAt = new Date().toISOString();
        updateNoteLinks(note);
        updateNoteTags(note);

        // Trigger the async save to the database
        saveState();

        // Update the UI
        buildLunrIndex();
        renderCollectionsList();
    }
}
            // --- START: In-Note Search Logic ---
            // Add this new function
function closeAndClearSearch() {
    const editorBody = app.elements.noteEditorBody;
    const highlightControls = document.getElementById('highlight-controls');

    if (highlightControls) {
        highlightControls.classList.add('hidden');
    }

    clearInNoteHighlights();
    const inNoteInput = document.getElementById('in-note-search-input');
    if (inNoteInput) {
        inNoteInput.value = '';
    }
    updateInNoteUI();

    const marks = Array.from(editorBody.querySelectorAll('mark:not(.in-note-highlight)'));

    if (marks.length > 0) {
        marks.forEach(mark => {
            const parent = mark.parentNode;
            while (mark.firstChild) {
                parent.insertBefore(mark.firstChild, mark);
            }
            parent.removeChild(mark);
            parent.normalize();
        });
    }

    // This is the key: Instantly update the note's content in the state 
    // and trigger the database save, fixing the refresh bug.
    saveCurrentNoteImmediately();
}
let inNoteMatches = [];
let inNoteCurrentIndex = -1;

function clearInNoteHighlights() {
    const editorBody = app.elements.noteEditorBody;
    const marks = Array.from(editorBody.querySelectorAll('mark.in-note-highlight'));
    marks.forEach(mark => {
        const parent = mark.parentNode;
        parent.replaceChild(document.createTextNode(mark.textContent), mark);
        parent.normalize(); // Merges adjacent text nodes
    });
    inNoteMatches = [];
    inNoteCurrentIndex = -1;
}

function updateInNoteUI() {
    const countEl = document.getElementById('in-note-search-count');
    const nextBtn = document.getElementById('in-note-search-next');
    const prevBtn = document.getElementById('in-note-search-prev');

    if (inNoteMatches.length === 0) {
        countEl.textContent = 'No results';
        nextBtn.disabled = true;
        prevBtn.disabled = true;
    } else {
        countEl.textContent = `${inNoteCurrentIndex + 1} of ${inNoteMatches.length}`;
        nextBtn.disabled = inNoteCurrentIndex >= inNoteMatches.length - 1;
        prevBtn.disabled = inNoteCurrentIndex <= 0;
    }
}

function navigateToMatch(index) {
    if (inNoteMatches[inNoteCurrentIndex]) {
        inNoteMatches[inNoteCurrentIndex].classList.remove('current');
    }
    inNoteCurrentIndex = index;
    const currentMatch = inNoteMatches[inNoteCurrentIndex];
    currentMatch.classList.add('current');

    // --- ROBUST SCROLL LOGIC TO PREVENT CUT-OFF HEADER ---
    // This is the new, more reliable scrolling logic.
// This new logic correctly calculates scroll position, accounting for the header
            const mainContentArea = document.getElementById('main-content-area');
            const header = document.getElementById('highlight-controls');
            const headerHeight = header.offsetHeight;
            const elementRect = currentMatch.getBoundingClientRect();
            const containerRect = mainContentArea.getBoundingClientRect();
            const scrollTop = mainContentArea.scrollTop;
            const desiredPadding = 20; // A little space between the header and the highlight

            const elementTopRelativeToContainer = elementRect.top - containerRect.top;
            const targetScrollTop = scrollTop + elementTopRelativeToContainer - headerHeight - desiredPadding;

            mainContentArea.scrollTo({
                top: targetScrollTop,
                behavior: 'smooth'
            });
    // --- END OF NEW LOGIC ---

    updateInNoteUI();
}

function performInNoteSearch() {
    clearInNoteHighlights();
    const query = document.getElementById('in-note-search-input').value;
    if (!query) {
        updateInNoteUI();
        return;
    }

    const editorBody = app.elements.noteEditorBody;
    const regex = new RegExp(`(${query.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')})`, 'gi');

    const walker = document.createTreeWalker(editorBody, NodeFilter.SHOW_TEXT, null, false);
    let node;
    const nodesToReplace = [];
    while (node = walker.nextNode()) {
        if (node.parentElement.tagName !== 'SCRIPT' && node.parentElement.tagName !== 'STYLE' && regex.test(node.textContent)) {
            nodesToReplace.push(node);
        }
    }

    nodesToReplace.forEach(node => {
        const newHtml = node.textContent.replace(regex, `<mark class="in-note-highlight">$1</mark>`);
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = newHtml;
        // Make checklist widget interactive on public page
tempDiv.querySelectorAll('.checklist-container').forEach(el => el.removeAttribute('contenteditable'));
tempDiv.querySelectorAll('.checklist-item-checkbox').forEach(cb => cb.removeAttribute('onclick'));
        const parent = node.parentNode;
        while(tempDiv.firstChild) {
            parent.insertBefore(tempDiv.firstChild, node);
        }
        parent.removeChild(node);
    });

    inNoteMatches = Array.from(editorBody.querySelectorAll('mark.in-note-highlight'));
    if (inNoteMatches.length > 0) {
        navigateToMatch(0);
    } else {
        updateInNoteUI();
    }
}

function setupInNoteSearchListeners() {
    const searchInput = document.getElementById('in-note-search-input');
    document.getElementById('clear-search-btn').addEventListener('click', closeAndClearSearch);

    document.getElementById('in-note-search-next').addEventListener('click', () => {
        if (inNoteCurrentIndex < inNoteMatches.length - 1) {
            navigateToMatch(inNoteCurrentIndex + 1);
        }
    });

    document.getElementById('in-note-search-prev').addEventListener('click', () => {
        if (inNoteCurrentIndex > 0) {
            navigateToMatch(inNoteCurrentIndex - 1);
        }
    });

    searchInput.addEventListener('input', performInNoteSearch);
    searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            if(e.shiftKey) {
                document.getElementById('in-note-search-prev').click();
            } else {
                document.getElementById('in-note-search-next').click();
            }
        }
        if (e.key === 'Escape') {
             // Use the correct button ID for the smart bar's 'X'
             document.getElementById('clear-search-btn').click();
        }
    });
}
// --- END: In-Note Search Logic ---

            // REPLACE THE OLD OBJECT WITH THIS NEW ONE
const defaultState = {
    collections: [
        {
            id: 'c1', 
            name: 'My First Project', 
            type: 'folder', 
            children: [], // The notes have been removed from here
            expanded: true
        }
    ],
    settings: {
        theme: 'reputify',
        activeCollectionId: null, // No active collection by default
        activeNoteId: null,       // No active note by default
        paneWidth: 280,
        sidebarCollapsed: false,
        activeView: 'list',
        listSortOrder: 'modifiedAt-desc',
        editorMode: 'editor',
        activeTag: null,
        tagsCollapsed: false,
        backlinksCollapsed: false,
        chatbotVisible: true,
        propertiesVisible: true,
    },
    templates: [],
    kanbanColumns: {
        'c1': [{ id: 'col1', title: 'To Do' }, { id: 'col2', title: 'In Progress' }, { id: 'col3', title: 'Done' }]
    },
    chatHistory: []
};

            async function saveState() {
                // Get the current user from Firebase Auth
                const user = window.auth.currentUser;

                // If no user is logged in, do nothing.
                if (!user) return;

                try {
                    // Create a reference to a specific document in Firestore.
                    // The path is /users/{the_user's_ID}/data/appState
                    // This ensures every user has their own private data document.
                    const userDocRef = doc(window.db, "users", user.uid, "data", "appState");

                    // Save the entire state object to that document.
                    await setDoc(userDocRef, state);

                } catch (error) {
                    console.error("Failed to save state to Firestore:", error);
                    showToast("Error saving data to the cloud.", 'error');
                }
            }
            function renderTagsState() {
    const isCollapsed = state.settings.tagsCollapsed;
    app.elements.toggleTagsBtn.classList.toggle('collapsed', isCollapsed);
    app.containers.tagList.classList.toggle('collapsed', isCollapsed);
}
            function migrateState(loadedState) {
    // This function ensures that data loaded from the cloud has all the necessary properties,
    // preventing errors if the data structure is old or incomplete.

    const migrateNode = (node) => {
        if (node.type === 'note') {
            if (typeof node.pinned === 'undefined') node.pinned = false;
            if (!Array.isArray(node.links)) node.links = [];
            if (!Array.isArray(node.tags)) node.tags = [];
            const now = new Date().toISOString();
            if (typeof node.createdAt === 'undefined') node.createdAt = now;
            if (typeof node.modifiedAt === 'undefined') node.modifiedAt = node.createdAt;
                    if (typeof node.properties === 'undefined') node.properties = {}; // ADD THIS LINE
                    if (typeof node.propertiesCollapsed === 'undefined') node.propertiesCollapsed = false; // ADD THIS LINE


        }
        if (node.children) {
            // Ensure children is an array before trying to loop through it
            if (Array.isArray(node.children)) {
                node.children.forEach(migrateNode);
            } else {
                node.children = [];
            }
        }
    };
    if (typeof loadedState.settings.backlinksCollapsed === 'undefined') loadedState.settings.backlinksCollapsed = false; // Add this line


    if (!loadedState) loadedState = {};
    if (!loadedState.settings) loadedState.settings = {};
        if (typeof loadedState.settings.chatbotVisible === 'undefined') loadedState.settings.chatbotVisible = true; // ADD THIS LINE
        if (typeof loadedState.settings.propertiesVisible === 'undefined') loadedState.settings.propertiesVisible = true;



    // THIS IS THE KEY FIX: Ensure .collections is always an array.
    if (!Array.isArray(loadedState.collections)) {
        loadedState.collections = [];
    }

    if (!loadedState.kanbanColumns) loadedState.kanbanColumns = {};
    if (!Array.isArray(loadedState.chatHistory)) loadedState.chatHistory = [];
    if (!Array.isArray(loadedState.templates)) loadedState.templates = [];

    // Now that we've confirmed .collections is an array, we can safely loop through it.
    loadedState.collections.forEach(migrateNode);

    // Set default settings if they are missing
    if (typeof loadedState.settings.sidebarCollapsed === 'undefined') loadedState.settings.sidebarCollapsed = false;
    if (typeof loadedState.settings.paneWidth === 'undefined') loadedState.settings.paneWidth = 280;
    if (typeof loadedState.settings.activeTag === 'undefined') loadedState.settings.activeTag = null;
    if (typeof loadedState.settings.tagsCollapsed === 'undefined') loadedState.settings.tagsCollapsed = false; // Add this line
    if (!loadedState.settings.listSortOrder) loadedState.settings.listSortOrder = 'modifiedAt-desc';
    if (!loadedState.settings.editorMode) loadedState.settings.editorMode = 'editor';

    return loadedState;
}

            // REPLACE the old loadState function with this one.

// =================================================================
// START: FINAL REPLACEMENT loadState FUNCTION (WITH MIGRATION)
// =================================================================
// =================================================================
// START: FINAL REPLACEMENT loadState FUNCTION (WITH ALL FIXES)
// =================================================================
// =================================================================
// START: FINAL REPLACEMENT loadState FUNCTION (WITH ALL FIXES)
// =================================================================
// notetakeapp.html

// =================================================================
// START: REPLACEMENT loadState FUNCTION (Lazy Loading)
// =================================================================
async function loadState() {
    const user = window.auth.currentUser;
    if (!user) return;

    const toastId = showToast('Loading workspace...', 'loading');
    // We only need the user's settings and folder structure on initial load.
    const userDocRef = doc(window.db, "users", user.uid, "data", "appState");

    try {
        const { getDoc, collection, writeBatch, doc: createDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");

        const userSettingsSnap = await getDoc(userDocRef);
        let settingsAndFolders;

        if (userSettingsSnap.exists()) {
            settingsAndFolders = userSettingsSnap.data();
        } else {
            console.log("New user detected, creating default state.");
            // For new users, create the default folder structure but don't create note documents yet.
            // They will be created when the user first clicks on them.
            settingsAndFolders = JSON.parse(JSON.stringify(defaultState));
            await setDoc(userDocRef, settingsAndFolders);
        }
        
        // This is the key change: The note cache starts empty!
        window.noteCache = {};
        
        state = migrateState(settingsAndFolders);

    } catch (error) {
        console.error("Failed to load state from Firestore:", error);
        if (!state || Object.keys(state).length === 0) {
             state = migrateState(JSON.parse(JSON.stringify(defaultState)));
        }
        showToast("Offline: Could not sync with cloud.", 'error');
    } finally {
        dismissToast(toastId);
        state.settings.theme = localStorage.getItem('codex-notes-theme') || 'reputify';
    }
}
// =================================================================
// END: REPLACEMENT loadState FUNCTION
// =================================================================
// =================================================================
// END: FINAL REPLACEMENT loadState FUNCTION
// =================================================================
// =================================================================
// END: FINAL REPLACEMENT loadState FUNCTION
// =================================================================
// =================================================================
// END: FINAL REPLACEMENT loadState FUNCTION
// =================================================================

            const generateId = (prefix = 'id') => `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            function formatBytes(bytes, decimals = 2) {
    if (!+bytes) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}
// ADD THIS ENTIRE FUNCTION
async function ensureAllNotesLoaded() {
    const noteIdsToLoad = window.chatbotContextNoteIds.filter(id => !window.noteCache[id]);
    if (noteIdsToLoad.length === 0) {
        return true; // All required notes are already in the cache.
    }

    const toastId = showToast(`Loading ${noteIdsToLoad.length} context note(s)...`, 'loading');

    try {
        const { doc, getDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
        
        const fetchPromises = noteIdsToLoad.map(id => {
            const noteRef = doc(db, "notes", id);
            return getDoc(noteRef).then(noteSnap => {
                if (noteSnap.exists()) {
                    window.noteCache[id] = noteSnap.data(); // Add the loaded note to the cache.
                } else {
                    console.warn(`Context note with ID ${id} not found.`);
                    // Remove missing note from context to prevent future errors
                    window.chatbotContextNoteIds = window.chatbotContextNoteIds.filter(noteId => noteId !== id);
                }
            });
        });

        await Promise.all(fetchPromises);
        dismissToast(toastId);
        renderContextPills(); // Re-render pills in case a note was removed
        return true;

    } catch (error) {
        console.error("Error loading context notes:", error);
        dismissToast(toastId);
        showToast("Failed to load context notes for the chat.", "error");
        return false;
    }
}
const handleFileUpload = async (file) => {
    const user = window.auth.currentUser;
    if (!file || !user) return;
    const spreadsheetTypes = [
        'text/csv',
        'application/vnd.ms-excel',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    ];
    if (spreadsheetTypes.includes(file.type)) {
        handleSpreadsheetUpload(file);
        return; // Stop further execution
    }

    // --- Overall file size limit ---
    const OVERALL_MAX_SIZE = 5 * 1024 * 1024; // 5 MB

    let fileToUpload = file;

    // --- Step 1: Perform local compression if the file is an image ---
    if (file.type.startsWith('image/')) {
        const localToast = showToast(`Optimizing ${file.name}...`, 'loading');
        try {
            const options = {
                maxWidthOrHeight: 1920,
                initialQuality: 0.8,
                fileType: 'image/webp',
                useWebWorker: true,
            };
            fileToUpload = await imageCompression(file, options);
            dismissToast(localToast);
        } catch (error) {
            dismissToast(localToast);
            console.error('Local compression failed.', error);
            // If local compression fails, we continue with the original file.
        }
    }

    // --- Step 2: Check the final file size against the 5MB limit ---
    if (fileToUpload.size > OVERALL_MAX_SIZE) {
        showToast(`File is too large (${(fileToUpload.size / 1024 / 1024).toFixed(2)} MB). Max size is 5MB.`, 'error');
        return;
    }

    // --- Step 3: Upload the processed file directly to Firebase Storage ---
    const uploadToastId = showToast(`Uploading ${fileToUpload.name}... 0%`, 'loading');
    try {
        const { getStorage, ref, uploadBytesResumable, getDownloadURL } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js");
        const storage = getStorage();
        const storageRef = ref(storage, `users/${user.uid}/${Date.now()}-${fileToUpload.name}`);
        const uploadTask = uploadBytesResumable(storageRef, fileToUpload);

        const downloadURL = await new Promise((resolve, reject) => {
            uploadTask.on('state_changed',
                (snapshot) => {
                    const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                    const toastElement = document.getElementById(uploadToastId);
                    if (toastElement) toastElement.textContent = `Uploading ${fileToUpload.name}... ${Math.round(progress)}%`;
                },
                (error) => reject(error),
                async () => {
                    const url = await getDownloadURL(uploadTask.snapshot.ref);
                    resolve(url);
                }
            );
        });

        // --- Step 4: Insert the final file/image into the editor ---
        dismissToast(uploadToastId);
        showToast('Upload complete!', 'success');

        const escapedFileName = fileToUpload.name.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        let fileHTML = '';

        if (fileToUpload.type.startsWith('image/')) {
            fileHTML = `<p><img src="${downloadURL}" alt="${escapedFileName}" style="max-width: 100%; height: auto; border-radius: 8px;" contenteditable="false" /></p>`;
        } else {
            fileHTML = `<div class="file-attachment-widget" contenteditable="false">
                            <i data-feather="file-text" class="w-6 h-6 text-text-secondary flex-shrink-0"></i>
                            <div class="file-info">
                                <div class="file-name">${escapedFileName}</div>
                                <div class="file-size">${formatBytes(fileToUpload.size)}</div>
                            </div>
                            <a href="${downloadURL}" target="_blank" class="brand-button p-2" download title="Download ${escapedFileName}"><i data-feather="download" class="w-5 h-5"></i></a>
                        </div>`;
        }

        app.elements.noteEditorBody.focus();
        document.execCommand('insertHTML', false, fileHTML + "<p><br></p>");
        feather.replace();
        saveNoteContent();

    } catch (error) {
        dismissToast(uploadToastId);
        showToast(`Upload failed: ${error.code || error.message}`, 'error');
        return;
    }
};
            
            

            const debounce = (func, delay) => {
                let timeout;
                return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), delay);
                };
            };
            const scheduleRebuildIndex = debounce(buildLunrIndex, 2000);
            
            
            
            const formatDateTime = (isoString) => {
                 return new Date(isoString).toLocaleString(undefined, {
                    year: 'numeric', month: 'short', day: 'numeric',
                    hour: 'numeric', minute: '2-digit', hour12: true
                 }).replace(/, /g, ', ');
            };
            // ADD THIS NEW HELPER FUNCTION
            // ADD THIS NEW HELPER FUNCTION
function parseDurationToMinutes(str) {
    if (!str) return 0;
    str = str.toLowerCase().trim();
    let totalMinutes = 0;
    const hourMatch = str.match(/(\d*\.?\d+)\s*h/);
    const minMatch = str.match(/(\d+)\s*m/);
    if (hourMatch) totalMinutes += parseFloat(hourMatch[1]) * 60;
    if (minMatch) totalMinutes += parseInt(minMatch[1], 10);
    // If just a number is entered, assume it's minutes
    if (!hourMatch && !minMatch && !isNaN(parseFloat(str))) {
        totalMinutes = parseFloat(str);
    }
    return Math.round(totalMinutes);
}
// ADD THIS NEW HELPER FUNCTION
function updateNowIndicator() {
    let indicator = document.getElementById('now-indicator');
    if (!indicator) return;
    const now = new Date();
    const minutes = now.getHours() * 60 + now.getMinutes();
    const top = (minutes / 60) * 48; // 48px per hour
    indicator.style.top = `${top}px`;
}
function getSelectColor(optionName) {
    const colors = ['bg-blue-500/20 text-blue-400', 'bg-green-500/20 text-green-400', 'bg-yellow-500/20 text-yellow-400', 'bg-red-500/20 text-red-400', 'bg-purple-500/20 text-purple-400', 'bg-pink-500/20 text-pink-400'];
    let hash = 0;
    for (let i = 0; i < optionName.length; i++) {
        hash = optionName.charCodeAt(i) + ((hash << 5) - hash);
    }
    return colors[Math.abs(hash % colors.length)];
}
            
            async function callGeminiAPI(payload, elementForError) {
                // Clear any previous errors
                if (elementForError) elementForError.textContent = '';

                try {
                    // Create a reference to our deployed Cloud Function
                    const { httpsCallable } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-functions.js");
                    const callGeminiFunction = httpsCallable(window.functions, 'callGemini');
                    
                    // Call the function with our prompt.
                    // The Firebase SDK automatically handles sending the user's auth token.
                    const response = await callGeminiFunction({ prompt: payload.contents[0].parts[0].text });

                    // The actual result from our function is in response.data.result
                    const generatedText = response.data.result;

                    if (!generatedText) {
                        throw new Error('Cloud function returned an empty response.');
                    }
                    return generatedText;

                } catch (err) {
                    console.error("Error calling Cloud Function:", err);
                    const errorMsg = `AI Error: ${err.message}`;
                    if (elementForError) elementForError.textContent = errorMsg;
                    else showToast(errorMsg, 'error');
                    return null;
                }
            }

            const openModal = (modal, isBlocking = false) => {
                const backdrop = app.modals.backdrop;
                
                if (isBlocking) {
                    backdrop.classList.add('bg-black/50');
                    backdrop.classList.remove('bg-black/30');
                } else {
                    backdrop.classList.add('bg-black/30');
                    backdrop.classList.remove('bg-black/50');
                }
                backdrop.style.opacity = '1';
                modal.classList.remove('hidden');
                setTimeout(() => {
                    modal.classList.remove('scale-95', 'opacity-0');
                }, 10);
            };

            const closeModal = (modal) => {
                const backdrop = app.modals.backdrop;
                backdrop.style.opacity = '0';
                backdrop.style.pointerEvents = 'none';

                modal.classList.add('scale-95', 'opacity-0');
                setTimeout(() => {
                    modal.classList.add('hidden');
                }, 300);
            };

            const showPrompt = ({ title, message, initialValue = '', placeholder = '', isReadOnly = false }) => {
    return new Promise((resolve) => {
        app.modals.promptTitle.textContent = title;
        app.modals.promptMessage.textContent = message;
        app.modals.promptInput.value = initialValue;
        app.modals.promptInput.placeholder = placeholder;
        app.modals.promptInput.readOnly = isReadOnly;
        app.modals.promptError.textContent = '';

        app.modals.promptConfirmBtn.textContent = isReadOnly ? 'Copy Link' : 'Confirm';

        openModal(app.modals.prompt);
        app.modals.promptInput.focus();
        app.modals.promptInput.select();

        const confirmHandler = () => {
            if (isReadOnly) {
                navigator.clipboard.writeText(app.modals.promptInput.value)
                    .then(() => showToast('Link copied to clipboard!', 'success'))
                    .catch(() => showToast('Failed to copy link.', 'error'));
                cleanup();
                resolve(null);
            } else {
                const value = app.modals.promptInput.value.trim();
                if (value) {
                    cleanup();
                    resolve(value);
                } else {
                    app.modals.promptError.textContent = 'Input cannot be empty.';
                }
            }
        };

        const cancelHandler = () => { cleanup(); resolve(null); };
        const keydownHandler = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                confirmHandler();
            }
        };
const cleanup = () => {
    app.modals.promptConfirmBtn.removeEventListener('click', confirmHandler);
    app.modals.promptCancelBtn.removeEventListener('click', cancelHandler);
    app.modals.backdrop.removeEventListener('click', backdropHandler);
            app.modals.promptInput.removeEventListener('keydown', keydownHandler);
    closeModal(app.modals.prompt);
};

const backdropHandler = () => cancelHandler();

app.modals.promptConfirmBtn.addEventListener('click', confirmHandler);
app.modals.promptCancelBtn.addEventListener('click', cancelHandler);
app.modals.backdrop.addEventListener('click', backdropHandler);
        app.modals.promptInput.addEventListener('keydown', keydownHandler);
    });
};
            
            const showConfirm = ({ title, message, confirmText = 'Confirm', confirmClass = 'bg-red-600' }) => {
     return new Promise((resolve) => {
        app.modals.confirmTitle.textContent = title;
        app.modals.confirmMessage.innerHTML = message;
        app.modals.confirmConfirmBtn.textContent = confirmText;
        
        app.modals.confirmConfirmBtn.className = "px-4 py-2 rounded-md text-white hover:opacity-90";
        if (state.settings.theme === 'reputify' && confirmClass.includes('red')) {
            app.modals.confirmConfirmBtn.classList.add('bg-red-600');
        } else {
            app.modals.confirmConfirmBtn.classList.add('brand-button');
        }

        openModal(app.modals.confirm);
        app.modals.backdrop.style.pointerEvents = 'auto'; // <-- ADD THIS LINE

        const confirmHandler = () => { cleanup(); resolve(true); };
        const cancelHandler = () => { cleanup(); resolve(false); };
        const backdropHandler = () => cancelHandler();

        const cleanup = () => {
            app.modals.backdrop.style.pointerEvents = 'none'; // <-- ADD THIS LINE
            app.modals.confirmConfirmBtn.removeEventListener('click', confirmHandler);
            app.modals.confirmCancelBtn.removeEventListener('click', cancelHandler);
            app.modals.backdrop.removeEventListener('click', backdropHandler);
            closeModal(app.modals.confirm);
        };

        app.modals.confirmConfirmBtn.addEventListener('click', confirmHandler);
        app.modals.confirmCancelBtn.addEventListener('click', cancelHandler);
        app.modals.backdrop.addEventListener('click', backdropHandler);
    });
};
// ADD THIS ENTIRE FUNCTION
const openLinkModal = () => {
    return new Promise((resolve) => {
        const modal = document.getElementById('link-modal');
        const input = document.getElementById('link-modal-input');
        const resultsContainer = document.getElementById('link-modal-results');
        const closeBtn = document.getElementById('link-modal-close-btn');

        // Store the selection when the modal opens
        const savedRange = editorSelectionRange ? editorSelectionRange.cloneRange() : null;

        const currentNoteId = state.settings.activeNoteId;
        const allNotes = getAllNotes(state.collections).filter(note => note.id !== currentNoteId);
        const fuse = new Fuse(allNotes, { keys: ['name'], threshold: 0.4 });

        const cleanupAndClose = (result = null) => {
            input.removeEventListener('input', handleSearch);
            resultsContainer.removeEventListener('click', handleResultClick);
            closeBtn.removeEventListener('click', () => cleanupAndClose());
            document.removeEventListener('keydown', handleEsc);
            closeModal(modal);
            resolve({ result, range: savedRange });
        };

        const renderResults = (items, isUrl = false) => {
            if (isUrl) {
                resultsContainer.innerHTML = `
                    <div class="link-modal-item p-2 rounded-md hover:bg-bg-pane-dark cursor-pointer" data-url="${items}">
                        <div class="flex items-center gap-3">
                            <i data-feather="link" class="w-5 h-5 text-text-secondary flex-shrink-0"></i>
                            <div class="min-w-0">
                                <div class="font-semibold text-text-primary truncate">Link to web page</div>
                                <div class="text-sm text-text-secondary truncate">${items}</div>
                            </div>
                        </div>
                    </div>`;
            } else {
                if (items.length === 0) {
                    resultsContainer.innerHTML = `<p class="p-4 text-center text-sm text-text-tertiary">No notes found.</p>`;
                    return;
                }
                resultsContainer.innerHTML = items.map(note => {
                    const findResult = findItem(note.id);
                    const parentName = (findResult && findResult.parent && !Array.isArray(findResult.parent)) ? findResult.parent.name : 'Uncategorized';
                    return `
                        <div class="link-modal-item p-2 rounded-md hover:bg-bg-pane-dark cursor-pointer" data-note-id="${note.id}" data-note-name="${note.name.replace(/"/g, '&quot;')}">
                            <div class="flex items-center gap-3">
                                <i data-feather="file-text" class="w-5 h-5 text-text-secondary flex-shrink-0"></i>
                                <div class="min-w-0">
                                    <div class="font-semibold text-text-primary truncate">${note.name}</div>
                                    <div class="text-sm text-text-secondary truncate">${parentName}</div>
                                </div>
                            </div>
                        </div>`;
                }).join('');
            }
            feather.replace();
        };

        const handleSearch = () => {
            const query = input.value.trim();
            if (/(^https?:\/\/)|(\w+\.\w{2,})/.test(query) && !query.includes(' ')) {
                renderResults(query, true);
            } else if (query === "") {
                const recentNotes = [...allNotes].sort((a, b) => new Date(b.modifiedAt) - new Date(a.modifiedAt)).slice(0, 5);
                renderResults(recentNotes);
            } else {
                const searchResults = fuse.search(query).map(result => result.item);
                renderResults(searchResults);
            }
        };

        const handleResultClick = (e) => {
            const item = e.target.closest('.link-modal-item');
            if (!item) return;

            if (item.dataset.noteId) {
                cleanupAndClose({ type: 'internal', id: item.dataset.noteId, name: item.dataset.noteName });
            } else if (item.dataset.url) {
                cleanupAndClose({ type: 'external', url: item.dataset.url });
            }
        };
        
        const handleEsc = (e) => {
            if (e.key === 'Escape') {
                cleanupAndClose();
            }
        };

        input.value = '';
        handleSearch(); // Initial render with recents
        openModal(modal);
        input.focus();
        input.addEventListener('input', handleSearch);
        resultsContainer.addEventListener('click', handleResultClick);
        closeBtn.addEventListener('click', () => cleanupAndClose());
        document.addEventListener('keydown', handleEsc, { once: true });
    });
};
            
            function render() {
    renderTheme();
    renderSidebarState();
    renderCollectionsList();
    renderTagList();
    renderTagsState();
    //renderChatbotState(); // This line is removed
    renderMainView();
    renderMobileControls();

    // --- START: NEW CONSOLIDATED LOGIC ---
    const fab = document.getElementById('chatbot-fab');
    const toggleBtn = document.getElementById('chatbot-toggle-btn');

    if (state.settings.chatbotVisible) {
        fab.style.display = 'flex'; // Use style.display for direct control
        toggleBtn.querySelector('span').textContent = 'Hide Chatbot Button';
    } else {
        fab.style.display = 'none'; // Use style.display for direct control
        toggleBtn.querySelector('span').textContent = 'Show Chatbot Button';
    }
    const propertiesBtn = document.getElementById('toggle-properties-btn');
if (propertiesBtn) {
    const icon = propertiesBtn.querySelector('i, svg');
    const text = propertiesBtn.querySelector('span');
    if (state.settings.propertiesVisible) {
        text.textContent = 'Hide Properties';
        icon.setAttribute('data-feather', 'eye-off');
    } else {
        text.textContent = 'Show Properties';
        icon.setAttribute('data-feather', 'eye');
    }
}
    // --- END: NEW CONSOLIDATED LOGIC ---


    const noteActive = !!state.settings.activeNoteId;
    document.getElementById('header-share-btn').style.display = noteActive ? 'flex' : 'none';
    document.getElementById('header-summarize-btn').style.display = noteActive ? 'flex' : 'none';
    document.getElementById('header-quiz-btn').style.display = noteActive ? 'flex' : 'none';
    document.getElementById('header-flashcard-btn').style.display = noteActive ? 'flex' : 'none';

    app.toolbar.editorModeToggle.disabled = !noteActive;
    app.toolbar.dictateBtn.disabled = !noteActive || !speechRecognizer;
    app.toolbar.graphBtn.disabled = !noteActive;
    document.getElementById('header-template-btn').style.display = noteActive ? 'flex' : 'none';
    document.getElementById('header-collaborate-btn').style.display = noteActive ? 'flex' : 'none';

    feather.replace();
}
            
            function renderTheme() {
                const docEl = document.documentElement;
                docEl.classList.remove('reputify-theme', 'dark', 'light');
                app.elements.themeReputifyIcon.classList.add('hidden');
                app.elements.themeSunIcon.classList.add('hidden');
                app.elements.themeMoonIcon.classList.add('hidden');

                if (state.settings.theme === 'dark') {
                    docEl.classList.add('dark');
                    app.elements.themeMoonIcon.classList.remove('hidden');
                    app.elements.themeText.textContent = 'Dark Theme';
                } else if (state.settings.theme === 'reputify') {
                    docEl.classList.add('reputify-theme');
                    app.elements.themeReputifyIcon.classList.remove('hidden');
                    app.elements.themeText.textContent = 'Reputify Theme';
                } else {
                    docEl.classList.add('light');
                    app.elements.themeSunIcon.classList.remove('hidden');
                    app.elements.themeText.textContent = 'Light Theme';
                }
                const themeColor = getComputedStyle(document.documentElement).getPropertyValue('--bg-main').trim();
const themeMeta = document.getElementById('theme-color-meta');
if (themeMeta) {
    themeMeta.setAttribute('content', themeColor);
}
            }
            
            function renderSidebarState() {
                const pane = app.elements.notesListPane;
                const resizer = app.elements.paneResizer;
                const body = app.elements.body;
                const toggleBtn = app.elements.sidebarToggleBtn;

                if (state.settings.sidebarCollapsed) {
                    pane.classList.add('collapsed');
                    resizer.classList.add('hidden');
                    body.classList.add('sidebar-collapsed');
                    toggleBtn.style.left = '0px';
                } else {
                    pane.classList.remove('collapsed');
                    pane.style.width = `${state.settings.paneWidth}px`;
                    resizer.classList.remove('hidden');
                    body.classList.remove('sidebar-collapsed');
                    toggleBtn.style.left = `${state.settings.paneWidth}px`;
                }
            }

            function renderCollectionsList(collections = state.collections, level = 0) {
    // Helper function to create the HTML for a single item (note or folder)
    const createItemHTML = (item, currentLevel) => {
        const isActive = item.id === state.settings.activeCollectionId;
        const isNoteActive = item.id === state.settings.activeNoteId;
        const isFolder = item.type === 'folder';

        let newNoteParentId = null;
        if (isFolder) {
            newNoteParentId = item.id;
        } else {
            const findResult = findItem(item.id);
            const parent = findResult ? findResult.parent : null;
            if (parent && !Array.isArray(parent)) {
                newNoteParentId = parent.id;
            }
        }

        let sharedIconHTML = '';
        const noteData = window.noteCache[item.id];
        const user = window.auth.currentUser;
        const isSharedWithMe = noteData && user && noteData.ownerId !== user.uid;

        // Add the 'users' icon only if it's a shared note
        if (item.type === 'note' && isSharedWithMe) {
            sharedIconHTML = `<i data-feather="users" class="w-4 h-4 text-text-secondary ml-auto mr-2" title="Shared with you"></i>`;
        }

        if (isFolder && item.children) {
            item.children.sort((a, b) => {
                if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
                return a.name.localeCompare(b.name);
            });
        }

        return `
            <li data-id="${item.id}" draggable="true" class="collection-item-wrapper group rounded-md">
                <div class="collection-item flex items-center justify-between gap-2 p-2 rounded-md hover:bg-bg-pane-dark ${isActive || isNoteActive ? 'bg-bg-pane-dark font-semibold' : ''}" style="padding-left: ${8 + currentLevel * 16}px;">
                    <a href="#" class="collection-item-link flex items-center gap-2 flex-grow min-w-0">
                        ${isFolder ? `<i data-feather="chevron-right" class="chevron w-4 h-4 flex-shrink-0 text-text-tertiary ${item.expanded ? 'open' : ''}"></i>` : ''}
                        ${!isSharedWithMe ? `<i data-feather="${isFolder ? 'folder' : (item.pinned ? 'paperclip' : 'file-text')}" class="w-4 h-4 flex-shrink-0 text-text-secondary ${item.pinned ? 'text-accent-primary': ''}"></i>` : ''}
                        <span class="truncate">${item.name}</span>
                    </a>
                    ${sharedIconHTML}
                    <button class="add-note-btn opacity-0 group-hover:opacity-100 transition-opacity" data-parent-id="${newNoteParentId}" title="Add New Note">
                        <i data-feather="plus" class="w-4 h-4 pointer-events-none"></i>
                    </button>
                </div>
                ${isFolder && item.expanded && item.children ? `<ul class="collection-children">${renderCollectionsList(item.children, currentLevel + 1)}</ul>` : ''}
            </li>
        `;
    };

    // --- NEW LOGIC IS HERE ---
    // This only runs for the top-level rendering (level 0)
    if (level === 0) {
        const user = window.auth.currentUser;
        const userItems = [];
        const sharedItems = [];

        // 1. Separate user's own items from shared items
        collections.forEach(item => {
            const noteData = window.noteCache[item.id];
            if (item.type === 'note' && user && noteData && noteData.ownerId !== user.uid) {
                sharedItems.push(item);
            } else {
                userItems.push(item);
            }
        });

        // 2. Sort both lists independently
        userItems.sort((a, b) => {
            if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
            return a.name.localeCompare(b.name);
        });
        sharedItems.sort((a, b) => a.name.localeCompare(b.name));
        
        // 3. Build the final HTML string with the new structure
        let finalHTML = `<ul class="space-y-1">${userItems.map(item => createItemHTML(item, 0)).join('')}</ul>`;

        if (sharedItems.length > 0) {
            finalHTML += `
                <div class="px-2 pt-4 pb-1">
                    <h3 class="font-bold text-xs uppercase tracking-wider text-text-tertiary">Shared with You</h3>
                </div>
                <ul class="space-y-1">${sharedItems.map(item => createItemHTML(item, 0)).join('')}</ul>
            `;
        }

        app.containers.collectionsList.innerHTML = finalHTML;
        feather.replace();

    } else {
        // For nested levels (folders), render as before
        collections.sort((a, b) => {
            if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
            return a.name.localeCompare(b.name);
        });
        return collections.map(item => createItemHTML(item, level)).join('');
    }
}
            function renderTagList() {
    const allNotes = getAllNotes(state.collections);
    // Get a flat list of all tags, including duplicates.
    const allTagsRaw = allNotes.flatMap(note => note.tags || []);

    if (allTagsRaw.length === 0) {
        app.containers.tagList.innerHTML = `<p class="px-2 text-xs text-text-tertiary">No tags found.</p>`;
        return;
    }

    // Create a frequency map to count how many times each tag is used.
    const tagCounts = allTagsRaw.reduce((acc, tag) => {
        acc[tag] = (acc[tag] || 0) + 1;
        return acc;
    }, {});

    // Get the unique tags and sort them alphabetically.
    const uniqueTags = [...new Set(allTagsRaw)].sort();

    // Update the HTML to include the count in a styled badge.
    app.containers.tagList.innerHTML = uniqueTags.map(tag => {
        const count = tagCounts[tag];
        return `
            <a href="#" class="tag-filter-item flex justify-between items-center text-sm p-1 px-2 rounded-md text-text-secondary hover:bg-bg-pane-dark hover:text-text-primary ${state.settings.activeTag === tag ? 'active' : ''}" data-tag="${tag}">
                <span>#${tag}</span>
                <span class="text-xs bg-bg-pane-dark rounded-full px-1.5 py-0.5 ml-2">${count}</span>
            </a>
        `
    }).join('');
}

            

            function updateNoteTags(note) {
                if (!note || typeof note.content !== 'string') return;
                const plainText = note.content.replace(/<[^>]*>?/gm, '');
                const matches = plainText.match(/#(\w+)/g) || [];
                note.tags = [...new Set(matches.map(tag => tag.substring(1)))];
            }

            function updateNoteLinks(note) {
                if (!note || typeof note.content !== 'string') return;
                const plainText = note.content.replace(/<[^>]*>?/gm, '');
                const matches = plainText.matchAll(/\[\[(.*?)\]\]/g);
                note.links = [...matches].map(match => match[1].trim());
            }

            function renderMainView() {
                document.querySelectorAll('.notes-view').forEach(v => v.classList.add('hidden'));
                    document.body.classList.remove('mobile-editor-active'); // ADD THIS LINE

                document.getElementById('main-header')?.classList.remove('hidden');
    document.getElementById('mobile-sticky-toolbar')?.classList.add('hidden');
                    document.getElementById('mobile-sticky-toolbar')?.classList.add('hidden');


                if (isSearchActive) {
                    renderSearchResults(app.search.input.value);
                    return;
                }
                
                const isNoteActive = !!state.settings.activeNoteId;
                const isTagActive = !!state.settings.activeTag;
                const activeCollection = findItem(state.settings.activeCollectionId)?.item;

                if (isTagActive) {
                    app.elements.currentViewTitle.textContent = `Tag: #${state.settings.activeTag}`;
                } else {
                    app.elements.currentViewTitle.textContent = activeCollection?.name || "All Notes";
                }
                
                const showListControls = !isNoteActive && (state.settings.activeView === 'list' || !activeCollection || isTagActive);

                app.elements.viewSwitcher.style.display = isNoteActive || !activeCollection || isTagActive ? 'none' : 'flex';
                app.elements.listViewControls.style.display = showListControls ? 'flex' : 'none';
                

                if (isNoteActive) {
                    renderNoteEditor();
                } else if (isTagActive) {
                    renderListView();
                } else if (activeCollection) {
                     document.querySelectorAll('#view-switcher-container .view-btn').forEach(b => b.classList.remove('active'));
                     document.querySelector(`#view-switcher-container .view-btn[data-view="${state.settings.activeView}"]`)?.classList.add('active');
                    
                    if (state.settings.activeView === 'board') {
                        renderKanbanView();
                    }else if (state.settings.activeView === 'calendar') { // ADD THIS BLOCK
    renderCalendarView();
} else if (state.settings.activeView === 'gallery') { // ADD THIS BLOCK
    renderGalleryView();
}else {
                        renderListView();
                    }
                } else {
                     renderListView();
                }
            }
            
            function renderMobileControls() {
    const activeCollection = findItem(state.settings.activeCollectionId)?.item;
    const note = findItem(state.settings.activeNoteId)?.item;
    const isNoteActive = !!note;

    let controlsHTML = '';
    
    if (isNoteActive) {
        // This block now contains BOTH AI Tools and Note Tools
        const pinText = note.pinned ? 'Unpin Note' : 'Pin Note';
        controlsHTML = `
            <div class="text-xs text-text-tertiary px-3 pt-2 pb-1 font-semibold uppercase">AI Tools</div>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-summarize">
                <i data-feather="zap" class="w-4 h-4"></i>AI Summary
            </button>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-quiz">
                <i data-feather="help-circle" class="w-4 h-4"></i>MCQ Quiz
            </button>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-flashcard">
    <i data-feather="copy" class="w-4 h-4"></i>Flashcards
</button>

            <hr class="my-1 border-border-color">

            <div class="text-xs text-text-tertiary px-3 pt-2 pb-1 font-semibold uppercase">Note Tools</div>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-new-note">
    <i data-feather="file-plus" class="w-4 h-4"></i>New Note
</button>
<button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-new-from-template">
    <i data-feather="file-plus" class="w-4 h-4"></i>New from Template
</button>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-rename">
                <i data-feather="edit-2" class="w-4 h-4"></i>Rename
            </button>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-duplicate">
                <i data-feather="copy" class="w-4 h-4"></i>Duplicate
            </button>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-save-as-template">
    <i data-feather="save" class="w-4 h-4"></i>Save as Template
</button>
<button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-collaborate">
    <i data-feather="users" class="w-4 h-4"></i>Collaborate
</button>

            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-share">
    <i data-feather="share-2" class="w-4 h-4"></i>Share Note
</button>
<button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-pin">
                <i data-feather="paperclip" class="w-4 h-4"></i>${pinText}
            </button>
<button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-upload">
    <i data-feather="upload-cloud" class="w-4 h-4"></i>Upload File
</button>
<button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-add-checklist">
    <i data-feather="check-square" class="w-4 h-4"></i>Add Checklist
</button>
<hr class="my-1 border-border-color">
<div class="text-xs text-text-tertiary px-3 pt-2 pb-1 font-semibold uppercase">Versions</div>
<button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-checkpoint">
    <i data-feather="flag" class="w-4 h-4"></i>Save Checkpoint
</button>

<button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-history">
    <i data-feather="clock" class="w-4 h-4"></i>Version History
</button>
            
            <hr class="my-1 border-border-color">
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2 text-red-500" data-action="mobile-delete">
                <i data-feather="trash-2" class="w-4 h-4"></i>Delete
            </button>
        `;
    }  else if (activeCollection) {
    controlsHTML += `
        <div class="text-xs text-text-tertiary px-3 pt-2 pb-1 font-semibold uppercase">Actions</div>
        <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-new-note">
            <i data-feather="file-plus" class="w-4 h-4"></i>New Note
        </button>
        <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-rename-folder">
    <i data-feather="edit-2" class="w-4 h-4"></i>Rename Folder
</button>
        <hr class="my-1 border-border-color">
        <div class="text-xs text-text-tertiary px-3 pt-2 pb-1 font-semibold uppercase">View</div>
        <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2 view-btn-mobile" data-view="calendar"><i data-feather="calendar" class="w-4 h-4"></i>Calendar</button>
        <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2 view-btn-mobile" data-view="list"><i data-feather="list" class="w-4 h-4"></i>List</button>
    `; 
//...
        if (state.settings.activeView === 'list') {
            controlsHTML += `<hr class="my-1 border-border-color">
                <div class="text-xs text-text-tertiary px-3 pt-2 pb-1 font-semibold uppercase">Sort By</div>
                <select id="sort-order-mobile" class="w-full bg-transparent text-text-primary text-sm rounded-md p-2 border-0 focus:ring-0">
                    <option value="modifiedAt-desc">Last Modified</option>
                    <option value="createdAt-desc">Date Created</option>
                    <option value="name-asc">Title (A-Z)</option>
                </select>
            `;
        }controlsHTML += `
        <hr class="my-1 border-border-color">
        <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2 text-red-500" data-action="mobile-delete-folder">
            <i data-feather="trash-2" class="w-4 h-4"></i>Delete Folder
        </button>
    `;
    } else {
        controlsHTML = `<div class="px-3 py-2 text-sm text-text-secondary">No options available</div>`;
    }

    app.containers.mobileControlsDropdown.innerHTML = controlsHTML;

    const mobileSortSelect = document.getElementById('sort-order-mobile');
    if (mobileSortSelect) {
        mobileSortSelect.value = state.settings.listSortOrder;
        mobileSortSelect.addEventListener('change', (e) => {
            state.settings.listSortOrder = e.target.value;
            app.elements.sortOrderSelect.value = e.target.value;
            saveState();
            renderListView();
        });
    }

    document.querySelectorAll('.view-btn-mobile').forEach(btn => {
        if (btn.dataset.view === state.settings.activeView) {
            btn.classList.add('bg-bg-pane-dark', 'font-semibold');
        }
    });
    feather.replace();
}
// ADD THIS ENTIRE NEW FUNCTION
// REPLACE THE ENTIRE renderCalendarView FUNCTION WITH THIS
// REPLACE THE ENTIRE renderCalendarView FUNCTION
function renderCalendarView() {
    const calendarView = document.getElementById('calendar-view');
    calendarView.classList.remove('hidden');
    const collectionId = state.settings.activeCollectionId;
    const collection = findItem(collectionId)?.item;

    if (!collection || collection.type !== 'folder') {
        calendarView.innerHTML = `<div class="text-center p-10 text-text-secondary"><i data-feather="calendar" class="w-12 h-12 mx-auto mb-4"></i><h3 class="font-semibold">Calendar View</h3><p>This view is only available for folders.</p></div>`;
        feather.replace();
        return;
    }

    const today = new Date();
    if (!state.calendar) state.calendar = {};
    if (!state.calendar[collectionId]) {
        state.calendar[collectionId] = { month: today.getMonth(), year: today.getFullYear() };
    }

    let { month, year } = state.calendar[collectionId];
    const firstDayOfMonth = new Date(year, month, 1);
    const lastDayOfMonth = new Date(year, month + 1, 0);
    const daysInMonth = lastDayOfMonth.getDate();
    const startingDay = firstDayOfMonth.getDay();

    const notesInCollection = (collection.children || []).filter(note => note.type === 'note');
    const notesWithDates = notesInCollection.map(note => {
        const dateProp = Object.values(note.properties || {}).find(p => p.type === 'date' && p.value);
        return dateProp ? { ...note, eventDate: new Date(dateProp.value) } : null;
    }).filter(Boolean);

    const daysOfWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

    let html = `
    <div class="calendar-grid-wrapper h-full">
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h3 class="text-xl font-semibold text-text-primary">${firstDayOfMonth.toLocaleString('default', { month: 'long' })} ${year}</h3>
            <div class="flex items-center gap-2">
                <button id="calendar-day-view-btn" class="view-btn px-2.5 py-1 rounded" title="Day View"><i data-feather="sidebar" class="w-4 h-4"></i></button>
                <button id="calendar-month-view-btn" class="view-btn px-2.5 py-1 rounded active" title="Month View"><i data-feather="calendar" class="w-4 h-4"></i></button>
                <button id="calendar-prev-month" class="p-2 rounded-md hover:bg-bg-pane-dark"><i data-feather="chevron-left" class="w-5 h-5"></i></button>
                <button id="calendar-next-month" class="p-2 rounded-md hover:bg-bg-pane-dark"><i data-feather="chevron-right" class="w-5 h-5"></i></button>
            </div>
        </header>
        <div class="grid grid-cols-7 gap-px bg-border-color border border-border-color rounded-lg flex-grow min-h-0">
            ${daysOfWeek.map(day => `<div class="text-center font-semibold text-sm py-2 bg-bg-pane-dark text-text-secondary">${day}</div>`).join('')}
    `;

    for (let i = 0; i < startingDay; i++) { html += `<div class="bg-bg-pane-light"></div>`; }

    for (let day = 1; day <= daysInMonth; day++) {
        const currentDate = new Date(year, month, day);

        // --- THIS IS THE FIX ---
        // Manually create the YYYY-MM-DD string to avoid timezone conversion errors.
        const yyyy = currentDate.getFullYear();
        const mm = String(currentDate.getMonth() + 1).padStart(2, '0');
        const dd = String(currentDate.getDate()).padStart(2, '0');
        const currentDateStr = `${yyyy}-${mm}-${dd}`;
        // --- END OF FIX ---

        const notesForDay = notesWithDates.filter(note => new Date(note.eventDate).toDateString() === currentDate.toDateString());

        html += `<div class="calendar-day-cell custom-scrollbar" data-date="${currentDateStr}">
            <div class="calendar-day-number" title="View Day">${day}</div>
            <div class="mt-1 space-y-1">
            ${notesForDay.map(note => {
                const selectProp = Object.values(note.properties || {}).find(p => p.type === 'select' && p.value);
                const colorClass = selectProp ? getSelectColor(selectProp.value).split(' ')[0] : 'bg-transparent';
                return `<div class="calendar-event-item" draggable="true" data-note-id="${note.id}">
                    <div class="event-color-dot ${colorClass}"></div>
                    <span class="truncate pointer-events-none">${note.name}</span>
                </div>`;
            }).join('')}
            </div>
        </div>`;
    }

    const remainingCells = (7 - ((startingDay + daysInMonth) % 7)) % 7;
    for (let i = 0; i < remainingCells; i++) { html += `<div class="bg-bg-pane-light"></div>`; }

    html += `</div></div>`;
    calendarView.innerHTML = html;
    feather.replace();
}
// END OF NEW FUNCTION
// ADD THIS ENTIRE NEW FUNCTION
function renderGalleryView() {
    const galleryView = document.getElementById('gallery-view');
    galleryView.classList.remove('hidden');

    const collectionId = state.settings.activeCollectionId;
    const collection = findItem(collectionId)?.item;

    if (!collection || collection.type !== 'folder') {
        galleryView.innerHTML = `<div class="text-center p-10 text-text-secondary"><i data-feather="grid" class="w-12 h-12 mx-auto mb-4"></i><h3 class="font-semibold">Gallery View</h3><p>This view is only available for folders.</p></div>`;
        feather.replace();
        return;
    }

    const notes = (collection.children || []).filter(note => note.type === 'note');

    if (notes.length === 0) {
        galleryView.innerHTML = `<div class="text-center p-10 text-text-secondary"><i data-feather="inbox" class="w-12 h-12 mx-auto mb-4"></i><h3 class="font-semibold">No Notes Here</h3><p>Create a new note to see it in the gallery.</p></div>`;
        feather.replace();
        return;
    }

    const cardsHTML = notes.map(note => {
        // --- Smart Cover Image Logic ---
        let coverImageHTML = '';
        let coverImageFound = false;
        // 1. Look for a specific "Cover Image" or "Image" property
        const coverProp = Object.values(noteData.properties || {}).find(p => p.type === 'image' && p.value);
        if (coverProp) {
            coverImageHTML = `<div class="h-32 bg-cover bg-center" style="background-image: url('${firstImage.src}')"></div>`;
            coverImageFound = true;
        } else {
            // 2. If not found, look for the first image in the note's content
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = noteData.content;
            const firstImage = tempDiv.querySelector('img');
            if (firstImage) {
                coverImageHTML = `<div class="h-32 bg-cover bg-center" style="background-image: url('${firstImage.src}')"></div>`;
                coverImageFound = true;
            } else {
                // 3. Fallback if no image is found
                const plainContent = noteData.content.replace(/<[^>]*>?/gm, '').trim();
                const excerpt = plainContent.substring(0, 100) + (plainContent.length > 100 ? '...' : '');
                coverImageHTML = `<div class="h-32 p-3 text-sm text-text-secondary overflow-hidden">${excerpt || 'Empty Note'}</div>`;
            }
        }

        // --- Property Display Logic ---
        const statusProp = Object.values(note.properties || {}).find(p => p.type === 'select' && p.value);
        let propertiesHTML = '';
        if (statusProp) {
            const colorClass = getSelectColor(statusProp.value);
            propertiesHTML += `<div class="mt-2"><span class="rounded px-2 py-0.5 text-xs ${colorClass}">${statusProp.value}</span></div>`;
        }

        return `
            <a href="#" class="gallery-card-item block bg-bg-pane-light border border-border-color rounded-lg overflow-hidden transition-all hover:shadow-lg hover:-translate-y-1" data-note-id="${note.id}">
                ${coverImageHTML}
                <div class="p-3">
                    <h4 class="font-semibold text-text-primary truncate">${note.name}</h4>
                    ${propertiesHTML}
                </div>
            </a>
        `;
    }).join('');

    galleryView.innerHTML = `
        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
            ${cardsHTML}
        </div>
    `;
}
// ADD THIS ENTIRE NEW FUNCTION
// REPLACE THE ENTIRE renderDayView FUNCTION
// REPLACE THE ENTIRE renderDayView FUNCTION
// REPLACE THE ENTIRE renderDayView FUNCTION
function renderDayView(date) {
    const calendarView = document.getElementById('calendar-view');
    const collectionId = state.settings.activeCollectionId;
    const collection = findItem(collectionId)?.item;
    if (!collection) return;

    // --- THIS IS THE FIX ---
    // Manually create a timezone-independent YYYY-MM-DD string for the data attribute.
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const dd = String(date.getDate()).padStart(2, '0');
    const dateStringForData = `${yyyy}-${mm}-${dd}`;
    // --- END OF FIX ---

    const notesInCollection = (collection.children || []).filter(note => note.type === 'note');
    const notesForDay = notesInCollection.map(note => {
        const dateProp = Object.values(note.properties || {}).find(p => p.type === 'date' && p.value);
        if (dateProp) {
            const eventDate = new Date(dateProp.value);
            if (eventDate.toDateString() === date.toDateString()) {
                const endDate = dateProp.endValue ? new Date(dateProp.endValue) : null;
                return { ...note, eventDate, endDate };
            }
        }
        return null;
    }).filter(Boolean);

    const allDayEvents = notesForDay.filter(note => !note.eventDate.toTimeString().startsWith('00:00:00') && (!note.endDate || (note.endDate.getTime() - note.eventDate.getTime()) >= 86400000));
    const timedEvents = notesForDay.filter(note => !allDayEvents.includes(note));
    timedEvents.sort((a, b) => a.eventDate - b.eventDate);

    // Use the new timezone-safe date string in the container's data attribute
    let html = `<div class="day-view-container" data-date="${dateStringForData}"> 
        <header class="flex justify-between items-center mb-4 flex-shrink-0">
            <h3 class="text-xl font-semibold text-text-primary">${date.toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric' })}</h3>
            <div class="flex items-center gap-2">
                <button id="calendar-month-view-btn" class="view-btn px-2.5 py-1 rounded"><i data-feather="calendar" class="w-4 h-4 mr-2"></i>Back to Month</button>
            </div>
        </header>

        <div class="day-view-timeline-wrapper custom-scrollbar">
            <div class="relative h-[1152px]">
                <div class="day-view-grid">
                    ${Array.from({ length: 24 }).map((_, hour) => {
                        const time = new Date(); time.setHours(hour, 0);
                        return `<div class="day-view-hour-slot" data-time="${time.toLocaleTimeString(undefined, { hour: 'numeric', hour12: true })}"></div>`;
                    }).join('')}
                </div>
                <div class="absolute top-0 bottom-0 left-20 right-0">
                    ${timedEvents.map(note => {
                        const startMinutes = note.eventDate.getHours() * 60 + note.eventDate.getMinutes();
                        const endMinutes = note.endDate ? (note.endDate.getHours() * 60 + note.endDate.getMinutes()) : (startMinutes + 60);
                        const duration = Math.max(30, endMinutes - startMinutes);
                        const top = (startMinutes / 60) * 48;
                        const height = (duration / 60) * 48;
                        const selectProp = Object.values(note.properties || {}).find(p => p.type === 'select' && p.value);
                        const styleColor = selectProp ? getComputedStyle(document.documentElement).getPropertyValue('--' + getSelectColor(selectProp.value).split(' ')[0].replace('bg-','').replace('-500/20','-400')) : 'var(--accent-primary)';

                        const startTime = note.eventDate.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit'});
                        const endTime = note.endDate ? note.endDate.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit'}) : '';
                        const timeString = endTime ? `${startTime} - ${endTime}` : startTime;

                        return `
                            <a href="#" class="day-view-event-link absolute left-1 right-2" data-note-id="${note.id}" style="top: ${top}px; height: ${height}px;">
                                <div class="day-view-event h-full p-2 rounded flex flex-col" style="border-left-width: 3px; border-left-color: ${styleColor}; background-color: ${styleColor.replace(')',', 0.1)')};">
                                    <div class="font-semibold text-text-primary text-sm truncate leading-tight">${note.name}</div>
                                    <div class="text-xs text-text-secondary mt-1">${timeString}</div>
                                </div>
                            </a>`;
                    }).join('')}
                    ${new Date().toDateString() === date.toDateString() ? '<div id="now-indicator"></div>' : ''}
                </div>
            </div>
        </div>
    </div>`;
    calendarView.innerHTML = html;
    feather.replace();

    if (document.getElementById('now-indicator')) {
        updateNowIndicator();
        setInterval(updateNowIndicator, 60000);
        const now = new Date();
        const minutes = now.getHours() * 60 + now.getMinutes();
        const scrollPos = (minutes / 60) * 48 - 100;
        document.querySelector('.day-view-timeline-wrapper').scrollTop = Math.max(0, scrollPos);
    }
}
// END OF NEW FUNCTION
            function renderKanbanView() {
                app.views.board.classList.remove('hidden');
                const collectionId = state.settings.activeCollectionId;
                const collection = findItem(collectionId)?.item;

                if (!collection || collection.type !== 'folder') {
                    app.containers.kanbanBoard.innerHTML = `<div class="text-center p-10 text-text-secondary"><i data-feather="trello" class="w-12 h-12 mx-auto mb-4"></i><h3 class="font-semibold">Board View</h3><p>This view is only available for project folders.</p></div>`;
                    feather.replace();
                    return;
                }
                
                const columns = state.kanbanColumns[collectionId] || [];
                const notesInCollection = collection.children.filter(c => c.type === 'note') || [];
                
                const columnsHTML = columns.map(column => {
                    const notesInColumn = [...notesInCollection]
                        .filter(note => note.status === column.id)
                        .sort((a,b) => notesInCollection.indexOf(a) - notesInCollection.indexOf(b));
                        
                    const cardsHTML = notesInColumn.map(note => {
                            const date = formatDateTime(note.modifiedAt);
                            const pinnedClass = note.pinned ? 'pinned' : '';
                            return `
                                <div class="kanban-card p-3 rounded-md shadow-sm border border-border-color mb-3 cursor-pointer hover:shadow-lg transition-all ${pinnedClass}" draggable="true" data-note-id="${note.id}">
                                    <div class="pointer-events-none flex-grow overflow-hidden">
                                        <h4 class="font-semibold pointer-events-none truncate">${note.name}</h4>
                                        <p class="text-sm text-text-secondary mt-1 pointer-events-none truncate-multiline card-content">${note.excerpt || ''}</p>
                                    </div>
                                    <div class="text-xs text-text-tertiary mt-2 pointer-events-none flex-shrink-0">Modified: ${date}</div>
                                </div>
                            `;
                        }).join('');

                    return `
                        <div class="kanban-column w-[280px] md:w-[300px] flex-shrink-0 bg-bg-pane-dark p-3 rounded-lg" data-column-id="${column.id}">
                            <div class="column-header flex justify-between items-center font-semibold mb-3 text-text-primary">
                                <span class="rename-column-btn cursor-pointer flex-grow p-1">${column.title}</span>
                                <button class="delete-column-btn text-text-tertiary hover:text-red-500 opacity-0 transition-opacity p-1"><i data-feather="x" class="w-4 h-4"></i></button>
                            </div>
                            <div class="cards-container min-h-[100px]">${cardsHTML}</div>
                        </div>
                    `;
                }).join('');
                
                const addColumnBtnHTML = columns.length < 5 ? `
                     <div class="w-[280px] md:w-[300px] flex-shrink-0">
                        <button id="add-column-btn" class="w-full bg-bg-pane-light p-3 rounded-lg text-text-secondary hover:bg-main hover:text-accent-primary transition-colors">
                            <i data-feather="plus" class="inline-block mr-2"></i>Add Column
                        </button>
                    </div>` : '';

                app.containers.kanbanBoard.innerHTML = columnsHTML + addColumnBtnHTML;
            }

function renderListView() {
    app.views.list.classList.remove('hidden');
    let notes = [];
    const activeTag = state.settings.activeTag;

    if (activeTag) {
        notes = getAllNotes(state.collections).filter(note => (note.tags || []).includes(activeTag));
    } else {
        const collectionId = state.settings.activeCollectionId;
        const collection = findItem(collectionId)?.item;
        notes = collection ?
            (collection.children || []).filter(c => c.type === 'note') :
            getAllNotes(state.collections);
    }

    if (notes.length === 0) {
        app.containers.notesListContent.innerHTML = `<div class="text-center p-10 text-text-secondary col-span-full"><i data-feather="inbox" class="w-12 h-12 mx-auto mb-4"></i><h3 class="font-semibold">No Notes Here</h3><p>Create a new note to see it here.</p></div>`;
        feather.replace();
        return;
    }

    const sortOrder = state.settings.listSortOrder;
    const [key, direction] = sortOrder.split('-');

    notes.sort((a, b) => {
        let valA = a[key];
        let valB = b[key];
        if (key === 'name') {
            return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
        } else {
            return direction === 'desc' ? new Date(valB) - new Date(valA) : new Date(valA) - new Date(valB);
        }
    });

    app.containers.notesListContent.innerHTML = notes.map(note => {
        // ADD THIS LINE
const noteData = window.noteCache[note.id] || { content: '', properties: {} };
    const pinnedClass = note.pinned ? 'pinned' : '';

    let coverImageHTML = '';
    const coverProp = Object.values(noteData.properties || {}).find(p => p.type === 'image' && p.value);
    if (coverProp) {
        coverImageHTML = `<div class="h-32 bg-contain bg-no-repeat bg-center mb-4" style="background-image: url('${coverProp.value}')"></div>`;
    } else {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = noteData.content;
        const firstImage = tempDiv.querySelector('img');
        if (firstImage) {
            coverImageHTML = `<div class="h-32 bg-contain bg-no-repeat bg-center mb-4" style="background-image: url('${firstImage.src}')"></div>`;
        }
    }

    let allPropertiesHTML = '';
    const props = noteData.properties || {};
    const sortedPropNames = Object.keys(props)
        .filter(propName => props[propName].type !== 'image' && props[propName].value)
        .sort();

    if (sortedPropNames.length > 0) {
        const propsList = sortedPropNames.map(propName => {
            const prop = props[propName];
            const propNameDisplay = `<span class="text-text-tertiary">${propName}:</span>`;
            let valueDisplay = '';

            if (prop.type === 'date') {
                const formattedDate = new Date(prop.value).toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
                return `<button class="list-view-jump-to-date-btn flex items-center gap-1.5 text-xs hover:bg-bg-pane-dark rounded-md" data-note-id="${note.id}" data-date-value="${prop.value}">
                            ${propNameDisplay}
                            <span class="text-text-primary font-medium">${formattedDate}</span>
                        </button>`;
            } else if (prop.type === 'select') {
                valueDisplay = `<span class="rounded px-1.5 py-0.5 text-xs font-medium ${getSelectColor(prop.value)}">${prop.value}</span>`;
            } else {
                valueDisplay = `<span class="text-text-primary font-medium truncate max-w-[150px] inline-block align-bottom">${prop.value}</span>`;
            }

            return `<div class="flex items-center gap-1.5 text-xs">${propNameDisplay} ${valueDisplay}</div>`;
        }).join('');

        if (propsList) {
            allPropertiesHTML = `<div class="flex items-center gap-x-3 whitespace-nowrap">${propsList}</div>`;
        }
    }
    
    let allChecklistsHTML = '';
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = noteData.content;
    const allChecklists = tempDiv.querySelectorAll('.checklist-container');

    if (allChecklists.length > 0) {
        const checklistsPreviews = Array.from(allChecklists).map((checklistEl, checklistIndex) => {
            const title = checklistEl.querySelector('.checklist-title')?.textContent.trim() || 'Checklist';
            const items = Array.from(checklistEl.querySelectorAll('.checklist-item'));
            const totalItems = items.length;
            
            // --- THIS LINE IS NEW ---
            const completedItems = checklistEl.querySelectorAll('.checklist-item.checked').length;

            if (totalItems === 0) return ''; 

            const itemsHTML = items.map((item, itemIndex) => {
                const isChecked = item.classList.contains('checked');
                const text = item.querySelector('.checklist-item-text')?.textContent || '';
                return `
                    <li class="checklist-preview-item ${isChecked ? 'checked' : ''}">
                        <label class="flex items-center gap-3 cursor-pointer w-full p-1 rounded hover:bg-bg-pane-dark">
                            <input type="checkbox" 
                                   ${isChecked ? 'checked' : ''} 
                                   data-note-id="${note.id}" 
                                   data-checklist-index="${checklistIndex}" 
                                   data-item-index="${itemIndex}">
                            <span class="flex-grow">${text.replace(/</g, "&lt;")}</span>
                        </label>
                    </li>
                `;
            }).join('');

            return `
                <div class="list-view-checklist-preview">
                    <div class="checklist-preview-header">
                        <div class="flex items-center gap-2 min-w-0">
                            <i data-feather="check-square" class="w-4 h-4 text-text-tertiary flex-shrink-0"></i>
                            <span class="font-medium truncate">${title}</span>
                            
                            <span class="text-xs text-text-tertiary bg-bg-main px-1.5 py-0.5 rounded-full flex-shrink-0">${completedItems}/${totalItems} Done</span>

                        </div>
                        <i data-feather="chevron-down" class="w-4 h-4 text-text-tertiary transition-transform flex-shrink-0"></i>
                    </div>
                    <div class="checklist-preview-body" style="display: none;">
                        <ul>${itemsHTML}</ul>
                    </div>
                </div>
            `;
        }).join('');

        if (checklistsPreviews) {
            allChecklistsHTML = `<div class="space-y-2">${checklistsPreviews}</div>`;
        }
    }
    
    const excerpt = note.excerpt || 'No content preview...';
    const modifiedDate = formatDateTime(note.modifiedAt);

    return `
        <div class="list-note-item flex flex-col bg-bg-pane-light border border-border-color rounded-lg overflow-hidden transition-all hover:shadow-md ${pinnedClass}" data-note-id="${note.id}">
            <a href="#" class="note-link-area block p-4 flex-grow">
                ${coverImageHTML}
                <h4 class="font-semibold text-lg text-text-primary truncate">${note.name}</h4>
                <p class="text-sm text-text-secondary mt-2" style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;">
                    ${excerpt || 'No content preview...'}
                </p>
            </a>

            ${allPropertiesHTML ? `
            <div class="px-4 py-2 border-t border-border-color">
                <div class="overflow-x-auto no-scrollbar">
                    ${allPropertiesHTML}
                </div>
            </div>
            ` : ''}

            ${allChecklistsHTML ? `
            <div class="list-view-all-checklists-container">
                ${allChecklistsHTML}
            </div>
            ` : ''}

            <div class="px-4 pb-3 pt-2 ${allPropertiesHTML || allChecklistsHTML ? '' : 'border-t border-border-color'} flex justify-between items-center">
                <p class="text-xs text-text-tertiary whitespace-nowrap">${modifiedDate}</p>
                <div class="flex items-center">
                    <button class="summarize-btn p-1.5 rounded-full hover:bg-bg-pane-dark text-text-secondary" title="Summarize Note" data-note-id="${note.id}"><i data-feather="zap" class="w-4 h-4"></i></button>
                    <button class="quiz-btn p-1.5 rounded-full hover:bg-bg-pane-dark text-text-secondary" title="Generate Quiz" data-note-id="${note.id}"><i data-feather="help-circle" class="w-4 h-4"></i></button>
                </div>
            </div>
        </div>
    `;
}).join('');
    feather.replace();
}            
            function updateEditorStats() {
                const text = app.elements.noteEditorBody.innerText || '';
                const charCount = text.length;
                const wordCount = text.trim().split(/\s+/).filter(Boolean).length;
                app.elements.charCount.textContent = charCount;
                app.elements.wordCount.textContent = wordCount;
            }
            function createAttachmentWidgetHTML(data) {
    if (data.isImage) {
        return `<p><img src="${data.downloadURL}" alt="${data.fileName}" style="max-width: 100%; height: auto; border-radius: 8px;" contenteditable="false" /></p>`;
    } else {
        return `<div class="file-attachment-widget" contenteditable="false">
                    <i data-feather="file-text" class="w-6 h-6 text-text-secondary flex-shrink-0"></i>
                    <div class="file-info">
                        <div class="file-name">${data.fileName}</div>
                        <div class="file-size">${formatBytes(data.fileSize)}</div>
                    </div>
                    <a href="${data.downloadURL}" target="_blank" class="brand-button p-2" download title="Download ${data.fileName}"><i data-feather="download" class="w-5 h-5"></i></a>
                </div>`;
    }
}
            // =================================================================
// START: REPLACEMENT renderNoteEditor FUNCTION (FOR COLLABORATION)
// =================================================================
// notetakeapp.html

// =================================================================
// START: REPLACEMENT renderNoteEditor FUNCTION (Lazy Loading)
// =================================================================
async function renderNoteEditor() {
    app.containers.noteEditor.classList.remove('hidden');
    if (window.innerWidth < 768) {
        document.body.classList.add('mobile-editor-active');
        document.getElementById('main-header')?.classList.add('hidden');
        document.getElementById('mobile-sticky-toolbar')?.classList.remove('hidden');
    }

    const noteId = state.settings.activeNoteId;
    const noteStub = findItem(noteId)?.item;

    if (!noteStub) {
        state.settings.activeNoteId = null;
        renderMainView();
        return;
    }
    
    // This is the new "lazy loading" logic
    let noteData = window.noteCache[noteId];
    if (!noteData) {
        // If note content isn't in our cache, show a loading state...
        app.elements.noteEditorTitle.value = noteStub.name;
        app.elements.noteEditorBody.innerHTML = '<p class="text-text-tertiary">Loading content...</p>';
        
        try {
            // ...then fetch it from Firestore.
            const { doc, getDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
            const noteRef = doc(db, "notes", noteId);
            const noteSnap = await getDoc(noteRef);

            if (noteSnap.exists()) {
                noteData = noteSnap.data();
                window.noteCache[noteId] = noteData; // Add the loaded content to the cache
            } else {
                 // This handles the edge case of a new user clicking a default note for the first time
                const user = window.auth.currentUser;
                console.log(`Note ${noteId} not found in DB, creating it now.`);
                const now = new Date().toISOString();
                const defaultNoteContent = {
                    ownerId: user.uid, name: noteStub.name, content: '',
                    properties: {}, createdAt: now, modifiedAt: now,
                    tags: [], links: [], sharedWith: []
                };
                await setDoc(noteRef, defaultNoteContent);
                noteData = defaultNoteContent;
                window.noteCache[noteId] = noteData;
            }

        } catch (error) {
            console.error("Error fetching note content:", error);
            showToast("Could not load note.", "error");
            app.elements.noteEditorBody.innerHTML = '<p class="text-red-500">Error loading content.</p>';
            return;
        }
    }

    // Once the data is loaded (either from cache or Firestore), render it.
    const propertiesContainer = document.getElementById('note-properties-container');
    if (state.settings.propertiesVisible) {
        propertiesContainer.classList.remove('hidden');
        renderNoteProperties({ ...noteStub, ...noteData });
    } else {
        propertiesContainer.classList.add('hidden');
    }

    app.elements.noteEditorTitle.value = noteData.name;
    app.elements.noteEditorTitle.style.height = 'auto';
    app.elements.noteEditorTitle.style.height = (app.elements.noteEditorTitle.scrollHeight) + 'px';

    // Convert any [[Note Name]] text into clickable links
const contentWithLinks = parseInternalLinks(noteData.content || '');
app.elements.noteEditorBody.innerHTML = DOMPurify.sanitize(contentWithLinks);

    renderBacklinks(noteStub, noteData); // Helper function depends on noteData
    updateEditorStats();
    listenToActiveNote(); // Activate the real-time listener
    feather.replace();
}

// Helper for renderNoteEditor
function renderBacklinks(noteStub, noteData) {
    const backlinksPane = document.getElementById('backlinks-pane');
    const backlinksList = document.getElementById('backlinks-list');
    
    // We can't search for backlinks until more notes are cached.
    // For now, this is a simplified approach. A full backlink search would be more complex.
    backlinksPane.classList.add('hidden');
}
// =================================================================
// END: REPLACEMENT renderNoteEditor FUNCTION
// =================================================================
// =================================================================
// END: REPLACEMENT renderNoteEditor FUNCTION
// =================================================================
function renderNoteProperties(note) {
    const container = document.getElementById('note-properties-container');
    if (!container || !note) {
        if (container) container.innerHTML = '';
        return;
    }

    const isCollapsed = note.propertiesCollapsed;

    let headerHTML = `
        <div id="properties-header" class="flex items-center text-text-tertiary hover:text-text-primary cursor-pointer -mx-2 px-2 py-1 rounded-md hover:bg-bg-pane-dark">
            <i data-feather="chevron-right" class="w-4 h-4 transition-transform duration-200 ${!isCollapsed ? 'rotate-90' : ''}"></i>
            <span class="ml-1 text-xs font-semibold uppercase">Properties</span>
        </div>`;

    let propertiesHTML = '';
    if (!isCollapsed) {
        const defaultProps = {
            'Created': { type: 'date', value: note.createdAt, readonly: true },
            'Modified': { type: 'date', value: note.modifiedAt, readonly: true }
        };
        const allProps = { ...defaultProps, ...(note.properties || {}) };

        propertiesHTML = Object.entries(allProps).map(([name, prop]) => {
            let valueHTML = '';
            const isReadOnly = prop.readonly;
            const icons = { 'text': 'type', 'number': 'hash', 'date': 'clock', 'select': 'chevron-down', 'image': 'image' };

            switch (prop.type) {
                case 'date':
                    if (!prop.value) {
                        valueHTML = `<span class="prop-value" data-prop-name="${name}">Empty</span>`;
                        break;
                    }
                    const startDate = new Date(prop.value);
                    const endDate = prop.endValue ? new Date(prop.endValue) : null;
                    
                    const hasTime = startDate.getUTCHours() !== 0 || startDate.getUTCMinutes() !== 0 || (endDate && (endDate.getUTCHours() !== 0 || endDate.getUTCMinutes() !== 0));
                    
                    const dateOptions = { year: 'numeric', month: 'short', day: 'numeric' };
                    const timeOptions = { hour: 'numeric', minute: '2-digit', hour12: true };

                    let formattedString = startDate.toLocaleString(undefined, {...dateOptions, ...(hasTime && timeOptions)});

                    if (endDate) {
                        const sameDay = startDate.toDateString() === endDate.toDateString();
                        if (sameDay) {
                            formattedString += ` → ${endDate.toLocaleTimeString(undefined, timeOptions)}`;
                        } else {
                            formattedString += ` → ${endDate.toLocaleString(undefined, {...dateOptions, ...(hasTime && timeOptions)})}`;
                        }
                    }
                    valueHTML = `<span class="prop-value" data-prop-name="${name}">${formattedString}</span>`;
                    break;
                case 'text': case 'number': case 'image': valueHTML = `<span class="prop-value" data-prop-name="${name}">${prop.value || 'Empty'}</span>`; break;
                case 'select':
                    if (prop.value) { valueHTML = `<span class="prop-value rounded px-2 py-0.5 ${getSelectColor(prop.value)}" data-prop-name="${name}">${prop.value}</span>`; } 
                    else { valueHTML = `<span class="prop-value text-text-tertiary" data-prop-name="${name}">Empty</span>`; }
                    break;
                default: valueHTML = `<span class="prop-value" data-prop-name="${name}">${prop.value || 'Empty'}</span>`;
            }

            return `<div class="property-row group flex items-center py-2 hover:bg-bg-pane-dark -mx-2 px-2 rounded-md">
                        <div class="prop-name w-32 text-text-tertiary flex-shrink-0 flex items-center gap-2 cursor-pointer">
                            <i data-feather="${icons[prop.type] || 'type'}" class="w-4 h-4"></i><span>${name}</span>
                        </div>
                        <div class="prop-value-container flex-grow text-text-primary font-medium ${isReadOnly ? '' : 'cursor-pointer'}">${valueHTML}</div>
                        ${!isReadOnly ? `<button class="delete-prop-btn opacity-0 group-hover:opacity-100 p-1 rounded-full hover:bg-bg-main" data-prop-name="${name}" title="Delete Property"><i data-feather="x" class="w-4 h-4 text-text-tertiary"></i></button>` : '<div class="w-8"></div>' }
                    </div>`;
        }).join('');

        propertiesHTML += `<div class="add-property-wrapper mt-1">
                            <button id="add-property-btn" class="flex items-center gap-2 text-sm text-text-tertiary hover:text-text-primary transition-colors p-2 -mx-2 hover:bg-bg-pane-dark rounded-md w-full">
                                <i data-feather="plus" class="w-4 h-4"></i><span>Add a property</span>
                            </button>
                        </div>`;
    }

    container.innerHTML = headerHTML + propertiesHTML;
}
function renderBacklinksState() {
    const isCollapsed = state.settings.backlinksCollapsed;
    const list = document.getElementById('backlinks-list');
    const btn = document.getElementById('toggle-backlinks-btn');
    if (list && btn) {
        list.classList.toggle('collapsed', isCollapsed);
        btn.classList.toggle('collapsed', isCollapsed);
    }
}

const handleBacklinksSummary = async (currentNote, backlinkingNotes) => {
    // --- 1. Caching Logic ---
    const cacheKey = backlinkingNotes.map(n => n.id + n.modifiedAt).join('');
    if (currentNote.cachedBacklinksSummary && currentNote.cachedBacklinksSummary.key === cacheKey) {
        app.modals.summaryContent.innerHTML = currentNote.cachedBacklinksSummary.summary;
        openModal(app.modals.summary);
        document.getElementById('summary-copy-btn').classList.remove('hidden');
        feather.replace();
        showToast('Loaded summary from cache.', 'info');
        return;
    }

    // --- 2. AI Call Logic ---
    const toastId = showToast('Summarizing linked notes...', 'loading');
    const combinedContent = backlinkingNotes.map(n => `Note: ${n.name}\nContent: ${n.content.replace(/<[^>]*>?/gm, '')}`).join('\n\n---\n\n');
    const prompt = `Based on the following notes that all link to "${currentNote.name}", provide a concise summary of their collective content. Synthesize the information into a cohesive overview.

Combined Content:
---
${combinedContent}`;

    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    const summaryText = await callGeminiAPI(payload);
    dismissToast(toastId);

    if (summaryText) {
        const summaryHtml = marked.parse(summaryText).trim();
        app.modals.summaryContent.innerHTML = summaryHtml;
        openModal(app.modals.summary);
        feather.replace();

        // --- 3. Save to Cache ---
        currentNote.cachedBacklinksSummary = {
            key: cacheKey,
            summary: summaryHtml
        };
        saveState();
    } else {
        showToast('Could not generate summary.', 'error');
    }
};
            
            function renderSearchResults(query) {
    app.views.searchResults.classList.remove('hidden');

    if (!query) {
        app.containers.searchResultsList.innerHTML = `<p class="text-text-secondary text-center"><i data-feather="search" class="w-12 h-12 mx-auto mb-4"></i><br>Start typing to search for notes.</p>`;
        feather.replace();
        return;
    }

    const results = lunrIndex.search(query);

    // --- FIX STARTS HERE ---
    // The original code used findItem(), which only returns a data stub without the note's content.
    // This new code correctly uses the note ID from the search result (res.ref) 
    // to get the FULL note data from the global note cache.
    const resultNotes = results.map(res => {
        const fullNoteData = window.noteCache[res.ref];
        // Combine the ID with the rest of the note data to create a complete object.
        return fullNoteData ? { id: res.ref, ...fullNoteData } : null;
    }).filter(Boolean); // Filter out any null results if a note wasn't in the cache.
    // --- FIX ENDS HERE ---

    if (resultNotes.length === 0) {
        app.containers.searchResultsList.innerHTML = `<p class="text-text-secondary text-center"><i data-feather="x-circle" class="w-12 h-12 mx-auto mb-4"></i><br>No results found for "${query}".</p>`;
        feather.replace();
        return;
    }

    const highlightText = (text, query) => {
        if (!query || !text) return text;
        const escapedQuery = query.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        const regex = new RegExp(`(${escapedQuery})`, 'gi');
        return text.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(regex, `<mark>$1</mark>`);
    };

    app.containers.searchResultsList.innerHTML = resultNotes.map(note => {
        const parentResult = findItem(note.id);
        const parent = parentResult ? parentResult.parent : null;
        const parentName = parent && !Array.isArray(parent) ? parent.name : null;
        // This line now works correctly because 'note.content' is available.
        const plainContent = note.content.replace(/<[^>]*>?/gm, ''); 
        const excerpt = highlightText(plainContent, query);

        return `
            <div class="search-result-item p-4 mb-3 rounded-lg hover:shadow-md border border-border-color bg-bg-pane-light transition-shadow cursor-pointer" data-note-id="${note.id}">
                <div class="flex justify-between items-start">
                    <div class="flex-grow min-w-0">
                        <div class="font-semibold text-text-secondary text-sm">
                            ${parentName ? `${highlightText(parentName, query)} / ` : ''}<span class="text-text-primary">${highlightText(note.name, query)}</span>
                        </div>
                        <p class="text-text-secondary mt-2 truncate-multiline card-content" style="-webkit-line-clamp: 2;">${excerpt}</p>
                    </div>
                    <div class="flex items-center flex-shrink-0 ml-4">
                        <button class="summarize-btn p-2 rounded-full hover:bg-bg-pane-dark text-text-secondary" title="Summarize Note with AI" data-note-id="${note.id}">
                            <i data-feather="zap" class="w-4 h-4"></i>
                        </button>
                        <button class="quiz-btn p-2 rounded-full hover:bg-bg-pane-dark text-text-secondary" title="Generate Quiz with AI" data-note-id="${note.id}">
                            <i data-feather="help-circle" class="w-4 h-4"></i>
                        </button>
                    </div>
                </div>
            </div>
        `;
    }).join('');

    feather.replace();
}
            
            function renderChatHistory() {
                app.modals.chatbotHistory.innerHTML = state.chatHistory.map(msg => {
                    const bubbleClass = msg.role === 'user'
                        ? 'user'
                        : 'model';
                    const formattedHtml = marked.parse(msg.text);
                    return `
                        <div class="chat-bubble w-fit rounded-lg px-3 py-2 self-${msg.role === 'user' ? 'end' : 'start'} ${bubbleClass}">
                            ${formattedHtml}
                        </div>`;
                }).join('');
                app.modals.chatbotHistory.scrollTop = app.modals.chatbotHistory.scrollHeight;
            }
            // ADD THIS NEW HELPER FUNCTION
// REPLACE THE OLD 'upgradePastedTables' FUNCTION
// REPLACE 'upgradePastedTables' FUNCTION
const upgradePastedTables = (html) => {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    const tables = tempDiv.querySelectorAll('table');
    if (tables.length === 0) return html;

    tables.forEach(table => {
        table.querySelectorAll('th, td').forEach(cell => cell.setAttribute('contenteditable', 'true'));
        const headers = table.querySelectorAll('th');
        const headerRow = table.querySelector('thead tr');
        const colCount = headerRow ? headerRow.children.length : 1;

        headers.forEach(th => {
            th.classList.add('sortable-header');
            th.dataset.sortDir = 'none';
        });

        const thead = table.querySelector('thead');
        if (thead) {
            const filterRow = document.createElement('tr');
            // This is the updated filter row HTML with the toggle button
            filterRow.innerHTML = `<th colspan="${colCount}" contenteditable="false"><div class="table-header-controls"><div class="table-filter-wrapper"><i data-feather="search" class="filter-icon"></i><input class="table-filter-input" placeholder="Filter table..."/></div><button class="toggle-filter-btn" title="Toggle Filter"><i data-feather="chevrons-up" class="w-4 h-4"></i></button></div></th>`;
            thead.prepend(filterRow);
        }
    });
    return tempDiv.innerHTML;
};            
            // =================================================================
// START: REPLACEMENT JAVASCRIPT BLOCK
// =================================================================

/**
 * MODIFIED: Upgraded to accept a specific parentId for the new note.
 */
// =================================================================
// START: REPLACEMENT createNewNote FUNCTION
// =================================================================
// =================================================================
// START: REPLACEMENT createNewNote FUNCTION (FOR COLLABORATION)
// =================================================================
const createNewNote = async (andSwitchToIt = true, template = {}, parentId = undefined) => {
    const user = window.auth.currentUser;
    if (!user) return null;

    const { doc, collection, writeBatch, serverTimestamp } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");

    let finalParentId = parentId;
    if (finalParentId === undefined) {
        finalParentId = state.settings.activeCollectionId;
    }

    // --- START: NEW EXCERPT LOGIC ---
    const initialContent = template.content || '';
    const plainText = initialContent.replace(/<[^>]*>?/gm, ' ').trim();
    const initialExcerpt = plainText.substring(0, 200);
    // --- END: NEW EXCERPT LOGIC ---

    const now = new Date().toISOString();
    const newNoteData = {
        ownerId: user.uid,
        name: template.name || 'Untitled Note',
        content: initialContent,
        excerpt: initialExcerpt, // ADD THIS
        properties: template.properties ? JSON.parse(JSON.stringify(template.properties)) : {},
        createdAt: now,
        modifiedAt: now,
        tags: [],
        sharedWith: []
    };

    const newNoteRef = doc(collection(db, "notes"));
    const noteId = newNoteRef.id;

    const parentResult = findItem(finalParentId);
    let targetArray = state.collections;
    if (parentResult && parentResult.item.type === 'folder') {
        if (!parentResult.item.children) parentResult.item.children = [];
        targetArray = parentResult.item.children;
        parentResult.item.expanded = true;
    } else {
        finalParentId = null;
    }

    const newNoteStub = {
        id: noteId,
        type: 'note',
        name: newNoteData.name,
        excerpt: initialExcerpt, // ADD THIS
        pinned: false
    };
    targetArray.unshift(newNoteStub);

    const batch = writeBatch(db);
    batch.set(newNoteRef, newNoteData);
    window.noteCache[noteId] = newNoteData;

    const userDocRef = doc(db, "users", user.uid, "data", "appState");
    batch.update(userDocRef, { collections: state.collections });

    await batch.commit();

    if (andSwitchToIt) {
        state.settings.activeNoteId = noteId;
        state.settings.activeCollectionId = finalParentId;
        state.settings.activeTag = null;
        state.settings.editorMode = 'editor';
        await saveState();
    }

    buildLunrIndex();
    render();

    if (andSwitchToIt) {
        app.elements.noteEditorTitle.focus();
        app.elements.noteEditorTitle.select();
    }

    return { ...newNoteStub, ...newNoteData };
};
// =================================================================
// END: REPLACEMENT createNewNote FUNCTION
// =================================================================

/**
 * MODIFIED: Now generates a '+' button for each item.
 */
const renderNotionStyleMenu = () => {
    const user = window.auth.currentUser;
    if (user && user.email) {
        document.getElementById('menu-user-initial').textContent = user.email.charAt(0).toUpperCase();
        document.getElementById('menu-user-email').textContent = user.email;
        document.getElementById('dropdown-user-email-display').textContent = user.email;
    }
    const allNotes = getAllNotes(state.collections);
    const recentNotes = [...allNotes]
        .sort((a, b) => new Date(b.modifiedAt) - new Date(a.modifiedAt))
        .slice(0, 5);
    let jumpBackHTML = '';
    if (recentNotes.length > 0) {
        jumpBackHTML = `
            <h3 class="notion-menu-section-header">Jump back in</h3>
            <div class="jump-back-in-grid">
                ${recentNotes.map(note => `
                    <a href="#" class="recent-note-card" data-id="${note.id}" data-action="navigate-note">
                        <i data-feather="file-text" class="w-5 h-5"></i>
                        <span class="note-name">${note.name}</span>
                    </a>
                `).join('')}
            </div>`;
    }

    const buildPrivateList = (collections = state.collections, level = 0, parentId = null) => {
        return collections.map(item => {
            const isFolder = item.type === 'folder';
            // --- MODIFIED: Added 'group' class and the new '+' button ---
            let itemHTML = `
                <li data-id="${item.id}" class="collection-item-wrapper group rounded-md">
                    <div class="collection-item flex items-center gap-2 p-2 rounded-md" style="padding-left: ${8 + level * 16}px;">
                        ${isFolder ? `<a href="#" class="expander-btn -ml-1 p-1" data-action="toggle-expand"><i data-feather="chevron-right" class="chevron w-4 h-4 flex-shrink-0 text-text-tertiary ${item.expanded ? 'open' : ''}"></i></a>` : '<div class="w-6 h-6 flex-shrink-0"></div>'}
                        <a href="#" class="flex items-center gap-2 flex-grow min-w-0" data-action="${isFolder ? 'navigate-folder' : 'navigate-note'}">
                            <i data-feather="${isFolder ? 'folder' : 'file-text'}" class="w-4 h-4 flex-shrink-0 text-text-secondary"></i>
                            <span class="truncate">${item.name}</span>
                        </a>
                        <button class="add-note-btn" data-action="add-note-here" data-parent-id="${isFolder ? item.id : parentId}" title="Add New Note Here">
                            <i data-feather="plus" class="w-4 h-4"></i>
                        </button>
                    </div>`;
            if (isFolder && item.expanded && item.children && item.children.length > 0) {
                itemHTML += `<ul class="collection-children">${buildPrivateList(item.children, level + 1, item.id)}</ul>`;
            } else if (isFolder && item.expanded) {
                itemHTML += `<p class="pl-12 py-1 text-sm text-text-tertiary">No notes inside</p>`;
            }
            itemHTML += `</li>`;
            return itemHTML;
        }).join('');
    };

    document.getElementById('jump-back-in-section').innerHTML = jumpBackHTML;
    document.getElementById('private-section').innerHTML = `
        <h3 class="notion-menu-section-header">All Notes</h3>
        <ul class="space-y-1">${buildPrivateList()}</ul>
    `;
    feather.replace();
};

/**
 * MODIFIED: Added a new case for 'add-note-here'.
 */
// =================================================================
// START: REPLACEMENT CLICK LISTENER
// =================================================================
// REPLACE your current notionMenu 'click' listener with this one
// REPLACE your current notionMenu 'click' listener with this one
// REPLACE your current notionMenu 'click' listener with this one

// =================================================================
// END: REPLACEMENT CLICK LISTENER
// =================================================================
// =================================================================
// END: REPLACEMENT JAVASCRIPT BLOCK
// =================================================================

            function initSpeechRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    showToast('Speech recognition is not supported in this browser.', 'error');
                    return;
                }
                
                speechRecognizer = new SpeechRecognition();
                speechRecognizer.continuous = true;
                speechRecognizer.interimResults = false;

                speechRecognizer.onresult = (event) => {
                    const last = event.results.length - 1;
                    const text = event.results[last][0].transcript;
                    
                    app.elements.noteEditorBody.focus();
                    document.execCommand('insertText', false, text.trim() + ' ');
                    saveNoteContent();
                };

                speechRecognizer.onend = () => {
                    if (isDictating) {
                        speechRecognizer.start(); // Keep listening if it stops unexpectedly
                    }
                };
                 speechRecognizer.onerror = (event) => {
                    console.error('Speech recognition error', event.error);
                    showToast(`Speech recognition error: ${event.error}`, 'error');
                    isDictating = false;
                    app.toolbar.dictateBtn.classList.remove('recording');
                };
            }

            function initClipper() {
                if (!window.location.hash.startsWith('#clip=')) return;

                try {
                    const encodedData = window.location.hash.substring(6);
                    const data = JSON.parse(decodeURIComponent(encodedData));
                    
                    let clippedContent = `<h1>${data.title}</h1>\n<p><em>Source: <a href="${data.url}" target="_blank">${data.url}</a></em></p>\n<hr>\n<blockquote>${data.clip.replace(/\n/g, '<br>')}</blockquote>`;

                    const newNote = createNewNote(true, clippedContent);
                    showToast(`Clipped content saved to "${newNote.name}"`, 'success');

                } catch (e) {
                    console.error('Error parsing clipped data:', e);
                    showToast('Could not import clipped content.', 'error');
                } finally {
                    // Clear the hash
                    history.pushState("", document.title, window.location.pathname + window.location.search);
                }
            }
            
            function buildLunrIndex() {
    // Get all note stubs, which now contain the excerpt
    const allNoteStubs = getAllNotes(state.collections);

    lunrIndex = lunr(function () {
        this.ref('id');
        this.field('name', { boost: 10 }); // Boost titles in search results
        this.field('excerpt'); // Index the new excerpt field
        this.field('tags');

        // This now iterates through the stubs directly, without needing the full content
        allNoteStubs.forEach(noteStub => {
            this.add({
                id: noteStub.id,
                name: noteStub.name,
                excerpt: noteStub.excerpt || '', // Use the saved excerpt
                tags: (noteStub.tags || []).join(' ')
            });
        });
    });
}
function setupSharedNoteListener() {
    const user = window.auth.currentUser;
    if (!user) return;

    import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js")
        .then(({ collection, query, where, onSnapshot }) => {
            
            const sharedNotesQuery = query(
                collection(db, "notes"),
                where('sharedWith', 'array-contains', user.uid)
            );

            onSnapshot(sharedNotesQuery, (snapshot) => {
                let stateChanged = false;
                snapshot.docChanges().forEach((change) => {
                    const noteData = change.doc.data();
                    const noteId = change.doc.id;

                    if (change.type === "added") {
                        // --- FIX IS HERE ---
                        // Check if the note doesn't already exist in the sidebar state
                        if (!findItem(noteId)) { 
                            console.log('New shared note detected:', noteData.name);
                            window.noteCache[noteId] = noteData;
                            const noteStub = { 
                                id: noteId, 
                                name: noteData.name, 
                                type: 'note', 
                                createdAt: noteData.createdAt, 
                                modifiedAt: noteData.modifiedAt, 
                                pinned: false 
                            };
                            // Add the shared note to the root of the collections list
                            state.collections.unshift(noteStub);

                            showToast(`📬 Note shared with you: "${noteData.name}"`, 'success');
                            stateChanged = true;
                        }
                    } 
                    else if (change.type === "removed") {
                        console.log('Shared note access revoked:', noteData.name);
                        
                        delete window.noteCache[noteId];
                        const findResult = findItem(noteId);
                        
                        if (findResult) {
                            const parentArray = Array.isArray(findResult.parent) ? findResult.parent : findResult.parent.children;
                            parentArray.splice(findResult.index, 1);
                        }

                        if (state.settings.activeNoteId === noteId) {
                            state.settings.activeNoteId = null;
                        }
                        
                        showToast(`🚫 Access to "${noteData.name}" was revoked.`, 'info');
                        stateChanged = true;
                    }
                });

                if (stateChanged) {
                    saveState();
                    buildLunrIndex();
                    render();
                }
            }, (error) => {
                console.error("Error listening for shared notes:", error);
            });
        });
}
            /**
 * Renders the generated quiz data into the quiz modal.
 * @param {Array<Object>} quizArray - An array of quiz question objects.
 */
function renderQuizModal(quizArray) {
    let quizHTML = '<div class="space-y-6">';
    quizArray.forEach((q, index) => {
        const isMultiSelect = q.type === 'msq';
        // The correct answer is now stringified to be stored in the data attribute
        const correctAnswer = JSON.stringify(q.answer); 

        quizHTML += `
            <div class="quiz-question-container border-b border-border-color pb-4" data-correct-answer='${correctAnswer}' data-question-type="${q.type || 'mcq'}">
                <p class="font-semibold text-text-primary">${index + 1}. ${q.question} ${isMultiSelect ? '<span class="text-xs font-normal text-text-tertiary">(Select all that apply)</span>' : ''}</p>
                <div class="mt-3 space-y-2">
                    ${Object.entries(q.options).map(([key, value]) => `
                        <label class="block flex items-start p-2 rounded-md border border-border-color cursor-pointer hover:bg-bg-pane-dark transition-colors duration-200">
                            <input type="${isMultiSelect ? 'checkbox' : 'radio'}" name="question-${index}" value="${key}" class="mr-3 mt-1 shrink-0">
                            <span>${key}: ${value}</span>
                        </label>
                    `).join('')}
                </div>
                ${isMultiSelect ? `<button class="submit-msq-btn mt-3 px-3 py-1 text-sm brand-button rounded-md">Submit Answer</button>` : ''}
                <p class="quiz-feedback text-sm mt-2 h-5 font-medium"></p>
            </div>
        `;
    });
    quizHTML += '</div>';

    app.modals.quizContent.innerHTML = quizHTML;
    openModal(app.modals.quiz);
}

/**
 * Handles the AI call to generate an MCQ quiz from note content.
 * @param {string} noteContent - The plain text content of the note.
 */
const handleGenerateQuiz = async (noteContent, note) => {
    // Check for a valid cached quiz first.
    if (note.cachedQuiz && note.cachedQuiz.sourceModifiedAt === note.modifiedAt) {
        showToast('Loading Quiz!', 'info');
        renderQuizModal(note.cachedQuiz.data);
        return;
    }

    // NEW: Determine quiz length based on content
    const contentLength = noteContent.length;
    let numQuestions = 3;
    if (contentLength > 1000) numQuestions = 5;
    if (contentLength > 2500) numQuestions = 7;

    const toastId = showToast(`Generating quiz...`, 'loading');
    
    // NEW: Enhanced prompt for smarter, varied, and multi-select questions
    const prompt = `Based on the following text, generate a multiple-choice quiz with exactly ${numQuestions} questions.

Instructions for the AI:
1.  Create a mix of question types: some for simple fact recall, and others that test understanding of concepts, consequences, or relationships between ideas in the text.
2.  For some questions, allow for multiple correct answers (multi-select).
3.  Return the result as a single, valid JSON object with a key "quiz" which is an array of objects.
4.  Each question object MUST have four keys:
    - "question" (string): The question text.
    - "options" (object): An object with A, B, C, D keys for the options.
    - "answer" (string OR array of strings): For single-answer questions, this is a string (e.g., "A"). For multi-select questions, this is an array of strings (e.g., ["B", "D"]).
    - "type" (string): Use "mcq" for single-answer questions and "msq" for multi-select questions.
5.  Do not include any text, notes, or markdown formatting like \`\`\`json before or after the JSON object itself.

Text:
---
${noteContent}`;

    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    const jsonResponse = await callGeminiAPI(payload);
    dismissToast(toastId);

    if (jsonResponse) {
        try {
            const cleanedJsonResponse = jsonResponse.replace(/^```json\n?/, '').replace(/\n?```$/, '');
            const quizData = JSON.parse(cleanedJsonResponse);

            if (quizData.quiz && Array.isArray(quizData.quiz)) {
                 renderQuizModal(quizData.quiz);
                 note.cachedQuiz = {
                     sourceModifiedAt: note.modifiedAt,
                     data: quizData.quiz
                 };
                 saveState();
            } else {
                throw new Error("Invalid quiz data structure.");
            }
        } catch (err) {
            console.error("Failed to parse quiz JSON:", err, "Raw Response:", jsonResponse);
            showToast('Failed to generate a valid quiz.', 'error');
        }
    }
};

            async function init() {
                const updateSaveIndicator = () => {
    const indicator = document.getElementById('save-indicator');
    if (indicator) {
        indicator.classList.toggle('visible', isNoteDirty);
    }
};
                // --- START: Ctrl+S Manual Save Logic ---
// REPLACE WITH THIS BLOCK
// --- START: Throttled Ctrl+S Manual Save Logic ---
// REPLACE WITH THIS *IMPROVED* BLOCK
// --- START: Throttled Ctrl+S Manual Save Logic (1-Second Cooldown) ---
let isSavingManual = false; // Add a flag to prevent spamming
document.addEventListener('keydown', (e) => {
    // Check for Ctrl+S or Cmd+S
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault(); 
        if (state.settings.activeNoteId && !isSavingManual) {
            isSavingManual = true; // Set the flag to true
            performImmediateSave(); 
            showToast('✅ Saved', 'success');
            
            // Set a 1-second cooldown. Solves the fast-edit scenario.
            setTimeout(() => {
                isSavingManual = false; 
            }, 1000); 
        }
    }
});
// --- END: Throttled Ctrl+S Manual Save Logic (1-Second Cooldown) ---
// --- END: Throttled Ctrl+S Manual Save Logic ---
// --- END: Ctrl+S Manual Save Logic ---
                // --- START: Sharing Modal Navigation Logic ---
document.getElementById('sharing-management-modal').addEventListener('click', (e) => {
    const link = e.target.closest('.sharing-modal-note-link');
    if (link) {
        e.preventDefault();
        const noteId = link.dataset.noteId;
        if (noteId) {
            // Logic to switch to the note
            state.settings.activeNoteId = noteId;
            const { parent } = findItem(noteId);
            state.settings.activeCollectionId = (Array.isArray(parent)) ? null : parent.id;
            state.settings.activeTag = null;
            saveState();
            render();
            // Close the modal after navigating
            closeModal(document.getElementById('sharing-management-modal'));
        }
    }
});
// --- END: Sharing Modal Navigation Logic ---
                // --- START: SHARING MANAGEMENT LOGIC ---

const openSharingModal = async () => {
    const user = window.auth.currentUser;
    if (!user) return;

    const modal = document.getElementById('sharing-management-modal');
    const byMeList = document.getElementById('shared-by-me-list');
    const withMeList = document.getElementById('shared-with-me-list');
    
    byMeList.innerHTML = '<p class="text-sm text-text-tertiary p-2">Loading...</p>';
    withMeList.innerHTML = '<p class="text-sm text-text-tertiary p-2">Loading...</p>';
    openModal(modal);
    feather.replace();

    // MODIFIED: Find the note ID to prevent it from being null
    const allNotesData = Object.entries(window.noteCache).map(([id, data]) => ({ id, ...data }));
    const ownedAndSharedNotes = allNotesData.filter(note => note.ownerId === user.uid && note.sharedWith?.length > 0);
    const sharedWithUserNotes = allNotesData.filter(note => note.sharedWith?.includes(user.uid));

    // Render notes shared BY the user
    if (ownedAndSharedNotes.length === 0) {
        byMeList.innerHTML = '<p class="text-sm text-text-tertiary p-2">You are not sharing any notes.</p>';
    } else {
        const allCollaboratorUIDs = [...new Set(ownedAndSharedNotes.flatMap(note => note.sharedWith))];
        const { httpsCallable } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-functions.js");
        const getUserProfiles = httpsCallable(window.functions, 'getUserProfiles');
        const profilesResult = await getUserProfiles({ uids: allCollaboratorUIDs });
        const emailMap = new Map(profilesResult.data.users.map(u => [u.uid, u.email]));

        byMeList.innerHTML = ownedAndSharedNotes.map(note => {
            // MODIFIED: This whole block is new for better layout and clickability
            const collaboratorsHTML = note.sharedWith.map(uid => `
                <div class="text-xs text-text-secondary">${emailMap.get(uid) || 'Unknown User'}</div>
            `).join('');
            return `
                <a href="#" class="sharing-modal-note-link block p-3 bg-bg-pane-dark rounded-md hover:bg-bg-pane-light" data-note-id="${note.id}">
                    <div class="flex justify-between items-center">
                        <span class="font-semibold text-text-primary truncate">${note.name}</span>
                        <div class="flex flex-col items-end">
                            ${collaboratorsHTML}
                        </div>
                    </div>
                </a>`;
        }).join('');
    }

    // Render notes shared WITH the user
    if (sharedWithUserNotes.length === 0) {
        withMeList.innerHTML = '<p class="text-sm text-text-tertiary p-2">No notes have been shared with you.</p>';
    } else {
        const ownerUIDs = [...new Set(sharedWithUserNotes.map(note => note.ownerId))];
        if (ownerUIDs.length > 0) {
            const { httpsCallable } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-functions.js");
            const getUserProfiles = httpsCallable(window.functions, 'getUserProfiles');
            const profilesResult = await getUserProfiles({ uids: ownerUIDs });
            const ownerEmailMap = new Map(profilesResult.data.users.map(u => [u.uid, u.email]));

            // MODIFIED: This block is new for better layout and clickability
            withMeList.innerHTML = sharedWithUserNotes.map(note => `
                <a href="#" class="sharing-modal-note-link block p-3 bg-bg-pane-dark rounded-md hover:bg-bg-pane-light" data-note-id="${note.id}">
                    <div class="flex justify-between items-center">
                        <span class="font-semibold text-text-primary truncate">${note.name}</span>
                        <span class="text-xs text-text-secondary whitespace-nowrap">by ${ownerEmailMap.get(note.ownerId) || '...'}</span>
                    </div>
                </a>`
            ).join('');
        }
    }
};

document.getElementById('manage-sharing-btn').addEventListener('click', openSharingModal);
document.getElementById('sharing-modal-close-btn').addEventListener('click', () => closeModal(document.getElementById('sharing-management-modal')));
document.getElementById('sharing-modal-done-btn').addEventListener('click', () => closeModal(document.getElementById('sharing-management-modal')));



// --- END: SHARING MANAGEMENT LOGIC ---
                // --- START: NEW INVITATION LOGIC ---

const setupInvitationListener = () => {
    const user = window.auth.currentUser;
    if (!user) return;

    import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js").then(({ collection, query, where, onSnapshot }) => {
        const invitationsQuery = query(
            collection(db, "invitations"),
            where('inviteeEmail', '==', user.email),
            where('status', '==', 'pending')
        );

        onSnapshot(invitationsQuery, (snapshot) => {
            snapshot.docChanges().forEach((change) => {
                if (change.type === "added") {
                    showInvitationToast({ id: change.doc.id, ...change.doc.data() });
                }
                if (change.type === "removed") {
                    document.getElementById(`invite-${change.doc.id}`)?.remove();
                }
            });
        });
    });
};

const showInvitationToast = (invitation) => {
    const container = document.getElementById('invitation-toast-container');
    const toast = document.createElement('div');
    toast.id = `invite-${invitation.id}`;
    toast.className = 'bg-bg-pane-dark w-80 rounded-lg shadow-2xl p-4 border border-border-color';
    toast.innerHTML = `
        <div class="flex items-start gap-3">
            <div class="bg-gradient-to-r from-[var(--brand-grad-from)] to-[var(--brand-grad-to)] w-8 h-8 rounded-full flex items-center justify-center text-white font-bold text-sm shrink-0">
                ${invitation.inviterEmail.charAt(0).toUpperCase()}
            </div>
            <div class="flex-grow">
                <p class="text-sm font-semibold text-text-primary">${invitation.inviterEmail}</p>
                <p class="text-sm text-text-secondary">wants to collaborate with you on <strong>${invitation.noteName}</strong></p>
            </div>
        </div>
        <div class="flex justify-end gap-2 mt-3">
            <button data-invite-id="${invitation.id}" data-action="decline" class="px-3 py-1 text-sm rounded-md bg-bg-pane-light hover:opacity-80">Decline</button>
            <button data-invite-id="${invitation.id}" data-action="accept" class="px-3 py-1 text-sm rounded-md brand-button hover:opacity-90">Accept</button>
        </div>
    `;
    container.appendChild(toast);
};

document.getElementById('invitation-toast-container').addEventListener('click', async (e) => {
    const button = e.target.closest('button[data-invite-id]');
    if (!button) return;

    const { inviteId, action } = button.dataset;
    const toastElement = document.getElementById(`invite-${inviteId}`);

    try {
        const { httpsCallable } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-functions.js");

        if (action === 'accept') {
            const acceptInvite = httpsCallable(functions, 'acceptInvitation');
            const result = await acceptInvite({ invitationId: inviteId });
            showToast(`🎉 You can now collaborate on "${result.data.noteName}"!`, 'success');
        } else {
            const declineInvite = httpsCallable(functions, 'declineInvitation');
            await declineInvite({ invitationId: inviteId });
            showToast('Invitation declined.', 'info');
        }

        toastElement?.remove();

    } catch (error) {
        console.error(`Failed to ${action} invitation:`, error);
        showToast(`Error: ${error.message}`, 'error');
    }
});

// --- END: NEW INVITATION LOGIC ---
                // --- START: Timer/Stopwatch Logic ---
// --- START: Timer/Stopwatch Logic ---
const initTimer = () => {
    const modal = document.getElementById('timer-modal');
    const header = document.getElementById('timer-header');
    const closeBtn = document.getElementById('timer-close-btn');
    const display = document.getElementById('timer-display');
    const startStopBtn = document.getElementById('timer-start-stop-btn');
    const resetBtn = document.getElementById('timer-reset-btn');
    const lapBtn = document.getElementById('timer-lap-btn');
    const lapsContainer = document.getElementById('timer-laps-container');
    const setBtn = document.getElementById('timer-set-btn');
    const input = document.getElementById('timer-input');
    const inputContainer = document.getElementById('timer-input-container');

    let timerInterval = null;
    let mode = 'stopwatch';
    let startTime = 0;
    let elapsedTime = 0;
    let laps = [];
    let countdownFrom = 0;
    let isRunning = false;

    const saveTimerState = () => {
        const stateToSave = {
            mode,
            startTime,
            elapsedTime,
            laps,
            countdownFrom,
            isRunning
        };
        localStorage.setItem('reputiflyTimerState', JSON.stringify(stateToSave));
    };

    const formatTime = (ms) => {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
        const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
        const seconds = String(totalSeconds % 60).padStart(2, '0');
        return `${hours}:${minutes}:${seconds}`;
    };

    const updateDisplay = () => {
        let currentTotalElapsed = isRunning ? elapsedTime + (Date.now() - startTime) : elapsedTime;

        if (mode === 'stopwatch') {
            display.textContent = formatTime(currentTotalElapsed);
        } else { // Timer mode
            const remainingTime = countdownFrom - currentTotalElapsed;
            if (remainingTime <= 0 && isRunning) {
                stopTimer(); // This will update elapsedTime
                display.textContent = "00:00:00";
                showToast("⏰ Timer Finished!", "success");
                new Audio('https://interactive-examples.mdn.mozilla.net/media/cc0-audio/t-rex-roar.mp3').play();
                resetTimer(); // Reset to initial state after finishing
                return;
            }
            display.textContent = formatTime(Math.max(0, remainingTime));
        }
    };

    const startTimer = () => {
        if (isRunning) return;
        isRunning = true;
        startTime = Date.now();
        timerInterval = setInterval(updateDisplay, 50); // Update more frequently for accuracy
        startStopBtn.textContent = 'Stop';
        lapBtn.disabled = (mode === 'timer');
        inputContainer.classList.add('hidden');
        saveTimerState();
    };

    const stopTimer = () => {
        if (!isRunning) return;
        clearInterval(timerInterval);
        timerInterval = null;
        elapsedTime += Date.now() - startTime;
        isRunning = false;
        startStopBtn.textContent = 'Start';
        lapBtn.disabled = true;
        saveTimerState();
    };

    const resetTimer = () => {
        stopTimer();
        elapsedTime = 0;
        laps = [];
        mode = 'stopwatch';
        countdownFrom = 0;
        isRunning = false; // Ensure isRunning is false
        display.textContent = "00:00:00";
        lapsContainer.innerHTML = '';
        inputContainer.classList.remove('hidden');
        input.value = '';
        saveTimerState();
    };

    const addLap = () => {
        if (!isRunning || mode !== 'stopwatch') return;
        const lapTime = elapsedTime + (Date.now() - startTime);
        laps.push(lapTime);
        renderLaps();
        saveTimerState();
    };
    
    const renderLaps = () => {
        lapsContainer.innerHTML = '';
        [...laps].reverse().forEach((lapTime, index) => {
            const lapNumber = laps.length - index;
            const prevLapTime = lapNumber > 1 ? laps[lapNumber - 2] : 0;
            const lapDuration = lapTime - prevLapTime;
            const lapEl = document.createElement('div');
            lapEl.className = 'flex justify-between p-1 border-b border-border-color';
            lapEl.innerHTML = `<span>Lap ${lapNumber}</span><span>${formatTime(lapDuration)}</span>`;
            lapsContainer.appendChild(lapEl);
        });
    };

    const setTimer = () => {
        const durationInMinutes = parseDurationToMinutes(input.value);
        if (durationInMinutes > 0) {
            resetTimer();
            mode = 'timer';
            countdownFrom = durationInMinutes * 60 * 1000;
            display.textContent = formatTime(countdownFrom);
            saveTimerState();
            startTimer();
        } else {
            showToast("Invalid time format. Use '15m', '1.5h', etc.", "error");
        }
    };
    
    const loadTimerState = () => {
        const savedStateJSON = localStorage.getItem('reputiflyTimerState');
        if (!savedStateJSON) return;

        const savedState = JSON.parse(savedStateJSON);
        mode = savedState.mode;
        elapsedTime = savedState.elapsedTime;
        laps = savedState.laps || [];
        countdownFrom = savedState.countdownFrom;
        
        if (savedState.isRunning) {
            // Recalculate elapsed time based on how long it's been since the page was closed
            elapsedTime += Date.now() - savedState.startTime;
            startTimer();
        }
        
        updateDisplay();
        renderLaps();
    };

    startStopBtn.addEventListener('click', () => { isRunning ? stopTimer() : startTimer(); });
    resetBtn.addEventListener('click', resetTimer);
    lapBtn.addEventListener('click', addLap);
    setBtn.addEventListener('click', setTimer);
    input.addEventListener('keydown', (e) => { if (e.key === 'Enter') setTimer(); });
    closeBtn.addEventListener('click', () => closeModal(modal));

    let isDragging = false, offsetX, offsetY;
    header.addEventListener('mousedown', (e) => {
        isDragging = true;
        offsetX = e.clientX - modal.offsetLeft;
        offsetY = e.clientY - modal.offsetTop;
        modal.style.transition = 'none';
    });
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        let newX = e.clientX - offsetX, newY = e.clientY - offsetY;
        const buffer = 10;
        newX = Math.max(buffer, Math.min(newX, window.innerWidth - modal.offsetWidth - buffer));
        newY = Math.max(buffer, Math.min(newY, window.innerHeight - modal.offsetHeight - buffer));
        modal.style.left = `${newX}px`;
        modal.style.top = `${newY}px`;
    });
    document.addEventListener('mouseup', () => {
        isDragging = false;
        modal.style.transition = 'all 0.3s';
    });

    loadTimerState();
};

// --- END: Timer/Stopwatch Logic ---
// --- END: Timer/Stopwatch Logic ---
                // Paste this code block AFTER the mainContentArea click listener
// This listener handles clicking on headers to expand/collapse them
// This listener handles clicking on headers to expand/collapse them
app.containers.notesListContent.addEventListener('click', (e) => {
    // First, check if a checklist item's label was clicked
    const itemLabel = e.target.closest('.checklist-preview-item label');
    if (itemLabel) {
        // This is the key fix: stop the click from bubbling up to the main note link.
        // We do NOT prevent the default action, as that would stop the checkbox from toggling.
        e.stopPropagation();
        return; // Action handled, nothing more to do for this click.
    }

    // Second, handle the expand/collapse header click
    const header = e.target.closest('.checklist-preview-header');
    if (header) {
        e.preventDefault();
        e.stopPropagation(); // Prevents the note link from firing
        
        const body = header.nextElementSibling;
        const chevron = header.querySelector('.feather-chevron-down');
        
        if (body && chevron) {
            const isVisible = body.style.display !== 'none';
            body.style.display = isVisible ? 'none' : 'block';
            chevron.style.transform = isVisible ? 'rotate(0deg)' : 'rotate(180deg)';
        }
    }
});

// This new listener handles ticking/unticking the interactive checkboxes
// This new listener handles ticking/unticking the interactive checkboxes
// This new listener handles ticking/unticking the interactive checkboxes
// This new listener handles ticking/unticking the interactive checkboxes
app.containers.notesListContent.addEventListener('change', (e) => {
    const checkbox = e.target.closest('.checklist-preview-item input[type="checkbox"]');
    if (checkbox) {
        const { noteId, checklistIndex, itemIndex } = checkbox.dataset;
        if (!noteId) return;

        const noteResult = findItem(noteId);
        if (!noteResult || !noteResult.item) return;
        
        const note = noteResult.item;

        // 1. Update the note's content in the state using a temporary element.
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = noteData.content;

        const checklistInContent = tempDiv.querySelectorAll('.checklist-container')[parseInt(checklistIndex)];
        if (!checklistInContent) return;

        const itemInContent = checklistInContent.querySelectorAll('.checklist-item')[parseInt(itemIndex)];
        if (!itemInContent) return;

        const checkboxInContent = itemInContent.querySelector('.checklist-item-checkbox');
        const isChecked = checkbox.checked;

        itemInContent.classList.toggle('checked', isChecked);
        itemInContent.dataset.checked = isChecked;
        if (isChecked) {
            checkboxInContent.setAttribute('checked', 'checked');
        } else {
            checkboxInContent.removeAttribute('checked');
        }

        note.content = tempDiv.innerHTML;
        note.modifiedAt = new Date().toISOString();
        saveState();

        // 2. Manually update the List View UI to avoid a full re-render
        const listItemPreview = checkbox.closest('.checklist-preview-item');
        if (listItemPreview) {
            listItemPreview.classList.toggle('checked', isChecked);
        }
        
        const checklistPreviewContainer = checkbox.closest('.list-view-checklist-preview');
        if (checklistPreviewContainer) {
            const totalItems = checklistInContent.querySelectorAll('.checklist-item').length;
            const completedItems = checklistInContent.querySelectorAll('.checklist-item.checked').length;
            const progressSpan = checklistPreviewContainer.querySelector('.checklist-preview-header span.text-xs');
            if (progressSpan) {
                progressSpan.textContent = `${completedItems}/${totalItems} Done`;
            }
        }

        // 3. Manually update the main editor view if the note is currently open
        if (note.id === state.settings.activeNoteId) {
            const editorChecklists = app.elements.noteEditorBody.querySelectorAll('.checklist-container');
            const targetChecklistInEditor = editorChecklists[parseInt(checklistIndex)];
            
            if (targetChecklistInEditor) {
                // THIS IS THE FIX: We must update the live editor's DOM state
                // *before* calling the progress update function.
                const itemInEditor = targetChecklistInEditor.querySelectorAll('.checklist-item')[parseInt(itemIndex)];
                if (itemInEditor) {
                    itemInEditor.classList.toggle('checked', isChecked);
                    const checkboxInEditor = itemInEditor.querySelector('input.checklist-item-checkbox');
                    if (checkboxInEditor) {
                        checkboxInEditor.checked = isChecked;
                    }
                }
                
                // Now, update its progress bar using the corrected DOM
                updateChecklistProgress(targetChecklistInEditor);
            }
        }
    }
});
                // --- START: Calculator Logic ---
const initCalculator = () => {
    const modal = document.getElementById('calculator-modal');
    const header = document.getElementById('calculator-header');
    const closeBtn = document.getElementById('calculator-close-btn');
    const display = document.getElementById('calculator-display');
    const buttons = document.getElementById('calculator-buttons');

    let currentOperand = '';
    let previousOperand = '';
    let operation = undefined;

    const compute = () => {
        let computation;
        const prev = parseFloat(previousOperand);
        const current = parseFloat(currentOperand);
        if (isNaN(prev) || isNaN(current)) return;
        switch (operation) {
            case '+': computation = prev + current; break;
            case '-': computation = prev - current; break;
            case '*': computation = prev * current; break;
            case '/': computation = prev / current; break;
            case '%': computation = prev % current; break;
            default: return;
        }
        currentOperand = computation.toString();
        operation = undefined;
        previousOperand = '';
    };

    const chooseOperation = (op) => {
        if (currentOperand === '' && previousOperand === '') return;
        if (currentOperand === '' && previousOperand !== '') {
            operation = op;
            return;
        }
        if (previousOperand !== '') {
            compute();
        }
        operation = op;
        previousOperand = currentOperand;
        currentOperand = '';
    };

    const appendNumber = (number) => {
        if (number === '.' && currentOperand.includes('.')) return;
        currentOperand = currentOperand.toString() + number.toString();
    };
    
    const clear = () => {
        currentOperand = '';
        previousOperand = '';
        operation = undefined;
    };
    
    const clearEntry = () => {
        currentOperand = '';
    };

    const updateDisplay = () => {
        display.value = currentOperand || previousOperand || '0';
    };

    buttons.addEventListener('click', (e) => {
        if (e.target.tagName !== 'BUTTON') return;
        const buttonText = e.target.innerText;

        if (buttonText >= '0' && buttonText <= '9' || buttonText === '.') {
            appendNumber(buttonText);
        } else if (['+', '-', '*', '/', '%'].includes(buttonText)) {
            chooseOperation(buttonText);
        } else if (buttonText === '=') {
            compute();
        } else if (buttonText === 'C') {
            clear();
        } else if (buttonText === 'CE') {
            clearEntry();
        }
        updateDisplay();
    });

    display.addEventListener('keydown', (e) => {
        if ((e.key >= '0' && e.key <= '9') || e.key === '.') appendNumber(e.key);
        else if (['+', '-', '*', '/', '%'].includes(e.key)) chooseOperation(e.key);
        else if (e.key === 'Enter' || e.key === '=') { e.preventDefault(); compute(); }
        else if (e.key === 'Backspace') clearEntry();
        else if (e.key.toLowerCase() === 'c') clear();
        else if (!['Tab', 'ArrowLeft', 'ArrowRight', 'Delete'].includes(e.key)) e.preventDefault();
        
        // A small delay to allow the value to update before displaying
        setTimeout(updateDisplay, 0);
    });

    closeBtn.addEventListener('click', () => closeModal(modal));

    // Draggable logic
    let isDragging = false;
    let offsetX, offsetY;
    header.addEventListener('mousedown', (e) => {
        isDragging = true;
        offsetX = e.clientX - modal.offsetLeft;
        offsetY = e.clientY - modal.offsetTop;
        modal.style.transition = 'none'; // Disable transition for smooth dragging
    });
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        let newX = e.clientX - offsetX;
        let newY = e.clientY - offsetY;
        
        // Constrain movement within the viewport
        const buffer = 10;
        newX = Math.max(buffer, Math.min(newX, window.innerWidth - modal.offsetWidth - buffer));
        newY = Math.max(buffer, Math.min(newY, window.innerHeight - modal.offsetHeight - buffer));
        
        modal.style.left = `${newX}px`;
        modal.style.top = `${newY}px`;
    });
    document.addEventListener('mouseup', () => {
        isDragging = false;
        modal.style.transition = 'all 0.3s'; // Re-enable transition
    });
};

// --- END: Calculator Logic ---
                // --- START: ADD THIS ENTIRE BLOCK FOR CHATBOT CONTEXT ---
            window.chatbotContextNoteIds = []; // Use window scope to make it accessible

            const chatbotContextModal = document.getElementById('chatbot-context-modal');
            const contextNoteList = document.getElementById('chatbot-context-note-list');
            const contextPillsContainer = document.getElementById('chatbot-context-pills');

            const renderContextPills = () => {
                if (window.chatbotContextNoteIds.length === 0) {
                    contextPillsContainer.innerHTML = '';
                    return;
                }
                const allNotes = getAllNotes(state.collections);
                const contextNotes = allNotes.filter(n => window.chatbotContextNoteIds.includes(n.id));
                contextPillsContainer.innerHTML = contextNotes.map(note => `
                    <div class="bg-bg-pane-dark text-text-secondary text-xs font-medium px-2 py-1 rounded-full flex items-center gap-1">
                        <i data-feather="file-text" class="w-3 h-3"></i>
                        <span>${note.name}</span>
                        <button class="remove-context-pill-btn" data-note-id="${note.id}"><i data-feather="x" class="w-3 h-3"></i></button>
                    </div>
                `).join('');
                feather.replace();
            };
            
            const renderNoteListForContext = (notesToRender) => {
                contextNoteList.innerHTML = notesToRender.map(note => `
                    <label class="p-2 rounded-md hover:bg-bg-pane-dark flex items-center gap-3 cursor-pointer">
                        <input type="checkbox" class="context-note-checkbox shrink-0" value="${note.id}" ${window.chatbotContextNoteIds.includes(note.id) ? 'checked' : ''}>
                        <i data-feather="file-text" class="w-5 h-5 text-text-secondary flex-shrink-0"></i>
                        <div class="min-w-0">
                            <div class="font-semibold text-text-primary truncate">${note.name}</div>
                        </div>
                    </label>
                `).join('');
                 feather.replace();
            };
            
            document.getElementById('chatbot-add-context-btn').addEventListener('click', () => {
                renderNoteListForContext(getAllNotes(state.collections));
                openModal(chatbotContextModal);
            });

            document.getElementById('chatbot-context-search-input').addEventListener('input', (e) => {
                const query = e.target.value;
                const allNotes = getAllNotes(state.collections);
                if (!query) {
                    renderNoteListForContext(allNotes);
                    return;
                }
                const fuse = new Fuse(allNotes, { keys: ['name'], threshold: 0.4 });
                renderNoteListForContext(fuse.search(query).map(result => result.item));
            });

            document.getElementById('chatbot-context-confirm-btn').addEventListener('click', () => {
                const selectedIds = Array.from(contextNoteList.querySelectorAll('.context-note-checkbox:checked')).map(cb => cb.value);
                window.chatbotContextNoteIds = selectedIds;
                renderContextPills();
                closeModal(chatbotContextModal);
            });
            
            contextPillsContainer.addEventListener('click', (e) => {
                const removeBtn = e.target.closest('.remove-context-pill-btn');
                if(removeBtn) {
                    const noteId = removeBtn.dataset.noteId;
                    window.chatbotContextNoteIds = window.chatbotContextNoteIds.filter(id => id !== noteId);
                    renderContextPills();
                }
            });
            
            const closeContextModal = () => closeModal(chatbotContextModal);
            document.getElementById('chatbot-context-modal-close-btn').addEventListener('click', closeContextModal);
            document.getElementById('chatbot-context-cancel-btn').addEventListener('click', closeContextModal);
            // --- END: ADD THIS ENTIRE BLOCK ---
                // --- START: Calendar Right-Click to Add Event Logic ---
// --- START: Calendar Right-Click to Add Event Logic ---
// --- START: Calendar Click/Right-Click to Add Event Logic ---
// --- START: Calendar Click/Right-Click to Add Event Logic ---
// --- START: Calendar Click/Right-Click to Add Event Logic ---
const assignNoteModal = document.getElementById('assign-note-modal');
const calendarViewEl = document.getElementById('calendar-view');
let assignNoteTargetTimestamp = null;
let notesForAssignment = [];
let isAssigningWithTime = false;

const openAssignNoteModal = (timestamp, notes) => {
    assignNoteTargetTimestamp = timestamp;
    notesForAssignment = notes;
    const modalTitle = document.getElementById('assign-note-modal-title');
    const searchInput = document.getElementById('assign-note-search-input');
    const durationWrapper = document.getElementById('assign-note-duration-wrapper');
    const durationInput = document.getElementById('assign-note-duration-input');

    // A specific time is being assigned if it's not noon (our placeholder for 'all-day')
    isAssigningWithTime = !(timestamp.getHours() === 12 && timestamp.getMinutes() === 0);

    durationWrapper.style.display = isAssigningWithTime ? 'block' : 'none';
    durationInput.value = '';

    const titleTime = isAssigningWithTime ? timestamp.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' }) : '';
    const titleDate = timestamp.toLocaleDateString(undefined, { month: 'long', day: 'numeric' });
    modalTitle.textContent = `Assign Note to ${titleDate}${isAssigningWithTime ? ` at ${titleTime}`: ''}`;

    searchInput.value = '';
    renderAssignableNotes(notes);
    openModal(assignNoteModal);
    searchInput.focus();
};

const renderAssignableNotes = (notes) => {
    const listEl = document.getElementById('assign-note-list');
    if (notes.length === 0) {
        listEl.innerHTML = `<p class="p-4 text-center text-sm text-text-tertiary">No notes in this project.</p>`; return;
    }
    listEl.innerHTML = notes.map(note => `
        <div class="link-modal-item p-2 rounded-md hover:bg-bg-pane-dark cursor-pointer" data-note-id="${note.id}">
            <div class="flex items-center gap-3">
                <i data-feather="file-text" class="w-5 h-5 text-text-secondary flex-shrink-0"></i>
                <div class="min-w-0">
                    <div class="font-semibold text-text-primary truncate">${note.name}</div>
                    <div class="text-sm text-text-secondary truncate">${formatDateTime(note.modifiedAt)}</div>
                </div>
            </div>
        </div>`).join('');
    feather.replace();
};

const handleCalendarDayAction = (dayCell) => {
    const date = new Date(dayCell.dataset.date + 'T12:00:00');
    const collectionId = state.settings.activeCollectionId;
    const collection = findItem(collectionId)?.item;
    const notesInCollection = (collection?.children || []).filter(item => item.type === 'note');
    openAssignNoteModal(date, notesInCollection);
};

const handleDayViewTimeSlotAction = (slotEl) => {
    const dayViewContainer = slotEl.closest('.day-view-container');
    if(!dayViewContainer) return;

    const dateString = dayViewContainer.dataset.date; // This is now YYYY-MM-DD
    const allSlots = Array.from(slotEl.parentElement.children);
    const hour = allSlots.indexOf(slotEl);

    const [year, month, day] = dateString.split('-').map(Number);
    const targetTimestamp = new Date(year, month - 1, day, hour);

    const collectionId = state.settings.activeCollectionId;
    const collection = findItem(collectionId)?.item;
    const notesInCollection = (collection?.children || []).filter(item => item.type === 'note');
    openAssignNoteModal(targetTimestamp, notesInCollection);
};

calendarViewEl.addEventListener('contextmenu', (e) => {
    const dayCell = e.target.closest('.calendar-day-cell');
    const hourSlot = e.target.closest('.day-view-hour-slot');
    if (dayCell || hourSlot) e.preventDefault();

    if (dayCell) handleCalendarDayAction(dayCell);
    if (hourSlot) handleDayViewTimeSlotAction(hourSlot);
});

calendarViewEl.addEventListener('click', (e) => {
    if (window.innerWidth >= 768) return; // Mobile only
    const dayCell = e.target.closest('.calendar-day-cell');
    const hourSlot = e.target.closest('.day-view-hour-slot');
    if (dayCell || hourSlot) e.preventDefault();

    if (dayCell) handleCalendarDayAction(dayCell);
    if (hourSlot) handleDayViewTimeSlotAction(hourSlot);
});

document.getElementById('assign-note-search-input').addEventListener('input', (e) => {
    const query = e.target.value;
    if (!query) { renderAssignableNotes(notesForAssignment); return; }
    const fuse = new Fuse(notesForAssignment, { keys: ['name'], threshold: 0.4 });
    renderAssignableNotes(fuse.search(query).map(result => result.item));
});

document.getElementById('assign-note-list').addEventListener('click', (e) => {
    const noteItem = e.target.closest('.link-modal-item');
    if (noteItem) {
        const noteId = noteItem.dataset.noteId;
        const note = window.noteCache[noteId];
        if (note && assignNoteTargetTimestamp) {
            if (!note.properties) note.properties = {};

            let datePropName = Object.keys(note.properties).find(k => note.properties[k].type === 'date') || 'Date';

            note.properties[datePropName] = { type: 'date', value: assignNoteTargetTimestamp.toISOString() };

            if (isAssigningWithTime) {
                const durationInput = document.getElementById('assign-note-duration-input').value;
                let durationInMinutes = parseDurationToMinutes(durationInput);
                if (durationInMinutes <= 0) { durationInMinutes = 60; }

                const endDate = new Date(assignNoteTargetTimestamp.getTime() + durationInMinutes * 60 * 1000);
                note.properties[datePropName].endValue = endDate.toISOString();
            } else {
                delete note.properties[datePropName].endValue;
            }

            note.modifiedAt = new Date().toISOString();
            saveState();

            if (document.querySelector('.day-view-container')) {
                renderDayView(assignNoteTargetTimestamp);
            } else { renderCalendarView(); }

            closeModal(assignNoteModal);
            showToast(`✅ "${note.name}" assigned to date.`);
        }
    }
});

document.getElementById('assign-note-modal-close-btn').addEventListener('click', () => {
    closeModal(assignNoteModal);
});
// --- END: Calendar Click/Right-Click to Add Event Logic ---
// --- END: Calendar Click/Right-Click to Add Event Logic ---
// --- END: Calendar Click/Right-Click to Add Event Logic ---
// --- END: Calendar Right-Click to Add Event Logic ---
// --- END: Calendar Right-Click to Add Event Logic ---
                // --- START: Mobile Toolbar Keyboard Awareness Logic ---

// --- END: Mobile Toolbar Keyboard Awareness Logic ---
                // ADD THIS ENTIRE BLOCK FOR THE NEW "ADD PROPERTY" MODAL LOGIC
// REPLACE THE ENTIRE "ADD PROPERTY" MODAL LOGIC BLOCK WITH THIS
const addPropertyModal = document.getElementById('add-property-modal');
const propTypeSelector = document.getElementById('new-prop-type-selector');
const propValueContainer = document.getElementById('new-prop-value-container');
const propValueWrapper = document.getElementById('new-prop-value-input-wrapper');

// This function dynamically creates the correct input field based on the selected type
const renderValueInput = (type) => {
    let inputHTML = '';
    const baseClasses = "class='w-full bg-bg-pane-dark border border-border-color rounded-md p-2 focus:ring-2 focus:ring-accent-primary focus:outline-none'";

    switch (type) {
        case 'text':
            inputHTML = `<input type="text" id="new-prop-value-input" ${baseClasses}>`;
            break;
        case 'number':
            inputHTML = `<input type="number" id="new-prop-value-input" ${baseClasses}>`;
            break;
        case 'date':
            inputHTML = `<input type="date" id="new-prop-value-input" ${baseClasses}>`;
            break;
        case 'image':
            inputHTML = `<input type="text" id="new-prop-value-input" placeholder="https://example.com/image.png" ${baseClasses}>`;
            break;
        case 'select':
            // For 'select', we don't ask for an initial value, just create the property.
            propValueContainer.classList.add('hidden');
            propValueWrapper.innerHTML = '';
            return;
    }
    propValueContainer.classList.remove('hidden');
    propValueWrapper.innerHTML = inputHTML;
};

// Listen for changes on the radio buttons to show the correct input
propTypeSelector.addEventListener('change', (e) => {
    const selectedType = e.target.value;
    renderValueInput(selectedType);
});

// Logic for the "Create" button, now with value handling
document.getElementById('create-property-btn').addEventListener('click', () => {
    const nameInput = document.getElementById('new-prop-name-input');
    const errorEl = document.getElementById('add-property-error');
    const propName = nameInput.value.trim();
    const propType = addPropertyModal.querySelector('input[name="prop-type"]:checked').value;

    if (!propName) {
        errorEl.textContent = 'Property name cannot be empty.';
        return;
    }
    
    const note = findItem(state.settings.activeNoteId)?.item;
    if (note) {
        if (!note.properties) note.properties = {};
        if (note.properties[propName] || ['Created', 'Modified'].includes(propName)) {
            errorEl.textContent = 'A property with this name already exists.';
            return;
        }

        let propValue = '';
        const valueInput = document.getElementById('new-prop-value-input');
        if (valueInput) {
            propValue = valueInput.value;
            // Convert date to proper ISO string format
            if (propType === 'date' && propValue) {
                const parts = propValue.split('-');
                propValue = new Date(Date.UTC(parts[0], parts[1] - 1, parts[2])).toISOString();
            }
        }

        note.properties[propName] = { type: propType, value: propValue };
        
        if (propType === 'select') {
            note.properties[propName].options = [];
        }

        saveState();
        renderNoteProperties(note);
        feather.replace();
        closeModal(addPropertyModal);
        showToast(`Property "${propName}" added!`, 'success');
    }
});

// Logic for closing the modal
const closeAddPropertyModal = () => closeModal(document.getElementById('add-property-modal'));
document.getElementById('add-property-cancel-btn').addEventListener('click', closeAddPropertyModal);
document.getElementById('add-property-modal-close-btn').addEventListener('click', closeAddPropertyModal);
// END OF BLOCK// END OF BLOCK TO ADD
                // --- START: Date Property Click-to-Calendar Listener ---
app.containers.notesListContent.addEventListener('click', (e) => {
    const dateBtn = e.target.closest('.list-view-jump-to-date-btn');
    if (dateBtn) {
        e.preventDefault();
        e.stopPropagation(); // Prevents the main card link from firing

        const noteId = dateBtn.dataset.noteId;
        const dateValue = dateBtn.dataset.dateValue;
        const noteResult = findItem(noteId);

        if (noteResult && dateValue) {
            const targetDate = new Date(dateValue);
            const parentCollection = Array.isArray(noteResult.parent) ? null : noteResult.parent;
            
            if (parentCollection) {
                // Set the calendar state for that collection to the correct month/year
                if (!state.calendar) state.calendar = {};
                state.calendar[parentCollection.id] = {
                    month: targetDate.getMonth(),
                    year: targetDate.getFullYear()
                };
                
                // Store the specific date we want to highlight
                state.settings.calendarHighlightDate = targetDate.toISOString().split('T')[0];
                
                // Switch the view to the calendar
                state.settings.activeView = 'calendar';
                state.settings.activeCollectionId = parentCollection.id;
                state.settings.activeNoteId = null; // We are viewing the folder, not a single note

                saveState();
                render();
            } else {
                showToast("Note must be in a project folder to view in calendar.", "info");
            }
        }
    }
});
// --- END: Date Property Click-to-Calendar Listener ---
                
                
                // ADD THIS NEW EVENT LISTENER INSIDE init()
// REPLACE THE ENTIRE 'calendar-view' CLICK LISTENER WITH THIS
document.getElementById('calendar-view').addEventListener('click', e => {
    const dayViewBtn = e.target.closest('#calendar-day-view-btn');
    const monthViewBtn = e.target.closest('#calendar-month-view-btn');
    const dayNumber = e.target.closest('.calendar-day-number');
    const eventLink = e.target.closest('.day-view-event-link');
    const prevBtn = e.target.closest('#calendar-prev-month');
    const nextBtn = e.target.closest('#calendar-next-month');
    const eventItem = e.target.closest('.calendar-event-item');
    
    const collectionId = state.settings.activeCollectionId;
    if (!collectionId) return;

    if (dayViewBtn) {
        renderDayView(new Date()); // Switch to today's date in Day View
    } else if (monthViewBtn) {
        renderCalendarView(); // Switch back to Month View
    } else if (dayNumber) {
        const dateStr = dayNumber.closest('.calendar-day-cell').dataset.date;
        renderDayView(new Date(dateStr + 'T12:00:00Z')); // Use noon UTC to avoid timezone issues
    } else if (eventLink) {
        e.preventDefault();
        state.settings.activeNoteId = eventLink.dataset.noteId;
        saveState();
        render();
    } else if (prevBtn) {
        state.calendar[collectionId].month--;
        if (state.calendar[collectionId].month < 0) {
            state.calendar[collectionId].month = 11;
            state.calendar[collectionId].year--;
        }
        renderCalendarView();
    } else if (nextBtn) {
        state.calendar[collectionId].month++;
        if (state.calendar[collectionId].month > 11) {
            state.calendar[collectionId].month = 0;
            state.calendar[collectionId].year++;
        }
        renderCalendarView();
    } else if (eventItem) {
        e.preventDefault();
        state.settings.activeNoteId = eventItem.dataset.noteId;
        saveState();
        render();
    }
});
// ADD THIS NEW EVENT LISTENER INSIDE init()
document.getElementById('gallery-view').addEventListener('click', e => {
    const cardItem = e.target.closest('.gallery-card-item');
    if (cardItem) {
        e.preventDefault();
        const noteId = cardItem.dataset.noteId;
        state.settings.activeNoteId = noteId;
        saveState();
        render();
    }
});
                // ADD THIS ENTIRE EVENT LISTENER BLOCK
// START: CORRECTED AND UNIFIED PROPERTY INTERACTION LOGIC
const propertiesContainer = document.getElementById('note-properties-container');
const propertiesMenu = document.getElementById('properties-menu');

// --- Unified Click Listener for the Properties Container ---
// REPLACE THE ENTIRE 'propertiesContainer.addEventListener('click', ...)' BLOCK WITH THIS
// REPLACE THE 'click' EVENT LISTENER FOR THE propertiesContainer
// REPLACE THE 'click' EVENT LISTENER FOR THE propertiesContainer
propertiesContainer.addEventListener('click', async (e) => {
    const note = findItem(state.settings.activeNoteId)?.item;
    if (!note) return;
    
    // This new block handles the "+ Add end date" button correctly, which is now legacy but we keep it for old data.
    const addEndDateBtn = e.target.closest('#add-end-date-btn');
    if (addEndDateBtn) {
        addEndDateBtn.classList.add('hidden');
        const wrapper = addEndDateBtn.closest('.flex-col')?.querySelector('#end-date-wrapper');
        if (wrapper) wrapper.classList.remove('hidden');
        return;
    }

    if (e.target.closest('#properties-header')) {
        note.propertiesCollapsed = !note.propertiesCollapsed;
        saveState();
        renderNoteProperties(note);
        feather.replace();
        return;
    }

    if (e.target.closest('#add-property-btn')) {
        const modal = document.getElementById('add-property-modal');
        document.getElementById('new-prop-name-input').value = '';
        document.getElementById('add-property-error').textContent = '';
        const defaultRadio = modal.querySelector('input[type="radio"][value="text"]');
        if(defaultRadio) defaultRadio.checked = true;
        renderValueInput('text');
        openModal(modal);
        feather.replace();
        document.getElementById('new-prop-name-input').focus();
        return;
    }

    const deleteBtn = e.target.closest('.delete-prop-btn');
    if (deleteBtn) {
        const propName = deleteBtn.dataset.propName;
        delete note.properties[propName];
        saveState();
        renderNoteProperties(note);
        feather.replace();
        return;
    }

    const valueContainer = e.target.closest('.prop-value-container');
    if (valueContainer && !valueContainer.dataset.editing) {
        const propValueEl = valueContainer.querySelector('[data-prop-name]');
        if (!propValueEl) return;

        const propName = propValueEl.dataset.propName;
        const allProps = {
            'Created': { type: 'date', value: note.createdAt, readonly: true },
            'Modified': { type: 'date', value: note.modifiedAt, readonly: true },
            ...(note.properties || {})
        };
        const prop = allProps[propName];
        if (!prop || prop.readonly) return;

        valueContainer.dataset.editing = "true";

        if (prop.type === 'date') {
            const toLocalISOString = (date) => {
                const tzoffset = (new Date()).getTimezoneOffset() * 60000;
                return (new Date(date - tzoffset)).toISOString().slice(0, 16);
            };
            
            const startValue = prop.value ? toLocalISOString(new Date(prop.value)) : '';
            let durationMinutes = 0;
            if (prop.value && prop.endValue) {
                durationMinutes = (new Date(prop.endValue) - new Date(prop.value)) / 60000;
            }
            const durationString = durationMinutes > 0 ? `${durationMinutes}m` : '';

            let inputHTML = `
                <div class="flex items-center gap-2">
                    <input type="datetime-local" value="${startValue}" class="prop-edit-input bg-transparent focus:outline-none w-full" data-prop-name="${propName}" data-prop-type="date" data-date-type="start">
                    <input type="text" value="${durationString}" placeholder="e.g., 45m, 1.5h" class="prop-edit-input bg-transparent focus:outline-none w-full" data-prop-name="${propName}" data-prop-type="date" data-date-type="duration">
                </div>
            `;
            valueContainer.innerHTML = inputHTML;
            valueContainer.querySelector('input[data-date-type="start"]')?.focus();
        } else {
            // Logic for 'text', 'number', 'select', etc. remains the same
            const originalValue = prop.value || '';
            const inputType = prop.type === 'number' ? 'number' : 'text';
            let inputHTML = `<input type="${inputType}" value="${originalValue}" class="prop-edit-input bg-transparent focus:outline-none w-full" data-prop-name="${propName}" data-prop-type="${prop.type}">`;
            valueContainer.innerHTML = inputHTML;
            const input = valueContainer.querySelector('input');
            input.focus();
            input.select();
        }
    }
});

// --- Save changes when an input loses focus (blur) ---
// --- Save changes when an input loses focus (blur) ---
// REPLACE THE 'blur' EVENT LISTENER FOR THE propertiesContainer
// REPLACE THE 'blur' EVENT LISTENER FOR THE propertiesContainer
// REPLACE THE 'blur' EVENT LISTENER FOR THE propertiesContainer
propertiesContainer.addEventListener('blur', (e) => {
    if (e.target.classList.contains('prop-edit-input')) {
        const note = findItem(state.settings.activeNoteId)?.item;
        const input = e.target;
        const propName = input.dataset.propName;
        
        if (note && propName) {
            const valueContainer = input.closest('.prop-value-container');
            if (!valueContainer) return;

            setTimeout(() => {
                if (document.activeElement.closest('.prop-value-container') === valueContainer) return;
                
                valueContainer.removeAttribute('data-editing');
                const prop = note.properties[propName];
                
                if (prop.type === 'date') {
                    const startDateInput = valueContainer.querySelector('input[data-date-type="start"]');
                    const durationInput = valueContainer.querySelector('input[data-date-type="duration"]');
                    
                    if (startDateInput && startDateInput.value) {
                        const startDate = new Date(startDateInput.value);
                        prop.value = startDate.toISOString();
                        
                        const durationMinutes = parseDurationToMinutes(durationInput.value);
                        if (durationMinutes > 0) {
                            const endDate = new Date(startDate.getTime() + durationMinutes * 60000);
                            prop.endValue = endDate.toISOString();
                        } else {
                            delete prop.endValue;
                        }
                    } else {
                        delete prop.value;
                        delete prop.endValue;
                    }
                } else {
                    prop.value = input.value;
                }

                saveState();
                renderNoteProperties(note);
                feather.replace();
            }, 150);
        }
    }
}, true);

// --- Handle adding a new property from the menu ---
propertiesMenu.addEventListener('click', async (e) => {
    const button = e.target.closest('button');
    if (!button) return;
    const propType = button.dataset.propType;

    const propName = await showPrompt({
        title: 'New Property',
        message: `Enter a name for the new "${propType}" property:`,
        placeholder: 'e.g., Status, Priority...'
    });

    if (propName) {
        const note = findItem(state.settings.activeNoteId)?.item;
        if (note) {
            if (!note.properties) note.properties = {};
            // If the new property is a date, initialize with a valid date. Otherwise, empty string.
            const initialValue = propType === 'date' ? new Date().toISOString() : '';
            note.properties[propName] = { type: propType, value: initialValue };
            
            if (propType === 'select') {
                note.properties[propName].options = [];
            }
            saveState();
            renderNoteProperties(note);
            feather.replace();
        }
    }

    propertiesMenu.classList.add('scale-95', 'opacity-0');
    setTimeout(() => propertiesMenu.classList.add('hidden'), 100);
});
// ADD THIS ENTIRE NEW EVENT LISTENER BLOCK
document.getElementById('select-property-menu').addEventListener('click', (e) => {
    const button = e.target.closest('.select-option-item');
    if (!button) return;

    const menu = document.getElementById('select-property-menu');
    const propName = menu.dataset.propName;
    const note = findItem(state.settings.activeNoteId)?.item;
    if (!note || !propName) return;

    const prop = note.properties[propName];
    const value = button.dataset.value;
    
    // This part handles creating a new option if it doesn't exist
    if (button.dataset.action === 'create') {
        if (!prop.options) prop.options = [];
        prop.options.push({ name: value });
    }
    
    // This sets the note's property value to the selected option
    prop.value = value;
    
    saveState();
    renderNoteProperties(note);
    feather.replace();

    // Hide the menu after selection
    menu.classList.add('scale-95', 'opacity-0');
    setTimeout(() => menu.classList.add('hidden'), 100);
});
// END: CORRECTED AND UNIFIED PROPERTY INTERACTION LOGIC

// Global click to hide the properties menu
// ADD THIS NEW, UPGRADED BLOCK
// Global click listener to hide any open property-related menus
document.addEventListener('click', (e) => {
    const propertiesMenu = document.getElementById('properties-menu');
    const selectMenu = document.getElementById('select-property-menu');

    // Hide the main "Add Property" menu if clicking away
    if (!propertiesMenu.classList.contains('hidden') && !e.target.closest('#add-property-btn') && !e.target.closest('#properties-menu')) {
        propertiesMenu.classList.add('scale-95', 'opacity-0');
        setTimeout(() => propertiesMenu.classList.add('hidden'), 100);
    }

    // Hide the "Select Option" menu if clicking away from it or its trigger
    if (!selectMenu.classList.contains('hidden') && !e.target.closest('.prop-value-container') && !e.target.closest('#select-property-menu')) {
        selectMenu.classList.add('scale-95', 'opacity-0');
        setTimeout(() => selectMenu.classList.add('hidden'), 100);
    }
});
// END OF EVENT LISTENER BLOCK
                // --- START: SLASH COMMAND CONSOLE ---
                // --- START: SLASH COMMAND CONSOLE ---

// --- START: SLASH COMMAND CONSOLE ---

// --- START: SLASH COMMAND CONSOLE ---

// --- START: SLASH COMMAND CONSOLE ---
const renderTemplatesInModal = (templatesToRender) => {
    const container = document.getElementById('template-list-container');
    if (templatesToRender.length === 0) {
        container.innerHTML = `<p class="text-text-secondary text-center md:col-span-2">No templates found. Save a note as a template to get started.</p>`;
        return;
    }
    container.innerHTML = templatesToRender.map(template => `
        <div class="template-item cursor-pointer p-4 border border-border-color rounded-lg hover:bg-bg-pane-dark hover:border-accent-primary transition-all" data-template-id="${template.id}">
            <h4 class="font-semibold text-text-primary truncate">${template.name}</h4>
            <p class="text-sm text-text-secondary mt-1 truncate-multiline" style="-webkit-line-clamp: 2;">${template.content.replace(/<[^>]*>?/gm, '') || 'No content.'}</p>
        </div>
    `).join('');
};
// ADD THIS ENTIRE FUNCTION
const openTemplateModal = () => {
    const modal = document.getElementById('template-modal');
    const searchInput = document.getElementById('template-search-input');

    // Initial render with all available templates
    renderTemplatesInModal(state.templates);

    // Clear any previous search and open the modal
    searchInput.value = '';
    openModal(modal);

    // Set up a search listener for the template modal input
    const handleSearch = debounce(() => {
        const query = searchInput.value.toLowerCase().trim();
        if (!query) {
            renderTemplatesInModal(state.templates); // Show all if search is empty
            return;
        }
        const filtered = state.templates.filter(t => t.name.toLowerCase().includes(query));
        renderTemplatesInModal(filtered);
    }, 200);

    // Ensure we only add the listener once to prevent duplicates
    if (!searchInput.hasAttribute('data-listener-added')) {
        searchInput.addEventListener('input', handleSearch);
        searchInput.setAttribute('data-listener-added', 'true');
    }
};
const renderManageTemplatesModal = () => {
    const container = document.getElementById('manage-template-list');
    if (state.templates.length === 0) {
        container.innerHTML = `<p class="text-text-secondary text-center p-4">You have no saved templates.</p>`;
        return;
    }
    container.innerHTML = state.templates.map(template => `
        <div class="flex items-center justify-between p-2 bg-bg-pane-dark rounded-md" data-template-id="${template.id}">
            <span class="font-medium text-text-primary truncate">${template.name}</span>
            <div class="flex items-center gap-2">
                <button class="manage-template-rename-btn p-2 rounded-md hover:bg-bg-main text-text-secondary hover:text-accent-primary" title="Rename Template">
                    <i data-feather="edit-2" class="w-4 h-4 pointer-events-none"></i>
                </button>
                <button class="manage-template-delete-btn p-2 rounded-md hover:bg-bg-main text-text-secondary hover:text-red-500" title="Delete Template">
                    <i data-feather="trash-2" class="w-4 h-4 pointer-events-none"></i>
                </button>
            </div>
        </div>
    `).join('');
    feather.replace();
};

const renameTemplate = async (templateId) => {
    const template = state.templates.find(t => t.id === templateId);
    if (!template) return;

    const newName = await showPrompt({
        title: 'Rename Template',
        message: 'Enter a new name:',
        initialValue: template.name
    });

    if (newName && newName !== template.name) {
        template.name = newName;
        await saveState();
        renderManageTemplatesModal(); // Refresh the list
        showToast('✅ Template renamed!', 'success');
    }
};
// --- START: Collaboration & Sharing Logic ---
const openShareModal = async () => {
    const modal = document.getElementById('share-modal');
    const noteId = state.settings.activeNoteId;
    if (!noteId) return showToast('No note selected.', 'error');

    const { doc, getDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
    const noteRef = doc(db, "notes", noteId);
    const noteSnap = await getDoc(noteRef);

    if (!noteSnap.exists()) return showToast('Note not found.', 'error');

    const noteData = noteSnap.data();
    renderCollaboratorsList(noteData);
    openModal(modal);
    feather.replace();
};

// =================================================================
// START: REPLACEMENT renderCollaboratorsList FUNCTION
// =================================================================
// REPLACE THE ENTIRE renderCollaboratorsList FUNCTION
const renderCollaboratorsList = async (noteData) => {
    const listEl = document.getElementById('share-collaborators-list');
    const ownerId = noteData.ownerId;
    const sharedWithUIDs = noteData.sharedWith || [];

    const currentUserEmail = window.auth.currentUser.email;
    let html = `<div class="flex items-center justify-between p-2">
        <div class="flex items-center gap-2">
            <span class="font-medium">${currentUserEmail}</span>
            <span class="text-xs bg-green-500/20 text-green-400 px-2 py-0.5 rounded-full">Owner</span>
        </div>
        <span class="text-sm text-text-tertiary">Full Access</span>
    </div>`;

    if (sharedWithUIDs.length > 0) {
        try {
            // Call the new Cloud Function to get emails
            const { httpsCallable } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-functions.js");
            const getUserProfiles = httpsCallable(window.functions, 'getUserProfiles');
            const result = await getUserProfiles({ uids: sharedWithUIDs });
            const collaborators = result.data.users;

            html += collaborators.map(user => `
                <div class="flex items-center justify-between p-2 rounded-md hover:bg-bg-pane-dark">
                    <span class="text-text-primary">${user.email}</span>
                    <button class="remove-collaborator-btn text-xs text-red-500 hover:underline" data-uid="${user.uid}">Remove</button>
                </div>
            `).join('');

        } catch (error) {
            console.error("Error fetching collaborator profiles:", error);
            // Fallback to showing UIDs if the function call fails
            html += sharedWithUIDs.map(uid => `
                 <div class="flex items-center justify-between p-2 rounded-md hover:bg-bg-pane-dark">
                    <span class="font-mono text-xs text-text-secondary">Error loading email (${uid})</span>
                    <button class="remove-collaborator-btn text-xs text-red-500 hover:underline" data-uid="${uid}">Remove</button>
                </div>
            `).join('');
            showToast("Couldn't load collaborator emails.", "error");
        }
    }

    listEl.innerHTML = html;
};
// =================================================================
// END: REPLACEMENT renderCollaboratorsList FUNCTION
// =================================================================

// REPLACE the existing handleInviteCollaborator function
const handleInviteCollaborator = async () => {
    const input = document.getElementById('share-email-input');
    const errorEl = document.getElementById('share-error');
    const email = input.value.trim();
    if (!email) return;

    const noteId = state.settings.activeNoteId;
    const note = findItem(noteId)?.item;
    if (!note) return;

    errorEl.textContent = '';
    const toastId = showToast('Sending invitation...', 'loading');

    try {
        const { httpsCallable } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-functions.js");
        const inviteUser = httpsCallable(functions, 'inviteUserByEmail');

        await inviteUser({
            email: email,
            noteId: noteId,
            noteName: note.name
        });

        input.value = '';
        dismissToast(toastId);
        showToast('Invitation sent!', 'success');

    } catch (error) {
        dismissToast(toastId);
        errorEl.textContent = error.message;
        console.error("Error inviting user:", error);
    }
};
const handleRemoveCollaborator = async (uidToRemove) => {
    const noteId = state.settings.activeNoteId;
    if (!noteId || !uidToRemove) return;

    const { doc, updateDoc, getDoc, arrayRemove } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
const noteRef = doc(db, "notes", noteId);

await updateDoc(noteRef, {
    sharedWith: arrayRemove(uidToRemove)
});

    const noteSnap = await getDoc(noteRef);
    renderCollaboratorsList(noteSnap.data());
    showToast('User removed.', 'success');
};

// --- END: Collaboration & Sharing Logic ---
const deleteTemplate = async (templateId) => {
    const template = state.templates.find(t => t.id === templateId);
    if (!template) return;

    // Directly delete the template without confirmation
    state.templates = state.templates.filter(t => t.id !== templateId);
    await saveState();
    renderManageTemplatesModal(); // Refresh the list
    showToast('🗑️ Template deleted.', 'success');
};
// --- START: Real-time Note Synchronization Logic ---

// --- END: Real-time Note Synchronization Logic ---
const saveAsTemplate = async (note) => {
    if (!note) return showToast('❌ No note selected.', 'error');

    // FIX: Get the full note data, including content, from the cache.
    const noteData = window.noteCache[note.id];
    if (!noteData) {
        return showToast('❌ Could not load note content to create template.', 'error');
    }

    const templateName = await showPrompt({
        title: 'Save as Template',
        message: 'Enter a name for this template:',
        initialValue: note.name // Use the name from the note stub
    });

    if (templateName) {
        // Check for duplicate template name
        if (state.templates.some(t => t.name.toLowerCase() === templateName.toLowerCase())) {
            showToast(`❌ A template named "${templateName}" already exists.`, 'error');
            return;
        }

        const newTemplate = {
            id: generateId('template'),
            name: templateName,
            // FIX: Use the content and properties from the full noteData object.
            content: noteData.content,
            properties: JSON.parse(JSON.stringify(noteData.properties || {}))
        };

        state.templates.push(newTemplate);
        await saveState();
        showToast(`✅ Template "${templateName}" saved!`, 'success');
    }
};

const createContentSnippet = (content, query) => {
    const plainText = content.replace(/<[^>]*>?/gm, ' ').replace(/\s+/g, ' ');
    const lowerQuery = query.toLowerCase();
    const queryIndex = plainText.toLowerCase().indexOf(lowerQuery);
    if (queryIndex === -1) return null;
    const start = Math.max(0, queryIndex - 20);
    const end = Math.min(plainText.length, queryIndex + query.length + 40);
    let snippet = plainText.substring(start, end);
    const regex = new RegExp(`(${query.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')})`, 'gi');
    snippet = snippet.replace(regex, '<b class="text-accent-primary">$1</b>');
    return `...${snippet}...`;
};

const findBestMatch = (query, items) => {
    if (!query || !items || items.length === 0) return null;
    
    // These options tell Fuse.js to search by the 'name' key and to be lenient with typos.
    const fuseOptions = {
        keys: ['name'],
        includeScore: true,
        threshold: 0.4 
    };

    const fuse = new Fuse(items, fuseOptions);
    const results = fuse.search(query);
    
    // Return the best match (the first item in the results)
    return results.length > 0 ? results[0].item : null;
};

const getAllTags = () => {
    const allNotes = getAllNotes(state.collections);
    const allTagsRaw = allNotes.flatMap(note => note.tags || []);
    return [...new Set(allTagsRaw)];
};

const commandPromptContainer = document.getElementById('command-prompt-container');
const commandInput = document.getElementById('command-input');
const commandSuggestionsContainer = document.getElementById('command-suggestions');
let isCommandPromptOpen = false;
let suggestionIndex = -1;

const renderHelpModal = () => {
    const helpContent = document.getElementById('help-content');
    helpContent.innerHTML = commands.sort((a,b) => a.name.localeCompare(b.name)).map(cmd => `
        <div class="help-command-row p-2 rounded-md hover:bg-bg-pane-dark">
            <code class="font-semibold text-text-primary bg-bg-pane-dark px-2 py-1 rounded-md whitespace-nowrap">/${cmd.name}</code>
            <p class="text-sm text-text-secondary">${cmd.description}</p>
        </div>
    `).join('');
    openModal(document.getElementById('help-modal'));
    feather.replace();
};

const renderLinkedNotesModal = (note) => {
    const modalTitle = document.getElementById('linked-notes-title');
    const modalContent = document.getElementById('linked-notes-content');
    modalTitle.innerHTML = `<i data-feather="link" class="w-5 h-5 text-accent-primary"></i> Connections for "${note.name}"`;
    
    const allNotes = getAllNotes(state.collections);
    const outgoingLinks = (note.links || []).map(linkName => allNotes.find(n => n.name === linkName)).filter(Boolean);
    const incomingLinks = allNotes.filter(n => n.id !== note.id && (n.links || []).some(linkName => linkName === note.name));

    const createNoteHTML = (n) => {
        const findResult = findItem(n.id);
        const parentName = (findResult && findResult.parent && !Array.isArray(findResult.parent)) ? findResult.parent.name : 'Uncategorized';

        return `
            <li class="border-2 border-border-color rounded-lg hover:bg-bg-pane-dark transition-colors duration-150">
                <a href="#" class="linked-note-jump block p-3" data-note-id="${n.id}">
                    <div class="flex items-center gap-3">
                        <i data-feather="file-text" class="w-5 h-5 text-text-secondary flex-shrink-0"></i>
                        <div class="min-w-0">
                            <div class="font-semibold text-text-primary truncate">${n.name}</div>
                            <div class="text-sm text-text-secondary truncate">${parentName}</div>
                        </div>
                    </div>
                </a>
            </li>`;
    };

    let contentHTML = '';
    if (outgoingLinks.length > 0) {
        contentHTML += `<div><h4 class="font-semibold text-text-primary mb-2">Links from this note:</h4><ul class="space-y-2">` + outgoingLinks.map(createNoteHTML).join('') + `</ul></div>`;
    }
    if (incomingLinks.length > 0) {
        contentHTML += `<div><h4 class="font-semibold text-text-primary mb-2">Linked here (Backlinks):</h4><ul class="space-y-2">` + incomingLinks.map(createNoteHTML).join('') + `</ul></div>`;
    }
    if (!contentHTML) {
        contentHTML = `<p class="text-text-secondary">No connections found for this note.</p>`;
    }

    modalContent.innerHTML = contentHTML;
    openModal(document.getElementById('linked-notes-modal'));
    feather.replace();
};

const executeWithSmartFind = async (args, itemType, action) => {
    let allItems, targetItem = null;
    if (itemType === 'notes') allItems = getAllNotes(state.collections);
    else if (itemType === 'folders') allItems = getAllFolders();
    else allItems = [...getAllNotes(state.collections), ...getAllFolders()];
    if (args) {
        targetItem = findBestMatch(args, allItems);
        if (!targetItem && itemType !== 'folders') {
            const contentResults = lunrIndex.search(args);
            if (contentResults.length > 0) {
                const item = findItem(contentResults[0].ref)?.item;
                if (item && item.type === 'note' && (itemType === 'notes' || itemType === 'items')) targetItem = item;
            }
        }
    }
    if (!targetItem) {
        if (itemType === 'notes' && state.settings.activeNoteId) targetItem = findItem(state.settings.activeNoteId)?.item;
        else if (itemType === 'folders' && state.settings.activeCollectionId) {
            const res = findItem(state.settings.activeCollectionId);
            if (res?.item.type === 'folder') targetItem = res.item;
        } else if (itemType === 'items') {
             const activeId = state.settings.activeNoteId || state.settings.activeCollectionId;
             if (activeId) targetItem = findItem(activeId)?.item;
        }
    }
    if (!targetItem) {
        const typeName = itemType.slice(0, -1);
        return showToast(`❌ ${typeName.charAt(0).toUpperCase() + typeName.slice(1)} not found.`, 'error');
    }
    action(targetItem);
};

const commands = [
    { name: 'nn', description: 'New Note. Usage: /nn [note name]', execute: async(args)=>{ const noteName = args || 'Untitled Note'; await createNewNote(true, { name: noteName }); showToast(`✅ Note "${noteName}" created`); } },
    // ADD THIS ENTIRE OBJECT TO YOUR COMMANDS ARRAY
{
    name: 'load',
    description: 'Fetch all Note Data.',
    execute: async () => {
        const toastId = showToast('🧠 Loading all note contents...', 'loading');
        try {
            const { getDoc, doc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
            const allNoteStubs = getAllNotes(state.collections);
            let notesWereLoaded = false;

            const fetchPromises = allNoteStubs.map(noteStub => {
                if (!window.noteCache[noteStub.id]) {
                    notesWereLoaded = true;
                    const noteRef = doc(db, "notes", noteStub.id);
                    return getDoc(noteRef).then(noteSnap => {
                        if (noteSnap.exists()) {
                            const fullNoteData = noteSnap.data();
                            window.noteCache[noteStub.id] = fullNoteData;

                            // --- THIS IS THE FIX ---
                            // 1. Generate an excerpt from the full content.
                            const plainText = (fullNoteData.content || '').replace(/<[^>]*>?/gm, ' ').trim();
                            const excerpt = plainText.substring(0, 200);
                            
                            // 2. Update the note stub in the main state with the new excerpt.
                            noteStub.excerpt = excerpt;
                            // --- END OF FIX ---
                        }
                    });
                }
                return Promise.resolve();
            });

            await Promise.all(fetchPromises);
            
            if (notesWereLoaded) {
                await saveState(); // Persist the new excerpts to the main state document
                buildLunrIndex();  // Rebuild the search index with all content
                render();          // Re-render the UI to show the new excerpts in lists
            }
            
            dismissToast(toastId);
            showToast(`✅ All ${allNoteStubs.length} notes loaded and indexed.`, 'success');

        } catch (error) {
            dismissToast(toastId);
            showToast('Error loading all notes.', 'error');
            console.error(error);
        }
    }
},
    { name: 'nf', description: 'New Folder. Usage: /nf [folder name]', execute: (args)=>{const n=args||'Untitled Folder';const c={id:generateId('c'),name:n,type:'folder',children:[],expanded:true};state.kanbanColumns[c.id]=[{id:generateId('col'),title:'To Do'}];state.collections.push(c);saveState();buildLunrIndex();render();showToast(`✅ Folder "${n}" created`)}},
{ name: 'rename', description: 'Rename item. Usage: /rename [old] to [new]', suggest: 'items', execute: async(args)=>{ const separator = /\s+to\s+/i; if (!separator.test(args)) return showToast('❌ Use: /rename [old] to [new]','error'); const parts = args.split(separator); const oldName = parts[0].trim(); const newName = parts[1].trim(); if (!oldName || !newName) return showToast('❌ Both names required.','error'); const itemToRenameCopy = findBestMatch(oldName, [...getAllNotes(state.collections), ...getAllFolders()]); if (!itemToRenameCopy) return showToast(`❌ Not found: "${oldName}"`,'error'); const findResult = findItem(itemToRenameCopy.id); if (!findResult || !findResult.item) { return showToast('❌ Could not locate the original item to rename.', 'error'); } const originalItem = findResult.item; const confirmed = await showConfirm({title:'Confirm Rename', message:`Rename "${originalItem.name}" to "${newName}"?`, confirmText:'Rename'}); if (confirmed) { const previousName = originalItem.name; originalItem.name = newName; try { if (originalItem.type === 'note') { const { doc, updateDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js"); const noteRef = doc(db, "notes", originalItem.id); await updateDoc(noteRef, { name: newName }); if (window.noteCache[originalItem.id]) { window.noteCache[originalItem.id].name = newName; } } await saveState(); buildLunrIndex(); render(); showToast(`✅ Renamed to "${newName}"`); } catch (error) { console.error("Error renaming item:", error); showToast('❌ A database error occurred. Rename failed.', 'error'); originalItem.name = previousName; } } } },    { name: 'link', description: 'Link notes. Usage: /link [source] to [target]', suggest: 'notes', execute: (args)=>{const s=/\s+to\s+/i;if(!s.test(args))return showToast('❌ Use: /link [source] to [target]','error');const p=args.split(s);const sN=p[0].trim();const tN=p[1].trim();if(!sN||!tN)return showToast('❌ Both notes required.','error');const aN=getAllNotes(state.collections);const sO=findBestMatch(sN,aN);const tO=findBestMatch(tN,aN);if(!sO)return showToast(`❌ Source not found: "${sN}"`,'error');if(!tO)return showToast(`❌ Target not found: "${tN}"`,'error');if(sO.id===tO.id)return showToast('❌ Cannot link a note to itself.','error');sO.content+=`\n<p>[[${tO.name}]]</p>`;updateNoteLinks(sO);sO.modifiedAt=new Date().toISOString();saveState();if(state.settings.activeNoteId===sO.id)renderNoteEditor();showToast(`✅ Linked "${sO.name}" to "${tO.name}"`)}},
    { name: 'unlink', description: 'Unlink notes. Usage: /unlink [target] from [source]', suggest: 'notes', execute: (args)=>{const s=/\s+from\s+/i;if(!s.test(args))return showToast('❌ Use: /unlink [target] from [source]','error');const p=args.split(s);const tN=p[0].trim();const sN=p[1].trim();if(!sN||!tN)return showToast('❌ Both notes required.','error');const aN=getAllNotes(state.collections);const sO=findBestMatch(sN,aN);const tO=findBestMatch(tN,aN);if(!sO)return showToast(`❌ Source not found: "${sN}"`,'error');if(!tO)return showToast(`❌ Target not found: "${tN}"`,'error');const r=new RegExp(`\\[\\[\\s*${tO.name}\\s*\\]\\]`,'gi');if(!r.test(sO.content))return showToast(`❌ Link to "${tO.name}" not found in "${sO.name}".`,'info');sO.content=sO.content.replace(r,'').replace(/<p>\s*<\/p>|\n\s*\n/gi,'');updateNoteLinks(sO);sO.modifiedAt=new Date().toISOString();saveState();if(state.settings.activeNoteId===sO.id)renderNoteEditor();showToast(`✅ Unlinked "${tO.name}" from "${sO.name}"`)}},
    { name: 'go', description: 'Go to item or tag. Usage: /go [item] or /go #[tag] [item]', suggest: 'items_or_tags', execute: (args)=>{if(!args)return showToast('❌ Specify item or tag.','error');if(args.startsWith('#')){const tN=args.split(' ')[0].substring(1).trim();const nN=args.substring(tN.length+2).trim();if(!tN)return showToast('❌ Tag name needed.','error');if(!getAllTags().includes(tN))return showToast(`❌ Tag not found: #${tN}`,'error');if(nN){const nT=getAllNotes(state.collections).filter(n=>(n.tags||[]).includes(tN));const t=findBestMatch(nN,nT);if(t){executeWithSmartFind(t.name,'notes',(i)=>{state.settings.activeTag=null;if(i.type==='note'){const{parent}=findItem(i.id);state.settings.activeCollectionId=(Array.isArray(parent)||!parent)?null:parent.id;state.settings.activeNoteId=i.id}showToast(`🚀 Navigated to "${i.name}"`);saveState();render()})}else{showToast(`❌ Note "${nN}" not in tag #${tN}.`,'error')}}else{state.settings.activeTag=tN;state.settings.activeNoteId=null;state.settings.activeCollectionId=null;showToast(`🏷️ Showing notes tagged with #${tN}`);saveState();render()}}else{executeWithSmartFind(args,'items',(i)=>{state.settings.activeTag=null;if(i.type==='note'){const{parent}=findItem(i.id);state.settings.activeCollectionId=(Array.isArray(parent)||!parent)?null:parent.id;state.settings.activeNoteId=i.id}else{state.settings.activeCollectionId=i.id;state.settings.activeNoteId=null}showToast(`🚀 Navigated to "${i.name}"`);saveState();render()})}} },
    { name: 'theme', description: 'Toggle through color themes.', execute: ()=>document.getElementById('theme-toggle')?.click() },
    // Add this object inside your commands array
{
    name: 'updatelinks',
    description: 'Scans all notes and fixes links pointing to renamed notes.',
    execute: updateAllLinksAgent
},
    { name: 'voice', description: 'Start/stop voice dictation in current note.', execute: ()=>{if(!state.settings.activeNoteId)return showToast('❌ Must be in a note.','error');document.getElementById('dictate-btn')?.click()} },
    { name: 'linked', description: 'Show all connections for a note. Usage: /linked [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args, 'notes', (note)=>renderLinkedNotesModal(note)) },
    { name: 'help', description: 'Shows this list of all available commands.', execute: renderHelpModal },
    { name: 'commands', description: 'Alias for /help.', execute: renderHelpModal },
    { name: 'calculator', description: 'Opens a draggable calculator.', execute: () => openModal(document.getElementById('calculator-modal')) },// Add this command object inside the `commands` array
{ 
    name: 'timer', 
    description: 'Opens a draggable timer and stopwatch.', 
    execute: () => openModal(document.getElementById('timer-modal')) 
},
    { name: 'ask', description: 'Ask Your Notes AI. Usage: /ask [question]', execute: (args)=>{if(!args)return showToast('❌ Question needed.','error');openModal(document.getElementById('global-ai-modal'));document.getElementById('global-ai-input').value=args;document.getElementById('global-ai-ask-btn').click();feather.replace()} },
    { name: 'summary', description: 'Summarize a note. Usage: /summary [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args,'notes',(n)=>{const c=(n.content||'').replace(/<[^>]*>?/gm,'').trim();if(!c)return showToast('Note empty.','info');handleSummarize(c)})},
    { name: 'quiz', description: 'Generate quiz. Usage: /quiz [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args,'notes',(n)=>{const c=(n.content||'').replace(/<[^>]*>?/gm,'').trim();if(!c)return showToast('Note empty.','info');handleGenerateQuiz(c,n)})},
    { name: 'flashcard', description: 'Open flashcards. Usage: /flashcard [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args,'notes',(n)=>handleFlashcardMode(n))},
    { name: 'share', description: 'Create share link. Usage: /share [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args,'notes',(noteStub)=>handleShareNote(noteStub))},
    {
    name: 'checkpoint',
    description: 'Save Note Version. Usage: /checkpoint [message]',
    execute: (args) => {
        const noteId = state.settings.activeNoteId;
        if (!noteId) {
            return showToast('❌ You must be in a note to save a checkpoint.', 'error');
        }
        if (!args) {
            return showToast('❌ A message is required for the checkpoint.', 'error');
        }
        
        // This ensures the very latest typed content is captured before versioning
        performImmediateSave(); 
        
        // FIX: Get note data from the global cache
        const noteData = window.noteCache[noteId];
        if (noteData) {
            saveNoteVersion(noteId, noteData.content, args);
            saveState();
            showToast(`✅ Checkpoint saved: "${args}"`, 'success');
        }
    }
},{
    name: 'list',
    description: 'Switch to list view. Usage: /list [folder name]',
    suggest: 'folders',
    execute: (args) => {
        const targetView = 'list';
        if (args) {
            const targetFolder = findBestMatch(args, getAllFolders());
            if (targetFolder) {
                state.settings.activeCollectionId = targetFolder.id;
                state.settings.activeNoteId = null;
                state.settings.activeView = targetView;
                saveState();
                render();
                showToast(`Showing List View for "${targetFolder.name}"`);
            } else {
                showToast(`❌ Folder not found: "${args}"`, 'error');
            }
        } else {
            let currentFolderId = state.settings.activeCollectionId;
            if (state.settings.activeNoteId) {
                const noteResult = findItem(state.settings.activeNoteId);
                const parent = noteResult ? noteResult.parent : null;
                if (parent && !Array.isArray(parent)) {
                    currentFolderId = parent.id;
                }
            }
            if (currentFolderId) {
                state.settings.activeCollectionId = currentFolderId;
                state.settings.activeNoteId = null;
                state.settings.activeView = targetView;
                saveState();
                render();
            } else {
                showToast('Please select a folder first.', 'info');
            }
        }
    }
},{
    name: 'add',
    suggest: 'checklists',
    description: 'Add to checklist. Usage: /add [checklist name] [item text]',
    execute: (args) => {
        const noteId = state.settings.activeNoteId;
        if (!noteId) {
            return showToast('❌ Must be in a note to add a checklist item.', 'error');
        }
        if (!args) {
            return showToast('❌ Usage: /add [checklist name] [item text]', 'error');
        }

        const editorBody = app.elements.noteEditorBody;
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = editorBody.innerHTML;

        const checklists = Array.from(tempDiv.querySelectorAll('.checklist-container'));
        if (checklists.length === 0) {
            return showToast('❌ No checklists found in this note.', 'info');
        }

        let targetChecklist = null;
        let itemText = '';

        const checklistData = checklists.map(cl => ({
            element: cl,
            title: cl.querySelector('.checklist-title')?.textContent.trim() || ''
        })).sort((a, b) => b.title.length - a.title.length);

        for (const data of checklistData) {
            if (data.title && args.toLowerCase().startsWith(data.title.toLowerCase())) {
                targetChecklist = data.element;
                itemText = args.substring(data.title.length).trim();
                break;
            }
        }

        if (!targetChecklist) {
            return showToast('❌ Could not find a checklist with that name.', 'error');
        }
        if (!itemText) {
            return showToast('❌ Please provide text for the checklist item.', 'error');
        }

        const checklistBody = targetChecklist.querySelector('.checklist-body');
        const newItem = document.createElement('li');
        newItem.className = 'checklist-item';
        newItem.dataset.checked = 'false';
        newItem.innerHTML = `
            <input type="checkbox" class="checklist-item-checkbox" onclick="return false;">
            <span class="checklist-item-text" contenteditable="false">${itemText.replace(/</g, "&lt;")}</span>
        `;
        checklistBody.appendChild(newItem);

        editorBody.innerHTML = tempDiv.innerHTML;

        const liveChecklistElement = Array.from(editorBody.querySelectorAll('.checklist-container')).find(
            el => el.querySelector('.checklist-title')?.textContent.trim() === targetChecklist.querySelector('.checklist-title')?.textContent.trim()
        );
        if (liveChecklistElement) {
            updateChecklistProgress(liveChecklistElement);
        }

        performImmediateSave();
        showToast(`✅ Added "${itemText}" to checklist.`);
    }
},{
    name: 'remove',
    suggest: 'checklist_items',
    description: 'Remove item from checklist. Usage: /remove [item name]',
    execute: (args) => {
        const noteId = state.settings.activeNoteId;
        if (!noteId) return showToast('❌ Must be in a note.', 'error');
        if (!args) return showToast('❌ Please specify an item to remove.', 'error');

        const editorBody = app.elements.noteEditorBody;
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = editorBody.innerHTML;

        const checklists = Array.from(tempDiv.querySelectorAll('.checklist-container'));
        if (checklists.length === 0) return showToast('❌ No checklists found.', 'info');

        // Attempt 1: Match as [Checklist Name] [Item Text] for explicit removal
        const checklistData = checklists.map(cl => ({
            element: cl,
            title: cl.querySelector('.checklist-title')?.textContent.trim() || ''
        })).sort((a, b) => b.title.length - a.title.length);

        for (const data of checklistData) {
            if (data.title && args.toLowerCase().startsWith(data.title.toLowerCase())) {
                const itemQuery = args.substring(data.title.length).trim();
                if (itemQuery) {
                    const items = Array.from(data.element.querySelectorAll('.checklist-item-text')).map(el => ({ text: el.textContent, element: el.parentElement }));
                    const fuse = new Fuse(items, { keys: ['text'], threshold: 0.3 });
                    const results = fuse.search(itemQuery);
                    if (results.length > 0) {
                        const itemToRemove = results[0].item.element;
                        const removedText = results[0].item.text;
                        itemToRemove.remove(); // Remove from the temporary element
                        editorBody.innerHTML = tempDiv.innerHTML; // Update the live editor

                        const liveEl = Array.from(editorBody.querySelectorAll('.checklist-container')).find(c => c.querySelector('.checklist-title')?.textContent.trim() === data.title);
                        if(liveEl) updateChecklistProgress(liveEl);

                        performImmediateSave();
                        return showToast(`✅ Removed "${removedText}" from "${data.title}".`);
                    }
                }
            }
        }

        // Attempt 2: If no explicit match, treat entire args as the item name
        const allItems = [];
        checklists.forEach(cl => {
            const title = cl.querySelector('.checklist-title')?.textContent.trim();
            cl.querySelectorAll('.checklist-item').forEach(itemEl => {
                allItems.push({
                    text: itemEl.querySelector('.checklist-item-text').textContent,
                    element: itemEl,
                    checklistTitle: title
                });
            });
        });

        const fuse = new Fuse(allItems, { keys: ['text'], includeScore: true, threshold: 0.3 });
        const potentialMatches = fuse.search(args).filter(res => res.score < 0.4); 

        if (potentialMatches.length === 0) {
            return showToast(`❌ Item not found: "${args}"`, 'error');
        }

        if (potentialMatches.length > 1) {
            const firstMatchText = potentialMatches[0].item.text;
            if (potentialMatches.every(res => res.item.text.toLowerCase() === firstMatchText.toLowerCase())) {
                return showToast(`❌ "${firstMatchText}" exists in multiple lists. Please specify the list name: /remove [list name] [item name]`, 'error');
            }
        }

        const bestMatch = potentialMatches[0].item;
        bestMatch.element.remove(); // Remove from the temporary element
        editorBody.innerHTML = tempDiv.innerHTML; // Update the live editor

        const liveChecklistElement = Array.from(editorBody.querySelectorAll('.checklist-container')).find(
            el => el.querySelector('.checklist-title')?.textContent.trim() === bestMatch.checklistTitle
        );
        if (liveChecklistElement) {
            updateChecklistProgress(liveChecklistElement);
        }

        performImmediateSave();
        showToast(`✅ Removed "${bestMatch.text}".`);
    }
},{
    name: 'save',
    description: 'Save a manual checkpoint of the current note',
    execute: () => {
        const noteId = state.settings.activeNoteId;
        if (!noteId) {
            return showToast('❌ You must be in a note to save a checkpoint.', 'error');
        }

        performImmediateSave(); // Ensure latest content is captured before versioning

        const note = window.noteCache[noteId];
        if (note) {
            const versions = state.versions?.[noteId] || [];
            const savedRegex = /^Saved(\s(\d+))?$/;
            let maxNum = -1; // -1 means "Saved" hasn't been used, 0 means only "Saved" has been used

            versions.forEach(v => {
                const match = v.message?.match(savedRegex);
                if (match) {
                    if (match[2]) { // If it's "Saved [number]" like "Saved 1"
                        const num = parseInt(match[2], 10);
                        if (num > maxNum) {
                            maxNum = num;
                        }
                    } else { // If it's just "Saved"
                        if (maxNum < 0) {
                           maxNum = 0;
                        }
                    }
                }
            });

            let message;
            if (maxNum === -1) {
                message = 'Saved';
            } else {
                message = `Saved ${maxNum + 1}`;
            }

            saveNoteVersion(note.id, note.content, message);
            saveState();
            showToast(`✅ Checkpoint saved: "${message}"`, 'success');
        }
    }
},{
    name: 'google',
    description: 'Search Google or Open a Website. Usage: /google [query]',
    execute: (args) => {
        if (!args) {
            return showToast('❌ Please provide a search query or a website.', 'error');
        }
        // Heuristic to detect if the argument is likely a website URL
        if (args.includes('.') && !args.includes(' ')) {
            let url = args;
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                url = 'https://' + url;
            }
            window.open(url, '_blank');
            showToast(`🚀 Opening ${args}...`);
        } else {
            // It's a search query
            const searchQuery = encodeURIComponent(args);
            const searchUrl = `https://www.google.com/search?q=${searchQuery}`;
            window.open(searchUrl, '_blank');
            showToast(`🔍 Searching Google for "${args}"...`);
        }
    }
},
{
    name: 'calendar',
    description: 'Switch to calendar view. Usage: /calendar [folder name]',
    suggest: 'folders',
    execute: (args) => {
        const targetView = 'calendar';
        if (args) {
            const targetFolder = findBestMatch(args, getAllFolders());
            if (targetFolder) {
                state.settings.activeCollectionId = targetFolder.id;
                state.settings.activeNoteId = null;
                state.settings.activeView = targetView;
                saveState();
                render();
                showToast(`Showing Calendar View for "${targetFolder.name}"`);
            } else {
                showToast(`❌ Folder not found: "${args}"`, 'error');
            }
        } else {
            let currentFolderId = state.settings.activeCollectionId;
            if (state.settings.activeNoteId) {
                const noteResult = findItem(state.settings.activeNoteId);
                const parent = noteResult ? noteResult.parent : null;
                if (parent && !Array.isArray(parent)) {
                    currentFolderId = parent.id;
                }
            }
            if (currentFolderId) {
                state.settings.activeCollectionId = currentFolderId;
                state.settings.activeNoteId = null;
                state.settings.activeView = targetView;
                saveState();
                render();
            } else {
                showToast('Please select a folder first.', 'info');
            }
        }
    }
},
{
    name: 'date',
    description: 'Set a date. Usage: /date [Property Name] DD/MM/YY',
    execute: (args) => {
        if (!state.settings.activeNoteId) {
            return showToast('❌ This command can only be used inside a note.', 'error');
        }

        const dateRegex = /^(.*)\s+(\d{1,2}\/\d{1,2}\/\d{2,4})$/;
        const match = args.match(dateRegex);

        if (!match) {
            return showToast('❌ Invalid format. Use: /date [Property Name] DD/MM/YY', 'error');
        }

        const propName = match[1].trim();
        const dateString = match[2];
        const dateParts = dateString.split('/');

        if (dateParts.length !== 3) {
             return showToast('❌ Invalid date format. Use DD/MM/YY.', 'error');
        }

        const day = parseInt(dateParts[0], 10);
        const month = parseInt(dateParts[1], 10);
        let year = parseInt(dateParts[2], 10);

        if (year < 100) {
            year += 2000;
        }

        if (isNaN(day) || isNaN(month) || isNaN(year)) {
             return showToast('❌ Invalid date value.', 'error');
        }

        const dateObj = new Date(Date.UTC(year, month - 1, day));
        
        if (isNaN(dateObj.getTime())) {
            return showToast('❌ Invalid date. Please check the day, month, and year.', 'error');
        }

        const note = findItem(state.settings.activeNoteId)?.item;
        if (note) {
            if (!note.properties) {
                note.properties = {};
            }
            note.properties[propName] = {
                type: 'date',
                value: dateObj.toISOString()
            };
            note.modifiedAt = new Date().toISOString();
            
            performImmediateSave();
            renderNoteProperties(note);
            feather.replace();
            showToast(`✅ Set date for "${propName}"`, 'success');
        }
    }
},
    {
        name: 'history',
        description: 'Open version history for a note. Usage: /history [note name]',
        suggest: 'notes',
        execute: (args) => {
            executeWithSmartFind(args, 'notes', (note) => {
                state.settings.activeNoteId = note.id;
                openVersionHistoryModal();
            });
        }
    },
    { name: 'dup', description: 'Duplicate an item. Usage: /dup [item name]', suggest: 'items', execute: (args)=>executeWithSmartFind(args,'items',(i)=>{const r=findItem(i.id);const nI=duplicateItem(i);const pA=Array.isArray(r.parent)?r.parent:r.parent.children;pA.splice(r.index+1,0,nI);showToast(`✅ Duplicated "${i.name}"`);saveState();buildLunrIndex();render()})},
    { name: 'pin', description: 'Toggle pin on a note. Usage: /pin [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args,'notes',(n)=>{n.pinned=!n.pinned;showToast(n.pinned?`📌 Pinned "${n.name}"`:`👎 Unpinned "${n.name}"`);saveState();render()})},
    { name: 'tag', description: 'Add a tag to current note. Usage: /tag [tagname]', execute: (args)=>{if(!state.settings.activeNoteId)return showToast('❌ Must be in a note.','error');if(!args)return showToast('❌ Tag name needed.','error');const tN=args.split(' ')[0].replace(/#/g,'');if(!tN)return;app.elements.noteEditorBody.innerHTML+=` #${tN}`;performImmediateSave();showToast(`🏷️ Tagged with #${tN}`)}},
    {
        name: 'clear',
        description: 'Clear all content from a note. Usage: /clear [note name]',
        suggest: 'notes',
        execute: (args) => executeWithSmartFind(args, 'notes', async (note) => {
            const confirmed = await showConfirm({
                title: `Clear Content of "${note.name}"`,
                message: 'This will permanently delete all content inside this note. This action cannot be undone.',
                confirmText: 'Clear Content',
                confirmClass: 'bg-red-600'
            });

            if (confirmed) {
                note.content = '';
                note.modifiedAt = new Date().toISOString();
                updateNoteLinks(note);
                updateNoteTags(note);
                
                saveState();
                buildLunrIndex();
                render();
                
                showToast(`✅ Content cleared from "${note.name}"`, 'success');
            }
        })
    },{
    name: 'notegraph',
    description: 'Show note graph. Usage: /notegraph [note name]',
    suggest: 'notes',
    execute: (args) => {
        executeWithSmartFind(args, 'notes', (note) => {
            // This reuses the same logic as the toolbar button
            const graphBtn = document.getElementById('graph-btn');
            if (graphBtn) {
                // Temporarily set the active note to the one we want to graph
                const originalActiveNote = state.settings.activeNoteId;
                state.settings.activeNoteId = note.id;
                graphBtn.click();
                // Restore the original active note so the UI doesn't jump
                state.settings.activeNoteId = originalActiveNote;
            }
        });
    }
},{
    name: 'checklist',
    description: 'Adds a new checklist. Usage: /checklist [Optional Title]',
    execute: (args) => {
        if (!state.settings.activeNoteId) {
            return showToast('❌ You must be in a note to add a checklist.', 'error');
        }

        const title = args ? args.replace(/</g, "&lt;") : 'Untitled Checklist';

        restoreSelectionAndExec(() => {
            const newDefaultChecklistHTML = `
<div class="checklist-container" contenteditable="false">
    <div class="checklist-header">
        <h4 class="checklist-title font-semibold text-text-primary flex-grow">${title}</h4>
        <button class="checklist-header-btn" data-action="edit" title="Edit Checklist"><i data-feather="edit" class="w-4 h-4"></i></button>
        <button class="checklist-header-btn delete" data-action="delete" title="Delete Checklist"><i data-feather="trash-2" class="w-4 h-4"></i></button>
    </div>
    <div class="checklist-progress-container">
        <div class="checklist-progress-bar">
            <div class="checklist-progress-fill" style="width: 0%;"></div>
        </div>
        <span class="checklist-progress-text">0% Complete</span>
    </div>
    <ul class="checklist-body">
        <li class="checklist-item" data-checked="false"><input type="checkbox" class="checklist-item-checkbox" onclick="return false;"><span class="checklist-item-text" contenteditable="false">New item</span></li>
    </ul>
</div>
<p><br></p>
`;
            document.execCommand('insertHTML', false, newDefaultChecklistHTML);
            feather.replace();
        });
        showToast('✅ Checklist added.');
    }
},// ... inside the 'commands' array
{
    name: 'move',
    description: 'Move a note to a folder. Usage: /move [note] to [folder]',
    suggest: 'items', // This will suggest both notes and folders
    execute: (args) => {
        const separator = /\s+to\s+/i;
        if (!separator.test(args)) {
            return showToast('❌ Invalid format. Use: /move [note name] to [folder name]', 'error');
        }

        const [noteName, folderName] = args.split(separator).map(s => s.trim());

        if (!noteName || !folderName) {
            return showToast('❌ Both a note and folder name are required.', 'error');
        }

        const allNotes = getAllNotes(state.collections);
        const allFolders = getAllFolders();

        const noteToMove = findBestMatch(noteName, allNotes);
        const targetFolder = findBestMatch(folderName, allFolders);

        if (!noteToMove) {
            return showToast(`❌ Note not found: "${noteName}"`, 'error');
        }
        if (!targetFolder) {
            return showToast(`❌ Target folder not found: "${folderName}"`, 'error');
        }

        // Find the note in the state tree to remove it from its current location
        const sourceResult = findItem(noteToMove.id);
        if (!sourceResult) return; // Should not happen, but a good safeguard

        const sourceArray = Array.isArray(sourceResult.parent) ? sourceResult.parent : sourceResult.parent.children;
        
        // Check if the note is already in the target folder
        if (sourceResult.parent && sourceResult.parent.id === targetFolder.id) {
            return showToast(`Note is already in "${targetFolder.name}".`, 'info');
        }

        // Remove the note from its original array
        const [movedNote] = sourceArray.splice(sourceResult.index, 1);

        // Add the note to the target folder's children array
        if (!targetFolder.children) {
            targetFolder.children = [];
        }
        targetFolder.children.unshift(movedNote);

        // Update the note's Kanban status to the first column of the new folder
        movedNote.status = state.kanbanColumns[targetFolder.id]?.[0]?.id || null;
        movedNote.modifiedAt = new Date().toISOString();

        // Save changes and update the UI
        saveState();
        buildLunrIndex();
        render();
        showToast(`✅ Moved "${movedNote.name}" to "${targetFolder.name}"`, 'success');
    }
},{
    name: 'table',
    description: 'Create a table. Usage: /table [rows]x[cols]. Defaults to 3x2.',
    execute: (args) => {
        if (!state.settings.activeNoteId) {
            return showToast('❌ You must be in a note to create a table.', 'error');
        }

        let rows = 3;
        let cols = 2;

        if (args) {
            const match = args.match(/(\d+)\s*x\s*(\d+)/i);
            if (match) {
                rows = parseInt(match[1], 10) || 3;
                cols = parseInt(match[2], 10) || 2;
            } else {
                 return showToast('❌ Invalid format. Use [rows]x[cols], e.g., 4x3.', 'error');
            }
        }
        
        if (rows > 50 || cols > 20) {
            return showToast('❌ Table size is too large (max 50x20).', 'error');
        }

        let tableHTML = '<table style="width:100%"><thead>';
tableHTML += `<tr><th colspan="${cols}" contenteditable="false"><div class="table-header-controls"><div class="table-filter-wrapper"><i data-feather="search" class="filter-icon"></i><input class="table-filter-input" placeholder="Filter table..."/></div><button class="toggle-filter-btn" title="Toggle Filter"><i data-feather="chevrons-up" class="w-4 h-4"></i></button></div></th></tr>`;
        tableHTML += '<tr>';
        for (let i = 0; i < cols; i++) {
            tableHTML += `<th class="sortable-header" data-sort-dir="none" contenteditable="true">Header ${i + 1}</th>`;
        }
        tableHTML += '</tr></thead><tbody>';
        for (let i = 0; i < rows; i++) {
            tableHTML += '<tr>';
            for (let j = 0; j < cols; j++) {
                tableHTML += '<td contenteditable="true"><br></td>';
            }
            tableHTML += '</tr>';
        }
        tableHTML += '</tbody></table><p><br></p>';

        restoreSelectionAndExec(() => document.execCommand('insertHTML', false, tableHTML));
        feather.replace();
        showToast(`✅ Table (${rows}x${cols}) created.`);
    }
},{
    name: 'recalculate',
    description: 'Usage: /recalculate [column name] or /recalculate for all.',
    suggest: 'none',
    execute: (args) => {
        const columnName = args ? args.trim() : null;

        const activeNoteId = state.settings.activeNoteId;
        if (!activeNoteId) {
            return showToast('❌ You must be in a note to use this command.', 'error');
        }

        const editorBody = app.elements.noteEditorBody;
        const table = editorBody.querySelector('table');

        if (!table) {
            return showToast('❌ No table found in the current note.', 'error');
        }

        // If a column name is provided, recalculate that specific column
        if (columnName) {
            const headers = Array.from(table.querySelectorAll('thead tr:last-child th'));
            let targetHeader = null;
            let targetColIndex = -1;

            for (let i = 0; i < headers.length; i++) {
                if (headers[i].innerText.trim().toLowerCase() === columnName.toLowerCase()) {
                    targetHeader = headers[i];
                    targetColIndex = i;
                    break;
                }
            }

            if (!targetHeader) {
                return showToast(`❌ Column "${columnName}" not found in the table.`, 'error');
            }

            const formula = targetHeader.dataset.formula;
            if (!formula) {
                return showToast(`❌ No custom formula is set for the "${columnName}" column.`, 'info');
            }

            performCustomFormula(table, targetColIndex, formula);
            showToast(`✅ Recalculated column "${columnName}".`, 'success');

        } else {
            // If no column name, recalculate all columns with a formula
            const headersWithFormulas = Array.from(table.querySelectorAll('thead tr:last-child th[data-formula]'));
            
            if (headersWithFormulas.length === 0) {
                return showToast('No columns with formulas found in this table.', 'info');
            }

            const allHeaders = Array.from(table.querySelectorAll('thead tr:last-child th'));

            headersWithFormulas.forEach(header => {
                const formula = header.dataset.formula;
                if (formula) {
                    const colIndex = allHeaders.indexOf(header);
                    if (colIndex > -1) {
                        performCustomFormula(table, colIndex, formula);
                    }
                }
            });

            showToast(`✅ Recalculated all ${headersWithFormulas.length} formula column(s).`, 'success');
        }
    }
},{
    name: 'recalc',
    description: 'Alias for /recalculate. Updates all table calculations.',
    execute: (args) => {
        // This just finds and runs the main /recalculate command's logic
        commands.find(c => c.name === 'recalculate').execute(args);
    }
},
{
    name: 'rc',
    description: 'Alias for /recalculate. Updates all table calculations.',
    execute: (args) => {
        // This also finds and runs the main /recalculate command's logic
        commands.find(c => c.name === 'recalculate').execute(args);
    }
},
// ... rest of the commands
    { name: 'dn', description: 'Delete a note. Usage: /dn [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args,'notes',async (n)=>{const r=findItem(n.id);const c=await showConfirm({title:`Delete "${n.name}"?`,message:'This cannot be undone.',confirmText:'Delete'});if(c){const pA=Array.isArray(r.parent)?r.parent:r.parent.children;pA.splice(r.index,1);showToast(`🗑️ Note deleted.`);if(state.settings.activeNoteId===n.id)state.settings.activeNoteId=null;saveState();buildLunrIndex();render()}})},
    { name: 'df', description: 'Delete folder. Usage: /df [folder name]', suggest: 'folders', execute: (args)=>executeWithSmartFind(args,'folders',async (f)=>{const r=findItem(f.id);const c=await showConfirm({title:`Delete folder "${f.name}"?`,message:'This will delete the folder and <strong>all notes inside</strong>.',confirmText:'Delete'});if(c){const pA=Array.isArray(r.parent)?r.parent:r.parent.children;pA.splice(r.index,1);showToast(`🗑️ Folder deleted.`);if(state.settings.activeCollectionId===f.id)state.settings.activeCollectionId=null;saveState();buildLunrIndex();render()}})},
// --- START: NEW RESEARCH AGENT COMMAND ---
{
    name: 'research',
    description: 'Research brief from multiple notes. Usage: /research [topic]',
    execute: (args) => {
        if (!args) {
            return showToast('❌ Please provide a research topic.', 'error');
        }
        // We will call the new agent function here
        researchAgent(args);
    }
},
// --- START: NEW MEETING ASSISTANT COMMAND ---
{
    name: 'process',
    description: 'Scans meeting notes to extract a summary and action items.',
    execute: (args) => {
        const noteId = state.settings.activeNoteId;
        if (!noteId) {
            return showToast('❌ You must be in a note to process it.', 'error');
        }
        // This will call our new agent function
        meetingAssistantAgent(noteId);
    }
}
// --- END: NEW MEETING ASSISTANT COMMAND ---
// --- END: NEW RESEARCH AGENT COMMAND ---
];

const openCommandPrompt = () => { if (document.activeElement === app.elements.noteEditorBody && window.getSelection().rangeCount > 0) {
        editorSelectionRange = window.getSelection().getRangeAt(0).cloneRange();
    }if(isCommandPromptOpen)return;isCommandPromptOpen=true;commandPromptContainer.classList.remove('hidden');commandInput.value='/';renderSuggestions('/');commandInput.focus();setTimeout(()=>commandInput.setSelectionRange(commandInput.value.length,commandInput.value.length),0) };
const closeCommandPrompt = () => { if(!isCommandPromptOpen)return;isCommandPromptOpen=false;commandPromptContainer.classList.add('hidden');commandSuggestionsContainer.classList.add('hidden');suggestionIndex=-1 };

const renderSuggestions = (rawInput) => {
    const input = rawInput.startsWith('/') ? rawInput.slice(1) : rawInput;
    const parts = input.split(' ');
    const commandName = parts[0];
    const argString = parts.slice(1).join(' ');
    const command = commands.find(c => c.name.toLowerCase() === commandName.toLowerCase());

    let suggestionsHTML = '';
    const argQuery = argString.toLowerCase();

    if (command && command.suggest) {
        let finalSuggestions = [];
        const toSeparator = /\s+to\s+/i;
        const fromSeparator = /\s+from\s+/i;

        if ((command.name === 'move' || command.name === 'rename' || command.name === 'link') && toSeparator.test(argString)) {
            const targetQuery = argString.split(toSeparator)[1].toLowerCase() || '';
            let itemsToSuggest = (command.suggest === 'notes') ? getAllNotes(state.collections) : [...getAllNotes(state.collections), ...getAllFolders()];
            if (command.name === 'move') itemsToSuggest = getAllFolders();
            const fuse = new Fuse(itemsToSuggest, { keys: ['name'], threshold: 0.5 });
            finalSuggestions = fuse.search(targetQuery).map(result => result.item);
        } else if (command.name === 'unlink' && fromSeparator.test(argString)) {
            const sourceQuery = argString.split(fromSeparator)[1].toLowerCase() || '';
            const fuse = new Fuse(getAllNotes(state.collections), { keys: ['name'], threshold: 0.5 });
            finalSuggestions = fuse.search(sourceQuery).map(result => result.item);
        } else { // This block now runs for any command with arguments
            const noteId = state.settings.activeNoteId;
            let editorChecklists = [];
            if (noteId) {
                editorChecklists = Array.from(app.elements.noteEditorBody.querySelectorAll('.checklist-container')).map(cl => ({
                    name: cl.querySelector('.checklist-title')?.textContent.trim() || '',
                    element: cl
                })).filter(c => c.name);
            }

            if (command.suggest === 'checklists') { // For /add
                if (editorChecklists.length > 0) {
                    const fuse = new Fuse(editorChecklists, { keys: ['name'], threshold: 0.5 });
                    finalSuggestions = fuse.search(argQuery).map(result => ({ ...result.item, type: 'checklist' }));
                }
            } else if (command.suggest === 'checklist_items') { // For /remove
                if (noteId && editorChecklists.length > 0) {
                    const allItems = [];
                    editorChecklists.forEach(cl => {
                        const items = Array.from(cl.element.querySelectorAll('.checklist-item-text'))
                            .map(itemEl => ({ 
                                name: itemEl.textContent, 
                                type: 'checklist_item',
                                context: `from: ${cl.name}` 
                            }));
                        allItems.push(...items);
                    });
                    const fuse = new Fuse(allItems, { keys: ['name'], threshold: 0.5 });
                    finalSuggestions = fuse.search(argQuery).map(result => result.item);
                }
            } else {
                let itemsToSearch = [];
                if (command.suggest.includes('items')) itemsToSearch = [...getAllNotes(state.collections), ...getAllFolders()];
                else if (command.suggest.includes('notes')) itemsToSearch = getAllNotes(state.collections);
                else if (command.suggest.includes('folders')) itemsToSearch = getAllFolders();
                else if (command.name === 'go' && argString.startsWith('#')) {
                    const tagQuery = argString.substring(1);
                    itemsToSearch = getAllTags().map(t => ({ id: t, name: t, type: 'tag' }));
                }
                if (itemsToSearch.length > 0) {
                    const fuse = new Fuse(itemsToSearch, { keys: ['name'], threshold: 0.5 });
                    finalSuggestions = fuse.search(argQuery).map(result => result.item);
                }
            }
        }

        if (finalSuggestions.length > 0) {
            suggestionsHTML = finalSuggestions.slice(0, 5).map((item, index) => {
                const isTag = item.type === 'tag';
                const dataAttribute = isTag ? `data-tag-name="#${item.name}"` : `data-item-name="${item.name.replace(/"/g, '&quot;')}"`;
                const icon = isTag ? 'hash' : (item.type === 'checklist' ? 'check-square' : (item.type === 'checklist_item' ? 'list' : (item.type === 'folder' ? 'folder' : 'file-text')));
                return `
                <div class="command-suggestion-item ${index === suggestionIndex ? 'active' : ''}" ${dataAttribute}>
                    <div class="flex items-center gap-2 min-w-0"> <i data-feather="${icon}" class="w-4 h-4 text-text-secondary flex-shrink-0"></i> <span class="cmd-name truncate">${item.name}</span> </div>
                    ${item.context ? `<span class="cmd-desc text-right truncate">${item.context}</span>` : ''}
                </div>`;
            }).join('');
        } else if (argString) {
            suggestionsHTML = `<div class="p-2 text-sm text-text-tertiary">No items match "${argString}"</div>`;
        }
    } else {
        const lowerCaseCommandName = commandName.toLowerCase();
        const filteredCommands = commands.filter(cmd => cmd.name.toLowerCase().startsWith(lowerCaseCommandName)).slice(0, 5);
        if (filteredCommands.length > 0) {
            suggestionsHTML = filteredCommands.map((cmd, index) => `
                <div class="command-suggestion-item ${index === suggestionIndex ? 'active' : ''}" data-command-name="${cmd.name}">
                    <div class="flex items-center gap-3"><span class="cmd-name">/${cmd.name}</span></div>
                    <span class="cmd-desc">${cmd.description}</span>
                </div>`).join('');
        }
    }

    if (suggestionsHTML) {
        commandSuggestionsContainer.innerHTML = suggestionsHTML;
        commandSuggestionsContainer.classList.remove('hidden');
        feather.replace();
    } else {
        commandSuggestionsContainer.classList.add('hidden');
    }
    suggestionIndex = -1;
};

const executeCommand = (inputValue) => {
    const cleanInput = inputValue.slice(1).trim();
    if (!cleanInput) { closeCommandPrompt(); return; }
    const parts = cleanInput.split(' ');
    const commandName = parts[0];
    const args = parts.slice(1).join(' ');
    // This comparison is now case-insensitive
    const command = commands.find(c => c.name.toLowerCase() === commandName.toLowerCase());
    if (command) command.execute(args);
    else showToast(`❌ Command not found: ${commandName}`, 'error');
    closeCommandPrompt();
};

document.addEventListener('keydown', (e) => {
// --- START: Modal Keyboard Shortcuts ---
const confirmModal = document.getElementById('confirm-modal');
const checklistModal = document.getElementById('checklist-edit-modal');

if (!confirmModal.classList.contains('hidden')) {
    if (e.key === 'Enter') {
        e.preventDefault();
        document.getElementById('confirm-confirm-btn').click();
    } else if (e.key === 'Escape') {
        e.preventDefault();
        document.getElementById('confirm-cancel-btn').click();
    }
    return; // Stop further keydown processing for this modal
}

if (!checklistModal.classList.contains('hidden')) {
    if (e.key === 'Enter') {
        // Only trigger save if not focused on a button, allowing keyboard navigation
        if (document.activeElement.tagName !== 'INPUT')  {
            e.preventDefault();
            document.getElementById('checklist-modal-save-btn').click();
        }
    } else if (e.key === 'Escape') {
        e.preventDefault();
        document.getElementById('checklist-modal-cancel-btn').click();
    }
    return; // Stop further keydown processing for this modal
}
// --- END: Modal Keyboard Shortcuts ---
    
    if ((e.metaKey || e.ctrlKey) && e.key === '/') { e.preventDefault(); isCommandPromptOpen ? closeCommandPrompt() : openCommandPrompt(); }
    if (!isCommandPromptOpen) {
        // --- START: Modal Keyboard Shortcuts ---
        const confirmModal = document.getElementById('confirm-modal');
        const checklistModal = document.getElementById('checklist-edit-modal');

        if (!confirmModal.classList.contains('hidden')) {
            if (e.key === 'Enter') {
                e.preventDefault();
                document.getElementById('confirm-confirm-btn').click();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                document.getElementById('confirm-cancel-btn').click();
            }
            return; 
        }

        if (!checklistModal.classList.contains('hidden')) {
            if (e.key === 'Enter') {
                if (document.activeElement.tagName !== 'INPUT') {
                    e.preventDefault();
                    document.getElementById('checklist-modal-save-btn').click();
                }
            } else if (e.key === 'Escape') {
                e.preventDefault();
                document.getElementById('checklist-modal-cancel-btn').click();
            }
            return; 
        }
        // --- END: Modal Keyboard Shortcuts ---
        return;
    }
    if (e.key === 'Escape') { e.preventDefault(); closeCommandPrompt(); return; }

    const activeSuggestion = commandSuggestionsContainer.querySelector('.command-suggestion-item.active');

    const completeAndExecute = (suggestionEl) => {
        const commandParts = commandInput.value.slice(1).split(' ');
        const commandName = commandParts[0];
        const argString = commandParts.slice(1).join(' ');
        const itemName = suggestionEl.dataset.itemName;
        const tagName = suggestionEl.dataset.tagName;
        const commandSuggestion = suggestionEl.dataset.commandName;

        let finalCommand;
        if (commandSuggestion) {
            finalCommand = `/${commandSuggestion}`;
        } else if (tagName) {
            finalCommand = `/go ${tagName}`;
        } else if (itemName) {
            const toSeparator = /\s+to\s+/i;
            const fromSeparator = /\s+from\s+/i;

            // --- START: FIX FOR MULTI-ARGUMENT COMMANDS ---
            if (commandName === 'add' || commandName === 'remove') {
                const noteId = state.settings.activeNoteId;
                let checklistNamePart = '';
                if (noteId) {
                    const editorChecklists = Array.from(app.elements.noteEditorBody.querySelectorAll('.checklist-container')).map(cl => cl.querySelector('.checklist-title')?.textContent.trim() || '').filter(Boolean).sort((a, b) => b.length - a.length);
                    for (const clName of editorChecklists) {
                        if (argString.toLowerCase().startsWith(clName.toLowerCase())) {
                            checklistNamePart = clName;
                            break;
                        }
                    }
                }
                finalCommand = `/${commandName} ${checklistNamePart} ${itemName}`;
            // --- END: FIX FOR MULTI-ARGUMENT COMMANDS ---
            } else if ((commandName === 'move' || commandName === 'link' || commandName === 'rename') && toSeparator.test(argString)) {
                finalCommand = `/${commandName} ${argString.split(toSeparator)[0]} to ${itemName}`;
            } else if (commandName === 'unlink' && fromSeparator.test(argString)) {
                finalCommand = `/${commandName} ${argString.split(fromSeparator)[0]} from ${itemName}`;
            } else if (commandName === 'go' && argString.startsWith('#')) {
                 const tagPart = argString.split(' ')[0];
                 finalCommand = `/go ${tagPart} ${itemName}`;
            }
            else {
                finalCommand = `/${commandName} ${itemName}`;
            }
        }
        executeCommand(finalCommand);
    };

    if (e.key === 'Enter') {
        e.preventDefault();
        if (activeSuggestion) {
            completeAndExecute(activeSuggestion);
        } else {
            executeCommand(commandInput.value);
        }
        return;
    }

    if (e.key === 'Tab') {
        e.preventDefault();
        const suggestionToUse = activeSuggestion || commandSuggestionsContainer.querySelector('.command-suggestion-item');
        if (suggestionToUse) {
            const commandName = commandInput.value.slice(1).split(' ')[0];
            const argString = commandInput.value.slice(1).substring(commandName.length).trim();
            const itemName = suggestionToUse.dataset.itemName;
            const tagName = suggestionToUse.dataset.tagName;
            const commandSuggestion = suggestionToUse.dataset.commandName;

            let completedValue = commandInput.value;
            if (commandSuggestion) {
                completedValue = `/${commandSuggestion} `;
            } else if (tagName) {
                completedValue = `/go ${tagName} `;
            } else if (itemName) {
                const toSeparator = /\s+to\s+/i;
                const fromSeparator = /\s+from\s+/i;

                // --- START: FIX FOR MULTI-ARGUMENT COMMANDS ---
                if (commandName === 'add' || commandName === 'remove') {
                    const noteId = state.settings.activeNoteId;
                    let checklistNamePart = '';
                    if (noteId) {
                        const editorChecklists = Array.from(app.elements.noteEditorBody.querySelectorAll('.checklist-container')).map(cl => cl.querySelector('.checklist-title')?.textContent.trim() || '').filter(Boolean).sort((a, b) => b.length - a.length);
                        for (const clName of editorChecklists) {
                            if (argString.toLowerCase().startsWith(clName.toLowerCase())) {
                                checklistNamePart = clName;
                                break;
                            }
                        }
                    }
                    if (checklistNamePart) {
                        completedValue = `/${commandName} ${checklistNamePart} ${itemName} `;
                    } else {
                        completedValue = `/${commandName} ${itemName} `;
                    }
                // --- END: FIX FOR MULTI-ARGUMENT COMMANDS ---
                } else if ((commandName === 'move' || commandName === 'link' || commandName === 'rename') && toSeparator.test(argString)) {
                    completedValue = `/${commandName} ${argString.split(toSeparator)[0]} to ${itemName} `;
                } else if (commandName === 'unlink' && fromSeparator.test(argString)) {
                    completedValue = `/${commandName} ${argString.split(fromSeparator)[0]} from ${itemName} `;
                } else if (commandName === 'go' && argString.startsWith('#')) {
                    completedValue = `/go ${argString.split(' ')[0]} ${itemName} `;
                } else if (commandName === 'move' || commandName === 'link' || commandName === 'rename') {
                     completedValue = `/${commandName} ${itemName} to `;
                } else if (commandName === 'unlink') {
                     completedValue = `/${commandName} ${itemName} from `;
                } else {
                    completedValue = `/${commandName} ${itemName} `;
                }
            }
            commandInput.value = completedValue;
            renderSuggestions(completedValue);
            const end = commandInput.value.length;
            commandInput.setSelectionRange(end, end);
        }
        return;
    }

    if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        e.preventDefault();
        const suggestions = Array.from(commandSuggestionsContainer.querySelectorAll('.command-suggestion-item'));
        if (suggestions.length === 0) return;
        if(activeSuggestion) activeSuggestion.classList.remove('active');
        const direction = e.key === 'ArrowDown' ? 1 : -1;
        suggestionIndex = (suggestionIndex + direction + suggestions.length) % suggestions.length;
        suggestions[suggestionIndex].classList.add('active');
    }
});

commandInput.addEventListener('input', () => { if (!commandInput.value.startsWith('/')) commandInput.value = '/'; renderSuggestions(commandInput.value); });
commandSuggestionsContainer.addEventListener('click', (e) => { const item = e.target.closest('.command-suggestion-item'); if(item){ const cmdName=commandInput.value.slice(1).split(' ')[0]; const argStr=commandInput.value.slice(1).substring(cmdName.length).trim(); let finalCmd; if(item.dataset.itemName){ const toSep=/\s+to\s+/i; const fromSep=/\s+from\s+/i; if((cmdName==='move'||cmdName==='link'||cmdName==='rename')&&toSep.test(argStr)){finalCmd=`/${cmdName} ${argStr.split(toSep)[0]} to ${item.dataset.itemName}`}else if(cmdName==='unlink'&&fromSep.test(argStr)){finalCmd=`/${cmdName} ${argStr.split(fromSep)[0]} from ${item.dataset.itemName}`}else if(cmdName==='go'&&argStr.startsWith('#')){finalCmd=`/${cmdName} ${argStr.split(' ')[0]} ${item.dataset.itemName}`}else{finalCmd=`/${cmdName} ${item.dataset.itemName}`}}else if(item.dataset.tagName){finalCmd=`/go ${item.dataset.tagName}`}else{finalCmd=`/${item.dataset.commandName}`}executeCommand(finalCmd)} });
document.addEventListener('click', (e) => { if (isCommandPromptOpen && !commandPromptContainer.contains(e.target)) closeCommandPrompt(); });

document.getElementById('help-close-btn').addEventListener('click', () => closeModal(document.getElementById('help-modal')));
document.getElementById('linked-notes-close-btn').addEventListener('click', () => closeModal(document.getElementById('linked-notes-modal')));
document.getElementById('linked-notes-modal').addEventListener('click', (e) => {
    const link = e.target.closest('.linked-note-jump');
    if (link) {
        e.preventDefault();
        const noteId = link.dataset.noteId;
        const noteName = findItem(noteId)?.item.name;
        if(noteName) {
            closeModal(document.getElementById('linked-notes-modal'));
            executeCommand(`/go ${noteName}`);
        }
    }
});
// --- END: SLASH COMMAND CONSOLE ---

// --- END: SLASH COMMAND CONSOLE ---

// --- END: SLASH COMMAND CONSOLE ---
// --- END: SLASH COMMAND CONSOLE ---

// --- END: SLASH COMMAND CONSOLE ---

// --- END: SLASH COMMAND CONSOLE ---
// --- Template Modal Listeners ---
// --- Manage Templates Modal Listeners ---
document.getElementById('manage-templates-btn').addEventListener('click', () => {
    closeModal(document.getElementById('template-modal'));
    renderManageTemplatesModal();
    openModal(document.getElementById('manage-templates-modal'));
});

document.getElementById('manage-templates-close-btn').addEventListener('click', () => {
    closeModal(document.getElementById('manage-templates-modal'));
});

document.getElementById('manage-templates-done-btn').addEventListener('click', () => {
    closeModal(document.getElementById('manage-templates-modal'));
});

document.getElementById('manage-template-list').addEventListener('click', (e) => {
    const templateId = e.target.closest('[data-template-id]')?.dataset.templateId;
    if (!templateId) return;

    if (e.target.closest('.manage-template-rename-btn')) {
        renameTemplate(templateId);
    } else if (e.target.closest('.manage-template-delete-btn')) {
        deleteTemplate(templateId);
    }
});
// --- Share Modal Listeners ---
document.getElementById('share-invite-btn').addEventListener('click', handleInviteCollaborator);
document.getElementById('share-email-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') handleInviteCollaborator();
});
document.getElementById('share-modal-close-btn').addEventListener('click', () => closeModal(document.getElementById('share-modal')));
document.getElementById('share-done-btn').addEventListener('click', () => closeModal(document.getElementById('share-modal')));

document.getElementById('share-collaborators-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('remove-collaborator-btn')) {
        const uid = e.target.dataset.uid;
        handleRemoveCollaborator(uid);
    }
});
document.getElementById('template-modal-close-btn').addEventListener('click', () => {
    closeModal(document.getElementById('template-modal'));
});

document.getElementById('template-list-container').addEventListener('click', (e) => {
    const item = e.target.closest('.template-item');
    if (item) {
        const templateId = item.dataset.templateId;
        const template = state.templates.find(t => t.id === templateId);
        if (template) {
            createNewNote(true, template);
            closeModal(document.getElementById('template-modal'));
        }
    }
});
                // --- Source Snippet Click Listener ---
document.getElementById('global-ai-modal').addEventListener('click', (e) => {
    const link = e.target.closest('.source-snippet-link');
    if (link) {
        e.preventDefault();
        const noteId = link.dataset.noteId;
        if (noteId) {
            // Logic to switch to the note
            state.settings.activeNoteId = noteId;
            const { parent } = findItem(noteId);
            state.settings.activeCollectionId = (Array.isArray(parent)) ? null : parent.id;
            state.settings.activeTag = null;
            saveState();
            render();
            // Close the modal
            closeModal(document.getElementById('global-ai-modal'));
        }
    }
});
                // --- Copy Button Listeners ---
// --- Copy Button Listeners ---
document.getElementById('summary-copy-btn').addEventListener('click', () => {
    const content = document.getElementById('summary-content').innerText;
    navigator.clipboard.writeText(content)
        .then(() => showToast('Summary copied!', 'success'))
        .catch(() => showToast('Failed to copy.', 'error'));
});

// This now uses the correct ID for the button in the "Ask Your Notes" modal footer
document.getElementById('global-ai-copy-btn-footer').addEventListener('click', () => {
    const content = document.getElementById('global-ai-answer').innerText;
    navigator.clipboard.writeText(content)
        .then(() => showToast('Answer copied!', 'success'))
        .catch(() => showToast('Failed to copy.', 'error'));
});
                // --- Global AI Q&A Listeners ---
const openGlobalAIModal = () => {
    // This now ONLY clears the input field, leaving the previous answer and sources visible.
    document.getElementById('global-ai-input').value = '';

    // It also resets the 'Ask' button so you can submit a new question.
    const askBtn = document.getElementById('global-ai-ask-btn');
    if (askBtn) {
        askBtn.disabled = false;
        askBtn.querySelector('span').textContent = 'Ask';
    }

    openModal(document.getElementById('global-ai-modal'));
    feather.replace();
};
document.getElementById('global-ai-btn').addEventListener('click', openGlobalAIModal); // Desktop button
document.getElementById('mobile-global-ai-btn').addEventListener('click', openGlobalAIModal); // Mobile button


document.getElementById('mobile-global-ai-btn').addEventListener('click', () => { // Mobile button
    document.getElementById('global-ai-input').value = '';
    document.getElementById('global-ai-answer-container').classList.add('hidden');
    openModal(document.getElementById('global-ai-modal'));
    feather.replace();
});

document.getElementById('global-ai-close-btn').addEventListener('click', () => {
    closeModal(document.getElementById('global-ai-modal'));
});

document.getElementById('global-ai-ask-btn').addEventListener('click', handleGlobalAIQuery);
                // --- Global AI Q&A Listeners ---
document.getElementById('global-ai-btn').addEventListener('click', () => {
    document.getElementById('global-ai-input').value = '';
    document.getElementById('global-ai-answer-container').classList.add('hidden');
    openModal(document.getElementById('global-ai-modal'));
    feather.replace();
});

document.getElementById('global-ai-close-btn').addEventListener('click', () => {
    closeModal(document.getElementById('global-ai-modal'));
});

document.getElementById('global-ai-ask-btn').addEventListener('click', handleGlobalAIQuery);
                if (hasInitialized) return;
                app.modals.apiKeyInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') app.modals.apiKeyConfirmBtn.click();
});

document.getElementById('global-ai-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleGlobalAIQuery();
    }
});

addPropertyModal.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        document.getElementById('create-property-btn').click();
    }
});

document.getElementById('checklist-edit-modal').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.target.matches('input[type="text"]')) {
        e.preventDefault();
        document.getElementById('checklist-modal-add-item-btn').click();
    }
});

document.getElementById('table-creator-modal').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        document.getElementById('table-create-btn').click();
    }
});
                // START: Mobile Header Restore Fix
app.elements.noteEditorBody.addEventListener('blur', () => {
    // On mobile, when the editor loses focus (e.g., keyboard dismissed), restore the main header.
    if (window.innerWidth < 768) {
        document.body.classList.remove('mobile-editor-active');
        document.getElementById('main-header')?.classList.remove('hidden');
        document.getElementById('mobile-sticky-toolbar')?.classList.add('hidden');
    }
});
// END: Mobile Header Restore Fix
// START: Mobile Header Hide on Edit Resume Fix
app.elements.noteEditorBody.addEventListener('focus', () => {
    // On mobile, when the editor regains focus, hide the main header and show the toolbar.
    if (window.innerWidth < 768) {
        document.body.classList.add('mobile-editor-active');
        document.getElementById('main-header')?.classList.add('hidden');
        document.getElementById('mobile-sticky-toolbar')?.classList.remove('hidden');
    }
});
// END: Mobile Header Hide on Edit Resume Fix
hasInitialized = true;
                
                // Add this inside the init() function
// Located inside the init() function
document.getElementById('chatbot-toggle-btn').addEventListener('click', () => {
    // Invert the boolean value
    state.settings.chatbotVisible = !state.settings.chatbotVisible;
    // Save the new state
    saveState();
    // Re-render the entire UI with the new state
    render();
});
document.getElementById('toggle-properties-btn').addEventListener('click', () => {
    state.settings.propertiesVisible = !state.settings.propertiesVisible;
    saveState();
    render();
});
                // --- START: Inline Toolbar Scroll Logic ---
const toolbarButtons = document.getElementById('inline-toolbar-buttons');
const scrollLeftBtn = document.getElementById('toolbar-scroll-left');
const scrollRightBtn = document.getElementById('toolbar-scroll-right');

const handleToolbarScroll = () => {
    scrollLeftBtn.addEventListener('click', () => {
        toolbarButtons.scrollLeft -= 70;
    });
    scrollRightBtn.addEventListener('click', () => {
        toolbarButtons.scrollLeft += 70;
    });
};

if (window.innerWidth < 768) {
    handleToolbarScroll();
}
// --- END: Inline Toolbar Scroll Logic ---
                // Add these listeners for the new table modal
document.getElementById('table-cancel-btn').addEventListener('click', () => {
    closeModal(document.getElementById('table-creator-modal'));
});
// This is the corrected event listener for the create button
// REPLACE THE OLD 'table-create-btn' LISTENER WITH THIS
// REPLACE THE OLD 'table-create-btn' LISTENER
// REPLACE 'table-create-btn' LISTENER
document.getElementById('table-create-btn').addEventListener('click', () => {
    const rows = parseInt(document.getElementById('table-rows').value) || 3;
    const cols = parseInt(document.getElementById('table-cols').value) || 2;

    let tableHTML = '<table style="width:100%"><thead>';
    // Add Filter Row with Icon
    tableHTML += `<tr><th colspan="${cols}" contenteditable="false"><div class="table-filter-wrapper"><i data-feather="search" class="filter-icon"></i><input class="table-filter-input" placeholder="Filter table..."/></div></th></tr>`;
    // Add Header Row
    tableHTML += '<tr>';
    for (let i = 0; i < cols; i++) {
        tableHTML += `<th class="sortable-header" data-sort-dir="none" contenteditable="true">Header ${i + 1}</th>`;
    }
    tableHTML += '</tr></thead><tbody>';
    // Add Data Rows
    for (let i = 0; i < rows; i++) {
        tableHTML += '<tr>';
        for (let j = 0; j < cols; j++) {
            tableHTML += '<td contenteditable="true"></td>';
        }
        tableHTML += '</tr>';
    }
    tableHTML += '</tbody></table><p><br></p>';

    restoreSelectionAndExec(() => document.execCommand('insertHTML', false, tableHTML));
    closeModal(document.getElementById('table-creator-modal'));
    feather.replace(); // This is important to render the new icon
});
                setupInNoteSearchListeners();

                
                // --- Logic for File Attachments ---
// --- Logic for File Attachments ---
const fileUploadInput = document.getElementById('file-upload-input');
const mobileAttachBtn = document.getElementById('mobile-attach-file-btn');
const desktopAttachBtn = document.getElementById('desktop-attach-file-btn');

const triggerFileUpload = () => fileUploadInput.click();

if (mobileAttachBtn) mobileAttachBtn.addEventListener('click', triggerFileUpload);
if (desktopAttachBtn) desktopAttachBtn.addEventListener('click', triggerFileUpload);
// --- Logic for Toolbar Toggle ---
const toggleToolbarBtn = document.getElementById('toggle-toolbar-btn');
const expandableButtons = document.getElementById('expandable-toolbar-buttons');
const toggleIcon = document.getElementById('toolbar-toggle-icon');

toggleToolbarBtn.addEventListener('click', () => {
    const isHidden = expandableButtons.classList.contains('hidden');
    if (isHidden) {
        expandableButtons.classList.remove('hidden');
        expandableButtons.classList.add('flex'); // Use flex to show the items
        toggleIcon.setAttribute('data-feather', 'chevron-left');
    } else {
        expandableButtons.classList.add('hidden');
        expandableButtons.classList.remove('flex');
        toggleIcon.setAttribute('data-feather', 'chevron-right');
    }
    feather.replace(); // This redraws the chevron icon
});
const titleTextarea = app.elements.noteEditorTitle;
                titleTextarea.addEventListener('input', () => {
                    titleTextarea.style.height = 'auto';
                    titleTextarea.style.height = (titleTextarea.scrollHeight) + 'px';
                });
// Add this new event listener for the Settings panel
                document.getElementById('toggle-settings-btn').addEventListener('click', () => {
                    const settingsContainer = document.getElementById('settings-list-container');
                    const settingsButton = document.getElementById('toggle-settings-btn');
                    settingsContainer.classList.toggle('collapsed');
                    settingsButton.classList.toggle('collapsed');
                    // You might want to save this state, similar to tagsCollapsed
                    // For now, it will reset on page load.
                    feather.replace();
                });
app.elements.toggleTagsBtn.addEventListener('click', () => {
    state.settings.tagsCollapsed = !state.settings.tagsCollapsed;
    saveState();
    renderTagsState();
    feather.replace(); // To ensure the icon animation is smooth
});
fileUploadInput.addEventListener('change', (e) => {
    const file = e.target.files[0];y
    if (file) {
        handleFileUpload(file);
    }
    // Reset the input so you can upload the same file again if needed
    e.target.value = '';
});
                document.getElementById('header-share-btn').addEventListener('click', () => handleShareNote());
                await loadState();
                buildLunrIndex();
                setupSharedNoteListener();
                setupInvitationListener();
                
                initSpeechRecognition();
                initClipper();
                initCalculator();
                initTimer()
                

                // Logic for the new AI buttons in the main header
const headerSummarizeBtn = document.getElementById('header-summarize-btn');
const headerQuizBtn = document.getElementById('header-quiz-btn');

const handleHeaderAIAction = (action) => {
    const noteId = state.settings.activeNoteId;
    // --- FIX STARTS HERE ---
    // Get the full note object from the cache instead of the sidebar stub.
    const note = window.noteCache[noteId] ? { id: noteId, ...window.noteCache[noteId] } : null;
    // --- FIX ENDS HERE ---

    if (note) {
        if (action === 'share') {
            handleShareNote(note);
            return;
        }

        const plainContent = (note.content || '').replace(/<[^>]*>?/gm, '').trim();
        if (plainContent) {
            if (action === 'summarize') {
                handleSummarize(plainContent);
            } else if (action === 'quiz') {
                handleGenerateQuiz(plainContent, note);
            } else if (action === 'flashcard') {
                handleFlashcardMode(note);
            }
        } else {
            showToast("Note is empty.", "info");
        }
    }
};

// --- START: Consolidated Header Action Listeners ---
document.getElementById('header-summarize-btn').addEventListener('click', () => handleHeaderAIAction('summarize'));
document.getElementById('header-quiz-btn').addEventListener('click', () => handleHeaderAIAction('quiz'));
document.getElementById('header-flashcard-btn').addEventListener('click', () => handleHeaderAIAction('flashcard'));

// This is the single, correct listener for the share button
document.getElementById('header-share-btn').addEventListener('click', () => handleHeaderAIAction('share')); 

// This handles the collaboration button
document.getElementById('header-collaborate-btn').addEventListener('click', openShareModal);
// --- START: Tap-to-Save Indicator Logic ---
document.getElementById('save-indicator').addEventListener('click', () => {
    if (isNoteDirty) {
        performImmediateSave();
        showToast('✅ Saved', 'success');
    }
});
// --- END: Tap-to-Save Indicator Logic ---
// --- END: Consolidated Header Action Listeners ---
                
                const renderer = new marked.Renderer();
                renderer.code = function(code, language) {
                    const validLang = language && hljs.getLanguage(language) ? language : 'plaintext';
                    const highlightedCode = hljs.highlight(code, { language: validLang, ignoreIllegals: true }).value;
                    return `
                        <div class="code-block-wrapper">
                            <div class="code-block-header">
                                <span class="lang-name">${validLang}</span>
                                <div class="flex items-center gap-2">
                                    <!-- THIS IS THE NEW EXIT BUTTON -->
                                    <button class="exit-code-btn" title="Exit Code Block">
                                        <i data-feather="arrow-down-left" class="w-4 h-4"></i>
                                        <span>Exit</span>
                                    </button>
                                    <button class="copy-code-btn" title="Copy Code">
                                        <i data-feather="copy" class="w-4 h-4"></i>
                                        <span>Copy</span>
                                    </button>
                                    <button class="delete-block-btn" title="Delete Block">
                                        <i data-feather="trash-2" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            <pre><code class="hljs language-${validLang}">${highlightedCode}</code></pre>
                        </div>
                    `;
                };

                marked.setOptions({
                    renderer: renderer,
                    gfm: true,
                    breaks: true,
                });

                

                app.elements.sortOrderSelect.value = state.settings.listSortOrder;
                
                app.elements.themeToggle.addEventListener('click', () => {
                    // ADD THIS NEW EVENT LISTENER for the profile dropdown
                const profileButton = document.getElementById('profile-button');
                const profileDropdown = document.getElementById('profile-dropdown');
                const signOutLink = document.getElementById('sign-out-link');

                if (profileButton && profileDropdown) {
                    profileButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevents the document click from firing immediately
                        profileDropdown.classList.toggle('hidden');
                    });
                }
                
                if(signOutLink) {
                    signOutLink.addEventListener('click', async (e) => {
                        e.preventDefault();
                        try {
                            await signOut(window.auth);
                            console.log('User signed out successfully.');
                            // onAuthStateChanged will handle hiding the app and showing the login form.
                        } catch (error) {
                            console.error('Sign out error:', error);
                            showToast('Error signing out.', 'error');
                        }
                    });
                }

                // Hides dropdown if you click anywhere else
                document.addEventListener('click', (e) => {
                    if (profileButton && !profileButton.contains(e.target) && profileDropdown && !profileDropdown.classList.contains('hidden')) {
                        profileDropdown.classList.add('hidden');
                    }
                });
                    const themes = ['reputify', 'light', 'dark'];
                    const currentThemeIndex = themes.indexOf(state.settings.theme);
                    state.settings.theme = themes[(currentThemeIndex + 1) % themes.length];
                    localStorage.setItem('codex-notes-theme', state.settings.theme); 
                    saveState();
                    renderTheme();
                    feather.replace();
                });
                
                app.elements.sidebarToggleBtn.addEventListener('click', () => {
                    state.settings.sidebarCollapsed = !state.settings.sidebarCollapsed;
                    saveState();
                    renderSidebarState();
                });
                
                app.elements.paneResizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    document.body.style.cursor = 'col-resize';
                    const startX = e.clientX;
                    const startWidth = app.elements.notesListPane.offsetWidth;
                    const doDrag = (e) => {
                        let newWidth = startWidth + e.clientX - startX;
                        newWidth = Math.max(240, Math.min(newWidth, 500)); 
                        app.elements.notesListPane.style.width = `${newWidth}px`;
                        app.elements.sidebarToggleBtn.style.left = `${newWidth}px`;
                    };
                    const stopDrag = () => {
                        document.body.style.cursor = 'default';
                        state.settings.paneWidth = app.elements.notesListPane.offsetWidth;
                        saveState();
                        document.removeEventListener('mousemove', doDrag);
                        document.removeEventListener('mouseup', stopDrag);
                    };
                    document.addEventListener('mousemove', doDrag);
                    document.addEventListener('mouseup', stopDrag);
                });

                // =================================================================
// START: REPLACEMENT JAVASCRIPT FOR NEW MOBILE MENU
// =================================================================

// Get references to our new menu elements
const notionMenu = document.getElementById('notion-style-mobile-menu');
const notionMenuContent = document.getElementById('notion-menu-content');
const notionMenuCloseBtn = document.getElementById('mobile-menu-close-btn');

/**
 * Dynamically builds the content for our new Notion-style menu.
 */
// REPLACE the entire renderNotionStyleMenu function
// =================================================================
// START: CORRECTED JAVASCRIPT FOR FOLDER NAVIGATION
// =================================================================

/**
 * Dynamically builds the content for our new Notion-style menu.
 */
// =================================================================
// START: REPLACEMENT FUNCTION
// =================================================================
const renderNotionStyleMenu = () => {
    const user = window.auth.currentUser;
    if (user && user.email) {
        document.getElementById('menu-user-initial').textContent = user.email.charAt(0).toUpperCase();
        document.getElementById('menu-user-email').textContent = user.email;
        document.getElementById('dropdown-user-email-display').textContent = user.email;
    }
    const allNotes = getAllNotes(state.collections);
    const recentNotes = [...allNotes]
        .sort((a, b) => new Date(b.modifiedAt) - new Date(a.modifiedAt))
        .slice(0, 5);
    let jumpBackHTML = '';
    if (recentNotes.length > 0) {
        jumpBackHTML = `
            <h3 class="notion-menu-section-header">Jump back in</h3>
            <div class="jump-back-in-grid">
                ${recentNotes.map(note => `
                    <a href="#" class="recent-note-card" data-id="${note.id}" data-action="navigate-note">
                        <i data-feather="file-text" class="w-5 h-5"></i>
                        <span class="note-name">${note.name}</span>
                    </a>
                `).join('')}
            </div>`;
    }

    const buildPrivateList = (collections = state.collections, level = 0, parentId = null) => {
        return collections.map(item => {
            const isFolder = item.type === 'folder';
            
            // --- THIS IS THE NEW, MORE RELIABLE HTML STRUCTURE ---
            let itemHTML = `
                <li data-id="${item.id}" class="collection-item-wrapper rounded-md">
                    <div class="collection-item flex items-center justify-between gap-2 p-2 rounded-md hover:bg-bg-pane-dark" style="padding-left: ${8 + level * 16}px;">
                        
                        <div class="flex items-center gap-2 flex-grow min-w-0">
                            ${isFolder ? `<a href="#" class="expander-btn -ml-1 p-1" data-action="toggle-expand"><i data-feather="chevron-right" class="chevron w-4 h-4 flex-shrink-0 text-text-tertiary ${item.expanded ? 'open' : ''}"></i></a>` : '<div class="w-6 h-6 flex-shrink-0"></div>'}
                            <a href="#" class="flex items-center gap-2 flex-grow min-w-0" data-action="${isFolder ? 'navigate-folder' : 'navigate-note'}">
                                <i data-feather="${isFolder ? 'folder' : 'file-text'}" class="w-4 h-4 flex-shrink-0 text-text-secondary"></i>
                                <span class="truncate">${item.name}</span>
                            </a>
                        </div>

                        <button class="add-note-btn" data-action="add-note-here" data-parent-id="${isFolder ? item.id : parentId}" title="Add New Note Here">
                            <i data-feather="plus" class="w-4 h-4"></i>
                        </button>

                    </div>`;

            if (isFolder && item.expanded && item.children && item.children.length > 0) {
                itemHTML += `<ul class="collection-children">${buildPrivateList(item.children, level + 1, item.id)}</ul>`;
            } else if (isFolder && item.expanded) {
                itemHTML += `<p class="pl-12 py-1 text-sm text-text-tertiary">No notes inside</p>`;
            }
            itemHTML += `</li>`;
            return itemHTML;
        }).join('');
    };

    document.getElementById('jump-back-in-section').innerHTML = jumpBackHTML;
    document.getElementById('private-section').innerHTML = `
        <h3 class="notion-menu-section-header">All Notes</h3>
        <ul class="space-y-1">${buildPrivateList()}</ul>
    `;
    feather.replace();
};
// =================================================================
// END: REPLACEMENT FUNCTION
// =================================================================

// --- THIS IS THE CORRECTED CLICK HANDLER FOR THE MENU ---
// REPLACE your current notionMenu 'click' listener with this one


// =================================================================
// END: CORRECTED JAVASCRIPT
// =================================================================
/**
 * Opens the new mobile menu.
 */
const openNotionStyleMenu = () => {
    renderNotionStyleMenu(); // Build the content just before showing
    notionMenu.classList.add('open');
};

/**
 * Closes the new mobile menu.
 */
const closeNotionStyleMenu = () => {
    notionMenu.classList.remove('open');
};
// =================================================================
// START: NEW MOBILE SETTINGS POPUP JAVASCRIPT
// =================================================================
const settingsPopup = document.getElementById('mobile-settings-popup');

/**
 * Opens and populates the mobile settings view.
 */
const openMobileSettingsPopup = () => {
    // 1. Update Theme Button state
    const currentTheme = state.settings.theme;
    const themeIcon = document.getElementById('mobile-theme-icon');
    const themeText = document.getElementById('mobile-theme-text');
    if (currentTheme === 'dark') {
        themeIcon.setAttribute('data-feather', 'moon');
        themeText.textContent = 'Dark Theme';
    } else if (currentTheme === 'reputify') {
        themeIcon.setAttribute('data-feather', 'star');
        themeText.textContent = 'Reputify Theme';
    } else {
        themeIcon.setAttribute('data-feather', 'sun');
        themeText.textContent = 'Light Theme';
    }

    // 2. Update Toggle Switch states
    const chatbotToggle = document.querySelector('.toggle-switch[data-setting="chatbotVisible"]');
    chatbotToggle.classList.toggle('active', state.settings.chatbotVisible);

    const propertiesToggle = document.querySelector('.toggle-switch[data-setting="propertiesVisible"]');
    // The logic is inverted for "Hide Properties", so we check for NOT visible
    propertiesToggle.classList.toggle('active', !state.settings.propertiesVisible);

    // 3. Render icons and show the popup
    feather.replace();
    settingsPopup.classList.add('open');
};

/**
 * Closes the mobile settings view.
 */
const closeMobileSettingsPopup = () => {
    settingsPopup.classList.remove('open');
};
// =================================================================
// START: NEW MOBILE TAGS POPUP JAVASCRIPT
// =================================================================
const tagsPopup = document.getElementById('mobile-tags-popup');

/**
 * Opens and populates the mobile tags view.
 */
const openMobileTagsPopup = () => {
    const tagsContent = document.getElementById('mobile-tags-content');
    // Re-use the HTML from the original desktop tags list for consistency
    const originalTagsHTML = app.containers.tagList.innerHTML;
    tagsContent.innerHTML = `<div class="p-2 space-y-1">${originalTagsHTML}</div>`;
    
    feather.replace();
    tagsPopup.classList.add('open');
};

/**
 * Closes the mobile tags view.
 */
const closeMobileTagsPopup = () => {
    tagsPopup.classList.remove('open');
};

// --- Event Listeners for the new Tags Popup ---

// Listener to open the popup from the main menu footer
document.getElementById('mobile-menu-tags-btn').addEventListener('click', openMobileTagsPopup);

// Listener for the back button inside the popup
document.getElementById('mobile-tags-back-btn').addEventListener('click', closeMobileTagsPopup);

// Listener to handle clicking a tag inside the new popup
document.getElementById('mobile-tags-content').addEventListener('click', (e) => {
    const tagItem = e.target.closest('.tag-filter-item');
    if (tagItem) {
        e.preventDefault();
        const tagName = tagItem.dataset.tag;
        // Simulate a click on the original tag to reuse existing logic
        const originalTag = app.containers.tagList.querySelector(`[data-tag="${tagName}"]`);
        if (originalTag) {
            originalTag.click();
        }
        // Close both the tags popup and the main menu to show the results
        closeMobileTagsPopup();
        closeNotionStyleMenu();
    }
});
// =================================================================
// END: NEW MOBILE TAGS POPUP JAVASCRIPT
// =================================================================
// --- Event Listeners for the new Settings Popup ---

// Listener to open the popup from the main menu footer
document.getElementById('mobile-menu-settings-btn').addEventListener('click', openMobileSettingsPopup);

// Listener for the back button inside the popup
document.getElementById('mobile-settings-back-btn').addEventListener('click', closeMobileSettingsPopup);

// Listener for all buttons inside the settings content area
document.getElementById('mobile-settings-content').addEventListener('click', (e) => {
    const button = e.target.closest('button');
    if (button) {
        // --- Re-use existing logic from the desktop sidebar ---
        if (button.id === 'mobile-theme-toggle') {
            document.getElementById('theme-toggle').click();
            // Re-render the popup to reflect the new theme name
            openMobileSettingsPopup(); 
        } else if (button.id === 'mobile-bookmarklet-btn') {
            document.getElementById('bookmarklet-info-btn').click();
        } else {
            const action = button.dataset.action;
            if (action) {
                // For Import/Export, find the original button by its data-action and click it
                document.querySelector(`#settings-panel button[data-action="${action}"]`)?.click();
            }
        }
    }

    // --- Handle clicks on the toggle switches ---
    const toggle = e.target.closest('.toggle-switch');
    if (toggle) {
        const settingKey = toggle.dataset.setting;
        if (settingKey === 'chatbotVisible') {
            state.settings.chatbotVisible = !state.settings.chatbotVisible;
            toggle.classList.toggle('active', state.settings.chatbotVisible);
        } else if (settingKey === 'propertiesVisible') {
            // "Hide Properties" is an inverted toggle
            state.settings.propertiesVisible = !state.settings.propertiesVisible;
            toggle.classList.toggle('active', !state.settings.propertiesVisible);
        }
        saveState();
        render(); // Re-render main app to show/hide elements
    }
});
// =================================================================
// END: NEW MOBILE SETTINGS POPUP JAVASCRIPT
// =================================================================
// --- EVENT LISTENERS ---
// ADD ALL THIS NEW JAVASCRIPT CODE

// --- Profile Dropdown Logic ---
const profileActivator = document.getElementById('mobile-menu-profile-activator');
const profileDropdown = document.getElementById('mobile-profile-dropdown');
const mobileSignOutLink = document.getElementById('mobile-sign-out-link');

profileActivator.addEventListener('click', (e) => {
    e.stopPropagation();
    profileDropdown.classList.toggle('hidden');
    if (!profileDropdown.classList.contains('hidden')) {
        feather.replace(); // Re-render icon if shown
    }
});

// Use the existing sign-out link in the main app to avoid duplicating logic
mobileSignOutLink.addEventListener('click', (e) => {
    e.preventDefault();
    document.getElementById('sign-out-link').click();
});

// --- New Footer Button Logic ---
document.getElementById('mobile-menu-add-folder-btn').addEventListener('click', () => {
    // This re-uses the existing new collection logic from the main app!
    app.elements.newCollectionBtn.click();
    closeNotionStyleMenu(); // Close menu after action
});




// --- Click handler for the whole menu needs to be updated for view-switcher ---
// REPLACE your current notionMenu 'click' listener with this one
// REPLACE your current notionMenu 'click' listener with this one
notionMenu.addEventListener('click', (e) => {
    // Find the closest element that has a data-action attribute
    const target = e.target.closest('[data-action]');
    if (!target) return;

    e.preventDefault();
    const action = target.dataset.action;
    
    // --- Priority 1: Handle the 'Add Note' action ---
    if (action === 'add-note-here') {
        const parentId = target.dataset.parentId === 'null' ? null : target.dataset.parentId;
        const newNote = createNewNote(false, '', parentId); // Create the note but don't switch view
        renderNotionStyleMenu(); // Re-render the menu to show the new note
        showToast(`Note "${newNote.name}" created!`, 'success');
        return; // Stop processing further actions
    }

    // --- Priority 2: Handle all other actions like navigation or expanding a folder ---
    const listItem = target.closest('.collection-item-wrapper, .recent-note-card');
    if (!listItem) return;

    const id = listItem.dataset.id;
    const { item } = findItem(id);
    if (!item) return;

    switch (action) {
        case 'mobile-new-from-template':
    openTemplateModal();
    break;
        case 'mobile-save-as-template':
    saveAsTemplate(note);
    break;
        case 'toggle-expand':
            if (item.type === 'folder') {
                item.expanded = !item.expanded;
                renderNotionStyleMenu(); // Only re-render the menu
            }
            break;
        case 'navigate-folder':
            state.settings.activeCollectionId = item.id;
            state.settings.activeNoteId = null;
            state.settings.activeTag = null;
            closeNotionStyleMenu(); // Close menu and render main app
            render();
            break;
        case 'navigate-note':
            state.settings.activeNoteId = item.id;
            const result = findItem(item.id);
            state.settings.activeCollectionId = (Array.isArray(result.parent)) ? null : result.parent.id;
            state.settings.activeTag = null;
            closeNotionStyleMenu(); // Close menu and render main app
            render();
            break;
    }
    
    saveState();
});

// Add a global click listener to close the profile dropdown when clicking away
document.addEventListener('click', (e) => {
    if (!profileActivator.contains(e.target) && !profileDropdown.classList.contains('hidden')) {
        profileDropdown.classList.add('hidden');
    }
});
// 1. DELINK the old function and LINK the new one to the main menu button.
app.elements.mobileMenuBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    openNotionStyleMenu(); // This now opens our new menu
});

// 2. Listener for the new close button.
notionMenuCloseBtn.addEventListener('click', closeNotionStyleMenu);

// 3. Listener to handle clicks inside the new menu (for navigation).
// REPLACE your current notionMenu 'click' listener with this one

// (The original toggleMobileSidebar and its overlay listener are no longer needed and have been removed)

// =================================================================
// END: REPLACEMENT JAVASCRIPT
// =================================================================
                
                app.elements.mobileMenuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleMobileSidebar(true);
                });
                
                app.elements.mobileSidebarOverlay.addEventListener('click', () => toggleMobileSidebar(false));
                // --- START: New Mobile Menu Logic ---
const mobileMenu = document.getElementById('mobile-menu-fullscreen');
const mobileMenuContent = document.getElementById('mobile-menu-fullscreen-content');
const mobileMenuCloseBtn = document.getElementById('mobile-menu-fullscreen-close-btn');

const openMobileMenu = () => {
    // 1. Get the content from the original (now hidden) dropdown
    const originalContent = app.containers.mobileControlsDropdown.innerHTML;
    
    // 2. Populate the new fullscreen menu with that content
    mobileMenuContent.innerHTML = originalContent;
    
    // 3. Open the fullscreen menu with animation
    mobileMenu.classList.add('open');
    
    // 4. Hide the mobile toolbar
    document.getElementById('mobile-sticky-toolbar')?.classList.add('hidden');

    feather.replace(); // Ensure icons are rendered
};

const closeMobileMenu = () => {
    mobileMenu.classList.remove('open');
    
    // Show the mobile toolbar again ONLY if a note is active
    if (state.settings.activeNoteId) {
        document.getElementById('mobile-sticky-toolbar')?.classList.remove('hidden');
    }
};

// Open menu when the "more" button is clicked
app.elements.mobileMoreButton.addEventListener('click', (e) => {
    e.stopPropagation();
    openMobileMenu();
});

// Close menu with the 'X' button
mobileMenuCloseBtn.addEventListener('click', closeMobileMenu);

// Close menu when an action button inside is clicked
mobileMenuContent.addEventListener('click', (e) => {
    const button = e.target.closest('button');
if (button) {
    // Find the corresponding button in the original dropdown and click it
    const originalButton = app.containers.mobileControlsDropdown.querySelector(`[data-action="${button.dataset.action}"]`);
    if (originalButton) {
        originalButton.click();
    }
    // Also handle view switchers
    const viewButton = app.containers.mobileControlsDropdown.querySelector(`[data-view="${button.dataset.view}"]`);
    if (viewButton) {
        viewButton.click();
    }
    
    closeMobileMenu();
}
});
// --- END: New Mobile Menu Logic ---
                // REPLACE the existing event listener with this one
// REPLACE the existing event listener with this one
app.containers.collectionsList.addEventListener('click', async (e) => {
    // First, check if the new plus button was clicked
    const addBtn = e.target.closest('.add-note-btn');
    if (addBtn) {
        e.preventDefault();
        e.stopPropagation(); // This stops the click from also navigating to the note/folder

        const parentId = addBtn.dataset.parentId === 'null' ? null : addBtn.dataset.parentId;
        createNewNote(true, '', parentId); 
        return; // Action is done, so we stop here
    }

    // If the plus button wasn't clicked, run the original navigation logic
    const itemLink = e.target.closest('.collection-item-link');
    if (!itemLink) return;

    e.preventDefault();

    const wrapper = itemLink.closest('.collection-item-wrapper');
    const id = wrapper.dataset.id;
    const { item } = findItem(id);

    state.settings.activeTag = null; // Deactivate tag filter

    if (item.type === 'folder') {
        if (window.innerWidth < 768) {
            state.settings.activeView = 'list';
        }
        state.settings.activeCollectionId = id;
        state.settings.activeNoteId = null;
        item.expanded = !item.expanded;
    } else if (item.type === 'note') {
        // ---💾 THIS IS THE FIX ---
        // It now works because the function is async
        if (isNoteDirty && state.settings.activeNoteId !== id) {
            await performImmediateSave();
        }
        // ---💾 END OF FIX ---

        state.settings.activeNoteId = id;
        const result = findItem(id);
        const parent = result.parent;
        state.settings.activeCollectionId = (Array.isArray(parent)) ? null : parent.id;
        if (window.innerWidth < 768) {
            toggleMobileSidebar(false);
        }
    }
    saveState();
    render();
});
                
                app.containers.tagList.addEventListener('click', e => {
                    e.preventDefault();
                    const tagItem = e.target.closest('.tag-filter-item');
                    if (!tagItem) return;

                    const tagName = tagItem.dataset.tag;
                    if (state.settings.activeTag === tagName) {
                        state.settings.activeTag = null; // Toggle off
                    } else {
                        state.settings.activeTag = tagName;
                    }

                    state.settings.activeNoteId = null;
                    state.settings.activeCollectionId = null;
                    saveState();
                    render();
                });

                let draggedItemId = null;
                app.containers.collectionsList.addEventListener('dragstart', (e) => {
                    const wrapper = e.target.closest('.collection-item-wrapper');
                    if(wrapper) {
                        draggedItemId = wrapper.dataset.id;
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', draggedItemId);
                        setTimeout(() => wrapper.classList.add('opacity-50'), 0);
                    }
                });

                app.containers.collectionsList.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    document.querySelectorAll('.drop-target-folder').forEach(el => el.classList.remove('drop-target-folder'));
                    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());

                    const targetWrapper = e.target.closest('.collection-item-wrapper');
                    if (!targetWrapper || targetWrapper.dataset.id === draggedItemId) return;
                    
                    const { item: targetItem } = findItem(targetWrapper.dataset.id);
                    const indicator = document.createElement('div');
                    indicator.className = 'drop-indicator';

                    if (targetItem.type === 'folder') {
                        targetWrapper.querySelector('.collection-item').classList.add('drop-target-folder');
                    }
                    
                    const rect = targetWrapper.getBoundingClientRect();
                    const isAfter = e.clientY > rect.top + rect.height / 2;
                    targetWrapper.insertAdjacentElement(isAfter ? 'afterend' : 'beforebegin', indicator);
                });
                
                app.containers.collectionsList.addEventListener('dragend', (e) => {
                    document.querySelectorAll('.collection-item-wrapper.opacity-50').forEach(el => el.classList.remove('opacity-50'));
                     document.querySelectorAll('.drop-indicator, .drop-target-folder').forEach(el => {
                        el.classList.remove('drop-target-folder');
                        if (el.classList.contains('drop-indicator')) el.remove();
                    });
                    draggedItemId = null;
                });

                app.containers.collectionsList.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const droppedOnElement = e.target;
                    if (!draggedItemId) return;

                    document.querySelectorAll('.drop-indicator, .drop-target-folder').forEach(el => {
                        el.classList.remove('drop-target-folder');
                        if (el.classList.contains('drop-indicator')) el.remove();
                    });

                    const dragResult = findItem(draggedItemId);
                    if (!dragResult) return;
                    
                    const sourceArray = Array.isArray(dragResult.parent) ? dragResult.parent : dragResult.parent.children;
                    const [draggedItem] = sourceArray.splice(dragResult.index, 1);
                    
                    const dropWrapper = droppedOnElement.closest('.collection-item-wrapper');
                    
                    if (dropWrapper) { 
                        const dropId = dropWrapper.dataset.id;
                        if (dropId === draggedItem.id) { 
                            sourceArray.splice(dragResult.index, 0, draggedItem);
                            return;
                        }
                        
                        const dropResult = findItem(dropId);
                        if (!dropResult) return; 
                        
                        const dropTargetIsFolder = dropResult.item.type === 'folder' && droppedOnElement.closest('.collection-item').classList.contains('drop-target-folder');

                        if (dropTargetIsFolder) {
                            if (!dropResult.item.children) dropResult.item.children = [];
                            dropResult.item.children.unshift(draggedItem);
                            dropResult.item.expanded = true;
                        } else {
                            const targetArray = Array.isArray(dropResult.parent) ? dropResult.parent : dropResult.parent.children;
                            let targetIndex = dropResult.index;
                            
                            const rect = dropWrapper.getBoundingClientRect();
                            const isAfter = e.clientY > rect.top + rect.height / 2;
                            if (isAfter) targetIndex++;

                            targetArray.splice(targetIndex, 0, draggedItem);
                        }
                    } else { 
                        state.collections.push(draggedItem);
                    }
                    
                    if (draggedItem.type === 'note') {
                         const newParentResult = findItem(draggedItem.id);
                         const newParent = newParentResult ? newParentResult.parent : null;
                         const newParentId = newParent && !Array.isArray(newParent) ? newParent.id : null;
                         const newProjectColumns = newParentId ? state.kanbanColumns[newParentId] : null;
                         if (newProjectColumns && newProjectColumns.length > 0) {
                             draggedItem.status = newProjectColumns[0].id;
                         } else {
                             draggedItem.status = null;
                         }
                    }

                    saveState();
                    render();
                });

                app.containers.kanbanBoard.addEventListener('click', async e => {
                    const addBtn = e.target.closest('#add-column-btn');
                    const renameBtn = e.target.closest('.rename-column-btn');
                    const deleteBtn = e.target.closest('.delete-column-btn');

                    const collectionId = state.settings.activeCollectionId;
                    if (!collectionId) return;

                    if (addBtn) {
                        const newName = await showPrompt({ title: 'New Column', message: 'Enter a name for the new column:', placeholder: 'e.g. Done' });
                        if (newName) {
                            if(!state.kanbanColumns[collectionId]) state.kanbanColumns[collectionId] = [];
                            state.kanbanColumns[collectionId].push({ id: generateId('col'), title: newName });
                            saveState();
                            render();
                        }
                    } else if (renameBtn) {
                        const columnEl = renameBtn.closest('.kanban-column');
                        const columnId = columnEl.dataset.columnId;
                        const column = state.kanbanColumns[collectionId].find(c => c.id === columnId);
                        const newName = await showPrompt({ title: 'Rename Column', message: `Enter a new name for "${column.title}":`, initialValue: column.title });
                        if(newName) {
                            column.title = newName;
                            saveState();
                            render();
                        }
                    } else if (deleteBtn) {
                        const columnEl = deleteBtn.closest('.kanban-column');
                        const columnId = columnEl.dataset.columnId;
                        const confirmed = await showConfirm({ title: 'Delete Column', message: 'Are you sure you want to delete this column? Notes inside will be moved to the first column.', confirmText: 'Delete' });
                        if (confirmed) {
                            const columns = state.kanbanColumns[collectionId];
                            const columnIndex = columns.findIndex(c => c.id === columnId);
                            const notesToMove = findItem(collectionId).item.children.filter(n => n.status === columnId);
                            
                            columns.splice(columnIndex, 1);

                            if(columns.length > 0) {
                                notesToMove.forEach(n => n.status = columns[0].id);
                            } else {
                                notesToMove.forEach(n => n.status = null);
                            }

                            saveState();
                            render();
                        }
                    }
                });
                
                let draggedKanbanNoteId = null;
                app.containers.kanbanBoard.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('kanban-card')) {
                        draggedKanbanNoteId = e.target.dataset.noteId;
                        e.dataTransfer.setData('text/plain', draggedKanbanNoteId);
                        setTimeout(() => e.target.classList.add('dragging'), 0);
                    }
                });

                app.containers.kanbanBoard.addEventListener('dragend', (e) => {
                    if (e.target.classList.contains('kanban-card')) {
                        e.target.classList.remove('dragging');
                    }
                    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
                    draggedKanbanNoteId = null;
                });

                app.containers.kanbanBoard.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const column = e.target.closest('.kanban-column');
                    if (column) {
                        document.querySelectorAll('.drop-indicator').forEach(el => el.remove());

                        const cardsContainer = column.querySelector('.cards-container');
                        const afterElement = [...cardsContainer.querySelectorAll('.kanban-card:not(.dragging)')].reduce((closest, child) => {
                            const box = child.getBoundingClientRect();
                            const offset = e.clientY - box.top - box.height / 2;
                            if (offset < 0 && offset > closest.offset) {
                                return { offset: offset, element: child };
                            } else {
                                return closest;
                            }
                        }, { offset: Number.NEGATIVE_INFINITY }).element;
                        
                        const indicator = document.createElement('div');
                        indicator.className = 'drop-indicator';

                        if (afterElement == null) {
                            cardsContainer.appendChild(indicator);
                        } else {
                            cardsContainer.insertBefore(indicator, afterElement);
                        }
                    }
                });
                
                app.containers.kanbanBoard.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const columnEl = e.target.closest('.kanban-column');
                    if (columnEl && draggedKanbanNoteId) {
                        const newColumnId = columnEl.dataset.columnId;
                        const collectionId = state.settings.activeCollectionId;
                        const collectionResult = findItem(collectionId);
                        const collectionNotes = collectionResult.item.children;

                        const dragResult = findItem(draggedKanbanNoteId);
                        const [draggedNote] = collectionNotes.splice(collectionNotes.indexOf(dragResult.item), 1);
                        draggedNote.status = newColumnId;
                        
                        const dropIndicator = columnEl.querySelector('.drop-indicator');
                        if (dropIndicator) {
                            const nextCard = dropIndicator.nextElementSibling;
                            if (nextCard) {
                                const nextNoteId = nextCard.dataset.noteId;
                                const nextNote = findItem(nextNoteId).item;
                                const targetIndex = collectionNotes.indexOf(nextNote);
                                collectionNotes.splice(targetIndex, 0, draggedNote);
                            } else {
                                collectionNotes.push(draggedNote);
                            }
                            dropIndicator.remove();
                        } else {
                            collectionNotes.push(draggedNote);
                        }
                        
                        saveState();
                        renderKanbanView();
                        feather.replace();
                    }
                });
                
                app.elements.viewSwitcher.addEventListener('click', (e) => {
                    const button = e.target.closest('.view-btn');
                    if(button && !button.classList.contains('active')) {
                        state.settings.activeView = button.dataset.view;
                        saveState();
                        renderMainView();
                        feather.replace();
                    }
                });

                // Located inside the init() function
app.containers.mobileControlsDropdown.addEventListener('click', async (e) => {
    
    const button = e.target.closest('button');
    if (!button) return;

    const closeDropdown = () => {
        const dropdown = app.containers.mobileControlsDropdown;
        dropdown.classList.add('scale-95', 'opacity-0');
        setTimeout(() => dropdown.classList.add('hidden'), 100);
    };

    const action = button.dataset.action;
    const noteId = state.settings.activeNoteId;
    
    // START: Actions that DON'T need an active note
    if (action === 'mobile-new-note') {
        closeDropdown();
        createNewNote();
        return;
    }
    if (action === 'mobile-new-from-template') {
        closeDropdown();
        openTemplateModal();
        return;
    }
    if (action === 'mobile-delete-folder') {
        closeDropdown();
        const collectionId = state.settings.activeCollectionId;
        if (!collectionId) return;

        const { item: folder, parent, index } = findItem(collectionId);
        if (!folder) return;

        const parentArray = Array.isArray(parent) ? parent : parent.children;

        const confirmed = await showConfirm({
            title: `Delete Folder "${folder.name}"`,
            message: 'This will delete the folder and <strong>all notes inside it</strong>. This action cannot be undone.',
            confirmText: 'Delete'
        });

        if (confirmed) {
            parentArray.splice(index, 1);
            showToast(`Folder "${folder.name}" deleted.`, 'success');
            state.settings.activeCollectionId = null;
            state.settings.activeNoteId = null;
            saveState();
            buildLunrIndex();
            render();
        }
        return;
    }
    if (action === 'mobile-rename-folder') {
        closeDropdown();
        const collectionId = state.settings.activeCollectionId;
        if (!collectionId) return;

        const { item: folder } = findItem(collectionId);
        if (!folder) return;

        const newName = await showPrompt({
            title: 'Rename Folder',
            message: `Enter a new name for "${folder.name}":`,
            initialValue: folder.name
        });

        if (newName && newName !== folder.name) {
            folder.name = newName;
            saveState();
            buildLunrIndex();
            render();
            showToast(`Folder renamed to "${newName}"`, 'success');
        }
        return;
    }
    // END: Actions that DON'T need an active note


    // Handle all actions that require an active note
    if (action && noteId) {
        closeDropdown(); // Close menu immediately after an action is clicked
        const { item: note, parent, index } = findItem(noteId);
        if (!note) return;

        const parentArray = Array.isArray(parent) ? parent : parent.children;
        const plainContent = (note.content || '').replace(/<[^>]*>?/gm, '').trim();

        switch (action) {
            case 'mobile-summarize':
                handleSummarize(plainContent);
                break;
            case 'mobile-quiz':
                handleGenerateQuiz(plainContent, note);
                break;
            case 'mobile-flashcard':
                handleFlashcardMode(note);
                break;
            case 'mobile-save-as-template': // ADDED THIS CASE
                saveAsTemplate(note);
                break;
            case 'mobile-rename':
                const newName = await showPrompt({ title: 'Rename', message: `Enter a new name for "${note.name}":`, initialValue: note.name });
                if (newName) {
                    note.name = newName;
                    saveState();
                    buildLunrIndex();
                    render();
                }
                break;
            case 'mobile-duplicate':
                const newItem = duplicateItem(note);
                parentArray.splice(index + 1, 0, newItem);
                showToast(`Duplicated "${note.name}"`);
                saveState();
                buildLunrIndex();
                render();
                break;
            case 'mobile-pin':
                note.pinned = !note.pinned;
                showToast(note.pinned ? `Pinned "${note.name}"` : `Unpinned "${note.name}"`);
                saveState();
                render();
                break;
            case 'mobile-delete':
                const confirmed = await showConfirm({ title: `Delete "${note.name}"`, message: 'This action cannot be undone.', confirmText: 'Delete' });
                if (confirmed) {
                    parentArray.splice(index, 1);
                    showToast(`"${note.name}" deleted.`);
                    state.settings.activeNoteId = null;
                    saveState();
                    buildLunrIndex();
                    render();
                }
                break;
            case 'mobile-history':
                openVersionHistoryModal();
                break;
            case 'mobile-checkpoint':
    const message = await showPrompt({
        title: 'Save Checkpoint',
        message: 'Add a short message to describe this version:',
        placeholder: 'e.g., Final draft before review'
    });
    if (message) {
        performImmediateSave(); // Ensure latest content is captured
        // FIX: Get the full note data from the global cache, which includes the content.
        const currentNote = window.noteCache[noteId];
        if (currentNote) {
            // FIX: Pass the correct properties to the save function.
            saveNoteVersion(noteId, currentNote.content, message);
            saveState();
            showToast('✅ Checkpoint saved!', 'success');
        }
    }
    break;
            case 'mobile-share':
                handleShareNote();
                break;
            case 'mobile-upload':
                document.getElementById('file-upload-input').click();
                break;
            case 'mobile-collaborate':
                openShareModal();
                break;
            case 'mobile-add-checklist':
                restoreSelectionAndExec(() => {
                    const newDefaultChecklistHTML = `
<div class="checklist-container" contenteditable="false">
    <div class="checklist-header">
        <h4 class="checklist-title font-semibold text-text-primary flex-grow">Untitled Checklist</h4>
        <button class="checklist-header-btn" data-action="edit" title="Edit Checklist"><i data-feather="edit" class="w-4 h-4"></i></button>
        <button class="checklist-header-btn delete" data-action="delete" title="Delete Checklist"><i data-feather="trash-2" class="w-4 h-4"></i></button>
    </div>
    <div class="checklist-progress-container">
        <div class="checklist-progress-bar">
            <div class="checklist-progress-fill" style="width: 0%;"></div>
        </div>
        <span class="checklist-progress-text">0% Complete</span>
    </div>
    <ul class="checklist-body">
        <li class="checklist-item" data-checked="false"><input type="checkbox" class="checklist-item-checkbox" onclick="return false;"><span class="checklist-item-text" contenteditable="false">New item</span></li>
    </ul>
</div>
<p><br></p>
`;
                    document.execCommand('insertHTML', false, newDefaultChecklistHTML);
                    feather.replace();
                });
                break;
        }
    } 
    // Handle view switching, which doesn't need an active note
    else if (button.classList.contains('view-btn-mobile')) {
        state.settings.activeView = button.dataset.view;
        saveState();
        renderMainView();
        renderMobileControls();
    }
});
                
                app.containers.mainContentArea.addEventListener('click', (e) => {
    const exitBtn = e.target.closest('.exit-code-btn');
    if (exitBtn) {
        const wrapper = exitBtn.closest('.code-block-wrapper');
        if (wrapper) {
            const newP = document.createElement('p');
            newP.innerHTML = '<br>';
            wrapper.after(newP);

            const selection = window.getSelection();
            const range = document.createRange();
            range.setStart(newP, 0);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);

            saveNoteContent();
        }
        return;
    }
    const backlink = e.target.closest('.backlink-item');
    if (backlink) {
        e.preventDefault();
        state.settings.activeNoteId = backlink.dataset.noteId;
        saveState();
        render();
        if (window.innerWidth < 768) {
            toggleMobileSidebar(false);
        }
        return;
    }

    const deleteBlockBtn = e.target.closest('.delete-block-btn');
    if (deleteBlockBtn) {
        const wrapper = deleteBlockBtn.closest('.code-block-wrapper');
        if (wrapper) {
            const parentEditor = wrapper.parentNode;
            const wasLastElement = (wrapper.nextElementSibling === null);

            const nextEl = wrapper.nextElementSibling;
            if (nextEl && nextEl.tagName === 'P' && (nextEl.innerHTML === '<br>' || nextEl.innerHTML === '')) {
                nextEl.remove();
            }

            wrapper.remove();

            if (wasLastElement) {
                const newP = document.createElement('p');
                newP.innerHTML = '<br>';
                parentEditor.appendChild(newP);
                const selection = window.getSelection();
                const range = document.createRange();
                range.setStart(newP, 0);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
            }

            saveNoteContent();
            showToast('Code block deleted', 'info');
        }
        return;
    }

    // --- FIX STARTS HERE FOR SUMMARIZE/QUIZ BUTTONS ---
    const summarizeBtn = e.target.closest('.summarize-btn');
    if (summarizeBtn) {
        e.preventDefault();
        e.stopPropagation();
        const noteId = summarizeBtn.dataset.noteId;
        const noteData = window.noteCache[noteId]; // Get full data from cache
        const plainContent = (noteData?.content || '').replace(/<[^>]*>?/gm, '').trim();
        if (!plainContent) {
            showToast("Note is empty, nothing to summarize.", "info");
            return;
        }
        handleSummarize(plainContent);
        return;
    }
    const quizBtn = e.target.closest('.quiz-btn');
    if (quizBtn) {
        e.preventDefault();
        e.stopPropagation();
        const noteId = quizBtn.dataset.noteId;
        const noteData = window.noteCache[noteId]; // Get full data from cache
        const note = noteData ? { id: noteId, ...noteData } : null; // Reconstruct note object for the handler
        const plainContent = (noteData?.content || '').replace(/<[^>]*>?/gm, '').trim();
        if (!plainContent) {
            showToast("Note is empty, cannot generate a quiz.", "info");
            return;
        }
        handleGenerateQuiz(plainContent, note);
        return;
    }
    // --- FIX ENDS HERE ---

    const copyBtn = e.target.closest('.copy-code-btn');
    if (copyBtn) {
         const codeBlock = copyBtn.closest('.code-block-wrapper, .hljs').querySelector('pre, code');
         if(codeBlock) {
            const code = codeBlock.innerText;
            navigator.clipboard.writeText(code)
                .then(() => showToast('Code copied!', 'success'))
                .catch(err => showToast('Failed to copy code', 'error'));
         }
        return;
    }

    const card = e.target.closest('.kanban-card, .list-note-item, .search-result-item');
    if (card) {
        if (isSearchActive && card.classList.contains('search-result-item')) {
            state.settings.searchHighlightQuery = app.search.input.value;
            closeSearch(true);
        }
        state.settings.activeNoteId = card.dataset.noteId;
        const { parent } = findItem(state.settings.activeNoteId);
        state.settings.activeCollectionId = (Array.isArray(parent)) ? null : parent.id;
        state.settings.activeTag = null;
        saveState();
        render();
        return;
    }

    const internalLink = e.target.closest('a.internal-link');
    if (internalLink) {
        e.preventDefault();
        const noteId = internalLink.dataset.noteId;
        if(noteId) {
            state.settings.activeNoteId = noteId;
            const { parent } = findItem(noteId);
            state.settings.activeCollectionId = (Array.isArray(parent)) ? null : parent.id;
            state.settings.activeTag = null;
            saveState();
            render();
            showToast(`Mapsd to "${internalLink.textContent}"`);
            if (window.innerWidth < 768) {
                toggleMobileSidebar(false);
            }
        }
        return;
    }

    const link = e.target.closest('a');
    if (link && link.href && (app.elements.noteEditorBody.contains(link) || app.elements.markdownPreview.contains(link))) {
        e.preventDefault();
        window.open(link.href, '_blank');
    }
});
                // This is the core save logic
                // This listener handles checklist state changes reliably
app.elements.noteEditorBody.addEventListener('change', (e) => {
    if (e.target.matches('.task-list-item input[type="checkbox"]')) {
        const item = e.target.closest('.task-list-item');
        if (item) {
            item.classList.toggle('checked', e.target.checked);
            if (e.target.checked) {
                e.target.setAttribute('checked', 'true');
            } else {
                e.target.removeAttribute('checked');
            }
            saveNoteContent();
        }
    }
});
// =================================================================
// START: REPLACEMENT saveNoteContent FUNCTION (FOR COLLABORATION)
// =================================================================
// notetakeapp.html

// =================================================================
// START: REPLACEMENT performImmediateSave FUNCTION
// =================================================================
performImmediateSave = async () => {
    const noteId = state.settings.activeNoteId;
    if (!noteId) return;

    const user = window.auth.currentUser;
    if (!user) return;

    const noteStub = findItem(noteId)?.item;
    const noteContent = window.noteCache[noteId];
    if (!noteStub || !noteContent) return;

    const newName = app.elements.noteEditorTitle.value;
    const newContent = app.elements.noteEditorBody.innerHTML;

    if (noteContent.name === newName && activeNoteCleanCopy === newContent) {
        return;
    }

    // --- START: ADDED EXCERPT LOGIC ---
    // Generate a 200-character plain text excerpt for search and previews
    const plainText = newContent.replace(/<[^>]*>?/gm, ' ').trim();
    const excerpt = plainText.substring(0, 200);
    // --- END: ADDED EXCERPT LOGIC ---

    const nameChanged = noteStub.name !== newName;

    // Save the excerpt to the note's "stub" in the main state
    noteStub.name = newName;
    noteStub.excerpt = excerpt;

    // Save the excerpt to the full note data in the cache
    noteContent.name = newName;
    noteContent.content = newContent;
    noteContent.excerpt = excerpt;
    noteContent.modifiedAt = new Date().toISOString();

    updateNoteLinks(noteContent);
    updateNoteTags(noteContent);

    if (nameChanged) {
        renderCollectionsList();
    }

    try {
        // This logic now saves the excerpt to the full note document in Firestore
        if (user.uid === noteContent.ownerId) {
            const { doc, updateDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
            const noteRef = doc(db, "notes", noteId);

            await updateDoc(noteRef, {
                name: newName,
                content: newContent,
                excerpt: excerpt, // ADDED
                modifiedAt: noteContent.modifiedAt,
                links: noteContent.links,
                tags: noteContent.tags
            });
        } else {
            const { httpsCallable } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-functions.js");
            const updateNote = httpsCallable(window.functions, 'updateNoteAsCollaborator');
            
            await updateNote({
                noteId: noteId,
                newName: newName,
                newContent: newContent,
                newExcerpt: excerpt, // ADDED
                newLinks: noteContent.links,
                newTags: noteContent.tags,
                modifiedAt: noteContent.modifiedAt
            });
        }
        
        activeNoteCleanCopy = newContent;
        isNoteDirty = false;
        updateSaveIndicator();

        scheduleRebuildIndex();

    } catch (error) {
        console.error("Failed to save note:", error);
        showToast("Error saving note. " + (error.message || ''), 'error');
    }
};
// =================================================================
// END: REPLACEMENT performImmediateSave FUNCTION
// =================================================================
// Find Here If Broken
// This re-introduces the debounced function that was missing
saveNoteContent = debounce(performImmediateSave, 5000);
// =================================================================
// END: REPLACEMENT saveNoteContent FUNCTION
// =================================================================
// This is the single, correct 'input' listener for the note editor
app.elements.noteEditorBody.addEventListener('input', () => {
    if (!isNoteDirty) {
        isNoteDirty = true;
        // Show the 'unsaved' dot immediately on the first change
        updateSaveIndicator();
    }
    // Trigger the debounced functions for saving and updating stats
    saveNoteContent();
    updateStatsDebounced();
});
                app.elements.noteEditorBody.addEventListener('input', () => {
                    saveNoteContent();
                    updateStatsDebounced();
                });

                // REPLACE your entire existing 'noteEditorBody' keydown listener with this one
app.elements.noteEditorBody.addEventListener('keydown', (e) => {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    const range = selection.getRangeAt(0);
    let container = range.startContainer;
    const node = container.nodeType === 3 ? container.parentNode : container;

    // --- START: Generalized Ctrl+Enter Escape Logic ---
    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        let elementToEscape = node.closest('.code-block-wrapper, blockquote, table, .task-list-item');
        if (!elementToEscape) {
            const inlineCode = node.closest('code:not(pre code)');
            if (inlineCode) {
                elementToEscape = inlineCode.closest('p, div, li');
            }
        }
        if (elementToEscape) {
            e.preventDefault();
            const newP = document.createElement('p');
            newP.innerHTML = '<br>';
            elementToEscape.after(newP);
            const newRange = document.createRange();
            newRange.setStart(newP, 0);
            selection.removeAllRanges();
            selection.addRange(newRange);
            saveNoteContent();
            return;
        }
    }
    // --- END: Generalized Ctrl+Enter Escape Logic ---

    // --- START: NEW, ROBUST Checklist 'Enter' and 'Backspace' Logic ---
    
    // --- END: NEW, ROBUST Checklist 'Enter' and 'Backspace' Logic ---

    // ... (the rest of the keydown logic for blockquotes, code blocks, etc. remains the same)
    if (e.key === 'Enter' && !e.shiftKey) {
        const currentBlock = node.closest('p, div');
        if (currentBlock) {
            const blockquote = currentBlock.closest('blockquote');
            if (blockquote && currentBlock.textContent.trim() === '' && (currentBlock.innerHTML === '' || currentBlock.innerHTML === '<br>')) {
                e.preventDefault();
                const newP = document.createElement('p');
                newP.innerHTML = '<br>';
                blockquote.after(newP);
                currentBlock.remove();
                if (blockquote.textContent.trim() === '') blockquote.remove();
                const newRange = document.createRange();
                newRange.setStart(newP, 0);
                selection.removeAllRanges();
                selection.addRange(newRange);
                saveNoteContent();
                return;
            }
        }
    }
    if (e.key === 'Backspace' && selection.isCollapsed && range.startOffset === 0) {
        const pre = node.closest('pre');
        if (pre && pre.textContent.length === 0) {
            const wrapper = pre.closest('.code-block-wrapper');
            if (wrapper) {
                e.preventDefault();
                wrapper.remove();
                saveNoteContent();
                return;
            }
        }
    }
    if (e.key === 'ArrowDown') {
        const pre = node.closest('pre');
        if (pre) {
            const codeEl = pre.querySelector('code');
            if (codeEl && selection.isCollapsed) {
                const range = selection.getRangeAt(0);
                const textContent = codeEl.textContent || '';
                if (range.startOffset === textContent.length) {
                    const wrapper = pre.closest('.code-block-wrapper');
                    if (wrapper && !wrapper.nextElementSibling) {
                        e.preventDefault();
                        const newP = document.createElement('p');
                        newP.innerHTML = '<br>';
                        wrapper.after(newP);
                        const newRange = document.createRange();
                        newRange.setStart(newP, 0);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    }
                }
            }
        }
    }
});

                // NEW: Enhanced paste event listener
// REPLACE THE OLD 'paste' LISTENER WITH THIS UPGRADED VERSION
app.elements.noteEditorBody.addEventListener('paste', (e) => {
    // Check for image files first (existing logic)
    const files = e.clipboardData.files;
    let handledFile = false;
    for (const file of files) {
        if (file.type.startsWith('image/')) {
            handleFileUpload(file);
            e.preventDefault();
            handledFile = true;
        }
    }
    if (handledFile) return;

    e.preventDefault();
    let pastedHtml = e.clipboardData.getData('text/html');
    const plainText = e.clipboardData.getData('text/plain');

    // --- START: NEW SPREADSHEET PASTE LOGIC ---
    // Check if the plain text is tab-separated and has multiple lines, which is typical for spreadsheets.
    if (plainText.includes('\t') && plainText.includes('\n')) {
        const lines = plainText.trim().split('\n').map(line => line.split('\t'));
        const cols = lines[0].length;

        // Ensure it's a consistent table structure
        if (lines.every(line => line.length === cols)) {
            let tableHTML = '<table style="width:100%"><thead>';
            tableHTML += `<tr><th colspan="${cols}" contenteditable="false"><div class="table-header-controls"><div class="table-filter-wrapper"><i data-feather="search" class="filter-icon"></i><input class="table-filter-input" placeholder="Filter table..."/></div><button class="toggle-filter-btn" title="Toggle Filter"><i data-feather="chevrons-up" class="w-4 h-4"></i></button></div></th></tr>`;
            
            const [headers, ...rows] = lines;
            tableHTML += '<tr>';
            headers.forEach(header => tableHTML += `<th class="sortable-header" data-sort-dir="none" contenteditable="true">${header}</th>`);
            tableHTML += '</tr></thead><tbody>';

            rows.forEach(row => {
                tableHTML += '<tr>';
                row.forEach(cell => tableHTML += `<td contenteditable="true">${cell}</td>`);
                tableHTML += '</tr>';
            });
            tableHTML += '</tbody></table><p><br></p>';
            
            document.execCommand('insertHTML', false, tableHTML);
            feather.replace();
            saveNoteContent();
            return; // Exit after handling the spreadsheet paste
        }
    }
    // --- END: NEW SPREADSHEET PASTE LOGIC ---

    // Fallback to existing logic for other HTML or plain text pastes
    if (!pastedHtml) {
        pastedHtml = `<p>${plainText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, '</p><p>')}</p>`;
    }

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = pastedHtml;
    tempDiv.querySelectorAll('*').forEach(el => {
        el.removeAttribute('style');
        el.removeAttribute('class');
        if (el.tagName.toLowerCase() === 'font') {
            const parent = el.parentNode;
            while (el.firstChild) parent.insertBefore(el.firstChild, el);
            parent.removeChild(el);
        }
    });
    const sanitizedHtml = tempDiv.innerHTML;
    const finalHtml = upgradePastedTables(sanitizedHtml);

    document.execCommand('insertHTML', false, finalHtml);
    feather.replace();
    saveNoteContent();
});

                app.elements.noteEditorBody.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const files = e.dataTransfer.files;
                    for (const file of files) {
                        handleImageFile(file);
                    }
                });
                
                app.elements.noteEditorBody.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });
                
                app.toolbar.ocrBtn.addEventListener('click', () => app.toolbar.ocrFileInput.click());
                app.toolbar.ocrFileInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    if (!state.settings.activeNoteId) {
                        createNewNote();
                    }
                    
                    const toastId = showToast('Recognizing text...', 'loading');
                    try {
                        const { data: { text } } = await Tesseract.recognize(file, 'eng');
                        const formattedText = `<p>${text.replace(/\n/g, '</p><p>')}</p>`;
                        app.elements.noteEditorBody.focus();
                        document.execCommand('insertHTML', false, formattedText);
                        saveNoteContent();
                        showToast('Text inserted!', 'success');
                    } catch (err) {
                        console.error(err);
                        showToast('Could not recognize text.', 'error');
                    } finally {
                        dismissToast(toastId);
                        app.toolbar.ocrFileInput.value = '';
                    }
                });
                
                app.toolbar.dictateBtn.addEventListener('click', () => {
                    if (!speechRecognizer) return;
                    if (isDictating) {
                        speechRecognizer.stop();
                        isDictating = false;
                        app.toolbar.dictateBtn.classList.remove('recording');
                        showToast('Dictation stopped.', 'info');
                    } else {
                        speechRecognizer.start();
                        isDictating = true;
                        app.toolbar.dictateBtn.classList.add('recording');
                        showToast('Listening...', 'info');
                    }
                });

                app.toolbar.graphBtn.addEventListener('click', () => {
                    const noteId = state.settings.activeNoteId;
                    if (!noteId) return;
                        document.getElementById('sidebar-toggle-btn').style.display = 'none'; // ADD THIS LINE


                    try {
                        const allNotes = getAllNotes(state.collections);
                        const { item: currentNote } = findItem(noteId);

                        const nodes = new vis.DataSet([{ id: currentNote.id, label: currentNote.name, color: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary') }]);
                        const edges = new vis.DataSet();

                        // Links from current note
                        (currentNote.links || []).forEach(linkName => {
                            const targetNote = allNotes.find(n => n.name.toLowerCase() === linkName.toLowerCase());
                            if (targetNote && targetNote.id !== currentNote.id) {
                                if (!nodes.get(targetNote.id)) {
                                    nodes.add({ id: targetNote.id, label: targetNote.name });
                                }
                                edges.add({ from: currentNote.id, to: targetNote.id, arrows: 'to' });
                            }
                        });

                        // Links to current note (backlinks)
                        allNotes.forEach(note => {
                            if (note.id !== currentNote.id && (note.links || []).some(link => link.toLowerCase() === currentNote.name.toLowerCase())) {
                                 if (!nodes.get(note.id)) {
                                    nodes.add({ id: note.id, label: note.name });
                                }
                                edges.add({ from: note.id, to: currentNote.id, arrows: 'to' });
                            }
                        });
                        
                        const computedStyles = getComputedStyle(document.documentElement);

                        const options = {
                            nodes: {
                                shape: 'box',
                                color: computedStyles.getPropertyValue('--bg-pane-dark').trim(),
                                font: { color: computedStyles.getPropertyValue('--text-primary').trim() },
                                borderWidth: 1,
                            },
                            edges: {
                                color: {
                                    color: computedStyles.getPropertyValue('--text-tertiary').trim(),
                                    highlight: computedStyles.getPropertyValue('--accent-primary').trim(),
                                }
                            },
                            physics: {
                                enabled: true,
                                solver: 'barnesHut',
                                barnesHut: {
                                    gravitationalConstant: -4000,
                                    centralGravity: 0.1,
                                    springLength: 150,
                                }
                            },
                            interaction: {
                                dragNodes: true,
                                dragView: true,
                                zoomView: true
                            }
                        };
                        new vis.Network(app.modals.graphContainer, { nodes, edges }, options);
                        const network = new vis.Network(app.modals.graphContainer, { nodes, edges }, options);

                        // --- START: NEW & IMPROVED INTERACTIVITY CODE ---
                        network.on('click', function(params) {
                            if (params.nodes.length > 0) {
                                const noteId = params.nodes[0];
                                const noteToOpen = findItem(noteId)?.item;
                                if (noteToOpen) {
                                    state.settings.activeNoteId = noteId;
                                    const { parent } = findItem(noteId);
                                    state.settings.activeCollectionId = (Array.isArray(parent)) ? null : parent.id;
                                    state.settings.activeTag = null;
                                    saveState();
                                    render();
                                    closeModal(app.modals.graph);
                                }
                            }
                        });

                        const createTooltip = () => {
                            let tooltip = document.getElementById('note-graph-tooltip');
                            if (!tooltip) {
                                tooltip = document.createElement('div');
                                tooltip.id = 'note-graph-tooltip';
                                tooltip.style.position = 'absolute';
                                tooltip.style.visibility = 'hidden';
                                tooltip.style.backgroundColor = 'var(--bg-pane-dark)';
                                tooltip.style.border = '1px solid var(--border-color)';
                                tooltip.style.borderRadius = '8px';
                                tooltip.style.padding = '12px';
                                tooltip.style.maxWidth = '300px';
                                tooltip.style.color = 'var(--text-primary)';
                                tooltip.style.boxShadow = '0 4px 12px var(--shadow-color)';
                                tooltip.style.pointerEvents = 'none';
                                tooltip.style.zIndex = '10000';
                                tooltip.style.opacity = '0';
                                tooltip.style.transition = 'opacity 0.2s ease-in-out';
                                document.body.appendChild(tooltip);
                            }
                            return tooltip;
                        };
                        
                        network.on('hoverNode', function(params) {
                            const noteId = params.node;
                            const note = findItem(noteId)?.item;
                            const tooltip = createTooltip();

                            if (note) {
                                const excerpt = note.excerpt || 'No content preview...';

                                tooltip.innerHTML = `
                                    <h4 style="font-weight: 600; margin: 0 0 5px 0;">${note.name}</h4>
                                    <p style="font-size: 0.875rem; margin: 0; color: var(--text-secondary);">${excerpt || 'This note is empty.'}</p>
                                `;

                                tooltip.style.left = `${params.event.pointer.DOM.x + 15}px`;
                                tooltip.style.top = `${params.event.pointer.DOM.y + 15}px`;
                                tooltip.style.visibility = 'visible';
                                tooltip.style.opacity = '1';
                            }
                        });

                        network.on('blurNode', function(params) {
                            const tooltip = document.getElementById('note-graph-tooltip');
                            if (tooltip) {
                                tooltip.style.opacity = '0';
                                tooltip.style.visibility = 'hidden';
                            }
                        });
                        // --- END: NEW & IMPROVED INTERACTIVITY CODE ---

                        network.on('blurNode', function(params) {
                            let tooltip = document.getElementById('note-graph-tooltip');
                            if (tooltip) {
                                tooltip.style.opacity = '0';
                            }
                        });
                        // --- END: ADD THIS NEW CODE ---
                        openModal(app.modals.graph);

                    } catch(err) {
                        console.error("Error creating note graph:", err);
                        // showToast('Could not create note graph.', 'error');
                    }
                });
                document.getElementById('header-template-btn').addEventListener('click', () => {
    const note = findItem(state.settings.activeNoteId)?.item;
    if (note) {
        saveAsTemplate(note);
    }
});
document.getElementById('header-collaborate-btn').addEventListener('click', openShareModal);
                
                app.modals.graphCloseBtn.addEventListener('click', () => closeModal(app.modals.graph));
                
                app.modals.aiCancelBtn.addEventListener('click', () => closeModal(app.modals.aiPrompt));
                app.modals.aiGenerateBtn.addEventListener('click', async () => {
                    const prompt = app.modals.aiPromptInput.value.trim();
                    if (!prompt) {
                        app.modals.aiPromptError.textContent = 'Please enter a prompt.';
                        return;
                    }
                    
                    if (!state.settings.activeNoteId) {
                        createNewNote();
                    }
                    
                    app.modals.aiGenerateBtn.disabled = true;
                    app.modals.aiGenerateBtnText.textContent = 'Generating...';

                    const payload = { contents: [{ parts: [{ text: prompt }] }] };
                    const generatedText = await callGeminiAPI(payload, app.modals.aiPromptError);

                    if (generatedText) {
                        app.elements.noteEditorBody.focus();
                        if (editorSelectionRange) {
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(editorSelectionRange);
                        }
                        const formattedHtml = marked.parse(generatedText).trim();
                        document.execCommand('insertHTML', false, formattedHtml);
                        saveNoteContent();
                        closeModal(app.modals.aiPrompt);
                        showToast('AI content inserted!', 'success');
                    }
                    
                    app.modals.aiGenerateBtn.disabled = false;
                    app.modals.aiGenerateBtnText.textContent = 'Generate';
                });
                // --- START: Version History Listeners ---
document.getElementById('history-btn').addEventListener('click', openVersionHistoryModal);
document.getElementById('version-history-close-btn').addEventListener('click', closeVersionHistoryModal);

document.getElementById('version-list-container').addEventListener('click', async (e) => {
    const restoreBtn = e.target.closest('.restore-version-btn');
    if (!restoreBtn) return;

    // Get the preview content directly from the item you clicked on
    const versionItem = restoreBtn.closest('.version-item');
    const previewHTML = versionItem.querySelector('.version-preview').innerHTML;

    const noteId = state.settings.activeNoteId;
    const timestamp = restoreBtn.dataset.versionTimestamp;
    const versionToRestore = state.versions?.[noteId]?.find(v => v.savedAt === timestamp);

    if (!versionToRestore) {
        showToast('Could not find that version.', 'error');
        return;
    }

    const confirmed = await showConfirm({
        title: 'Restore Note Version',
        // This new message includes the content preview for clarity
        message: `This will replace the note's content with the version from <strong>${formatRelativeTime(timestamp)}</strong>.<br><br><p class="text-xs text-text-tertiary">Preview:</p><blockquote class="text-sm p-2 bg-bg-pane-dark rounded-md border-l-4 border-border-color max-h-24 overflow-y-auto">${previewHTML}</blockquote>`,
        confirmText: 'Restore',
        // This makes the button use the brand color instead of red
        confirmClass: 'brand-button'
    });

    if (confirmed) {
        const { item: note } = findItem(noteId);
        if (note) {
            note.content = versionToRestore.content;
            app.elements.noteEditorBody.innerHTML = note.content;
            performImmediateSave();
            closeModal(document.getElementById('version-history-modal'));
            showToast('Note restored successfully!', 'success');
        }
    }
});
// --- END: Version History Listeners ---
                

                const handleSummarize = async (noteContent) => {
    const toastId = showToast('Summarizing...', 'loading');
    const prompt = `Summarize the following text into one or more concise paragraphs:\n\n---\n\n${noteContent}`;
    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    const summaryText = await callGeminiAPI(payload);

    dismissToast(toastId);

    if (summaryText) {
        // New logic: Show the summary in the dedicated modal.
        app.modals.summaryContent.innerHTML = marked.parse(summaryText).trim();
        openModal(app.modals.summary);
        feather.replace();
    } else {
         showToast('Could not generate summary.', 'error');
    }
};
                app.modals.summaryCloseBtn.addEventListener('click', () => closeModal(app.modals.summary));
                app.modals.quizCloseBtn.addEventListener('click', () => closeModal(app.modals.quiz));
app.modals.quizDoneBtn.addEventListener('click', () => closeModal(app.modals.quiz));

app.modals.quizContent.addEventListener('change', e => {
    if (e.target.type === 'radio') { // Logic for single-choice questions
        const questionContainer = e.target.closest('.quiz-question-container');
        const selectedAnswer = e.target.value;
        const correctAnswer = JSON.parse(questionContainer.dataset.correctAnswer);
        const feedbackEl = questionContainer.querySelector('.quiz-feedback');

        questionContainer.querySelectorAll('input[type="radio"]').forEach(radio => {
            radio.disabled = true;
            radio.parentElement.classList.add('cursor-not-allowed', 'opacity-60');
        });

        if (selectedAnswer === correctAnswer) {
            feedbackEl.textContent = 'Correct!';
            feedbackEl.className = 'quiz-feedback text-sm mt-2 h-5 font-medium text-green-500';
            e.target.parentElement.classList.add('bg-green-500/20', 'border-green-500');
        } else {
            feedbackEl.textContent = `Incorrect. The correct answer is ${correctAnswer}.`;
            feedbackEl.className = 'quiz-feedback text-sm mt-2 h-5 font-medium text-red-500';
            e.target.parentElement.classList.add('bg-red-500/20', 'border-red-500');
            const correctLabel = questionContainer.querySelector(`input[value="${correctAnswer}"]`).parentElement;
            correctLabel.classList.remove('opacity-60');
            correctLabel.classList.add('bg-green-500/20', 'border-green-500');
        }
    }
});

// Add this new click listener right after the 'change' listener above
app.modals.quizContent.addEventListener('click', e => {
    if (e.target.classList.contains('submit-msq-btn')) { // Logic for multi-select questions
        const questionContainer = e.target.closest('.quiz-question-container');
        const correctAnswers = new Set(JSON.parse(questionContainer.dataset.correctAnswer));
        const selectedAnswers = new Set(Array.from(questionContainer.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value));
        const feedbackEl = questionContainer.querySelector('.quiz-feedback');

        // Check for perfect match
        const isCorrect = correctAnswers.size === selectedAnswers.size && [...correctAnswers].every(answer => selectedAnswers.has(answer));

        questionContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.disabled = true;
            const label = cb.parentElement;
            label.classList.add('cursor-not-allowed', 'opacity-60');
            if (correctAnswers.has(cb.value)) {
                label.classList.add('bg-green-500/20', 'border-green-500');
            } else if (selectedAnswers.has(cb.value)) {
                label.classList.add('bg-red-500/20', 'border-red-500');
            }
        });

        if (isCorrect) {
            feedbackEl.textContent = 'Correct!';
            feedbackEl.className = 'quiz-feedback text-sm mt-2 h-5 font-medium text-green-500';
        } else {
            feedbackEl.textContent = `Incorrect. The correct answer(s): ${Array.from(correctAnswers).join(', ')}.`;
            feedbackEl.className = 'quiz-feedback text-sm mt-2 h-5 font-medium text-red-500';
        }
        e.target.style.display = 'none'; // Hide submit button after answering
    }
});

                app.elements.chatbotFab.addEventListener('click', () => {
                    renderChatHistory();
                    openModal(app.modals.chatbot);
                    app.modals.chatbotInput.focus();
                    feather.replace();
                });
                app.modals.chatbotCloseBtn.addEventListener('click', () => closeModal(app.modals.chatbot));
                app.modals.chatbotClearBtn.addEventListener('click', async () => {
                    const confirmed = await showConfirm({
                        title: 'Clear Chat History',
                        message: 'Are you sure you want to delete the entire conversation and remove all context notes?',
                        confirmText: 'Clear',
                        confirmClass: 'bg-red-500'
                    });
                    if (confirmed) {
                        state.chatHistory = [];
                        window.chatbotContextNoteIds = []; // Also clear the context
                        saveState();
                        renderChatHistory();
                        document.getElementById('chatbot-context-pills').innerHTML = ''; // Clear the UI pills
                        showToast('Chat history cleared', 'success');
                    }
                });

                // REPLACE the existing handleChatSubmit function with this one
const handleChatSubmit = async () => {
    const userInput = app.modals.chatbotInput.value.trim();
    if (!userInput) return;

    // This check will now work correctly with the function you added
    if (window.chatbotContextNoteIds.length > 0) {
        if (!(await ensureAllNotesLoaded())) return; // Stop if notes fail to load
    }

    app.modals.chatbotError.textContent = '';
    app.modals.chatbotInput.value = '';
    app.modals.chatbotSendBtn.disabled = true;

    state.chatHistory.push({ role: 'user', text: userInput });
    renderChatHistory();

    const thinkingBubble = document.createElement('div');
    thinkingBubble.className = 'chat-bubble thinking w-fit rounded-lg px-3 py-2 self-start model';
    thinkingBubble.innerHTML = '● ● ●';
    app.modals.chatbotHistory.appendChild(thinkingBubble);
    app.modals.chatbotHistory.scrollTop = app.modals.chatbotHistory.scrollHeight;

    let fullPrompt = "You are a helpful AI assistant. Answer the user's question based on the conversation history and any provided note context.\n\n---\n\n";

    // ** START: THIS IS THE NEW LOGIC TO ADD CONTEXT **
    if (window.chatbotContextNoteIds.length > 0) {
        const context = window.chatbotContextNoteIds.map(id => {
            const noteData = window.noteCache[id];
            if (!noteData) return ''; // Should not happen after ensureAllNotesLoaded, but is a safeguard
            const plainContent = (noteData.content || '').replace(/<[^>]*>?/gm, '');
            return `--- Note Context: "${noteData.name}" ---\n${plainContent}`;
        }).join('\n\n');
        fullPrompt += `CONTEXT FROM NOTES:\n${context}\n\n---\n\n`;
    }
    // ** END: NEW LOGIC **

    state.chatHistory.forEach(msg => {
        fullPrompt += `${msg.role === 'user' ? 'User' : 'AI'}: ${msg.text}\n\n`;
    });

    const payload = { contents: [{ parts: [{ text: fullPrompt }] }] };
    const modelResponse = await callGeminiAPI(payload, app.modals.chatbotError);
    
    thinkingBubble.remove();

    if (modelResponse) {
        state.chatHistory.push({ role: 'model', text: modelResponse });
        renderChatHistory();
    }

    saveState();
    app.modals.chatbotSendBtn.disabled = false;
    app.modals.chatbotInput.focus();
};

                app.modals.chatbotSendBtn.addEventListener('click', handleChatSubmit);
                app.modals.chatbotInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        handleChatSubmit();
                    }
                });

                app.elements.newCollectionBtn.addEventListener('click', async () => {
    const name = await showPrompt({
        title: 'New Project Folder',
        message: 'Enter a name for your new project:',
        placeholder: 'e.g. Project Phoenix'
    });
    if (name) {
        const newCollection = {
            id: generateId('c'),
            name,
            type: 'folder',
            children: [],
            expanded: true
        };
        state.kanbanColumns[newCollection.id] = [{
            id: generateId('col'),
            title: 'To Do'
        }];
        state.collections.unshift(newCollection);

        // This now uses your corrected createNewNote function,
        // which properly handles creating the Firestore document.
        const newNote = await createNewNote(true, {
            name: 'Getting Started'
        }, newCollection.id);

        // The createNewNote function already saves state and re-renders,
        // so we just need to update the active collection and do one final render.
        state.settings.activeCollectionId = newCollection.id;
        state.settings.activeNoteId = newNote.id;
        await saveState();
        render();
        showToast(`Project "${name}" created!`, 'success');
    }
});

                // --- New Note Dropdown Logic ---
const newNoteContainer = document.getElementById('new-note-dropdown-container');
const newNoteDropdown = document.getElementById('new-note-dropdown');
newNoteContainer.addEventListener('click', (e) => {
    const action = e.target.closest('button')?.dataset.action;
    if (action === 'new-blank-note') {
        createNewNote(true, {}); // Pass empty object for a blank note
        newNoteDropdown.classList.add('hidden');
    } else if (action === 'new-from-template') {
        openTemplateModal();
        newNoteDropdown.classList.add('hidden');
    } else {
        // If the main button is clicked, just toggle the dropdown
        newNoteDropdown.classList.toggle('hidden');
        if(!newNoteDropdown.classList.contains('hidden')) feather.replace();
    }
});
document.addEventListener('click', (e) => {
    if (!newNoteContainer.contains(e.target)) {
        newNoteDropdown.classList.add('hidden');
    }
});

                const openSearch = () => {
                    buildLunrIndex(); // Ensure index is fresh before searching
                    const highlightControls = document.getElementById('highlight-controls');
                    if (!highlightControls.classList.contains('hidden')) {
                        const clearSearchBtn = document.getElementById('clear-search-btn');
                        if (clearSearchBtn) clearSearchBtn.click();
                    }
                    
                    if (window.innerWidth < 768) {
                        // On mobile, show the search bar as an absolute overlay within the header
                        app.search.container.classList.remove('hidden');
                        app.search.container.classList.add('absolute', 'top-0', 'left-0', 'w-full', 'h-full', 'bg-bg-main');
                        app.elements.headerMainContent.classList.add('opacity-0', 'pointer-events-none');
                    } else {
                        // Desktop behavior
                        app.elements.headerMainContent.classList.add('opacity-0', 'pointer-events-none');
                        app.search.container.classList.remove('hidden');
                    }

                    isSearchActive = true;
                    app.search.input.focus();
                    renderMainView();
                };

                const closeSearch = (skipRender = false) => {
                     if (window.innerWidth < 768) {
                        // Properly hide the absolute overlay and restore the main header content
                        app.search.container.classList.add('hidden');
                        app.search.container.classList.remove('absolute', 'top-0', 'left-0', 'w-full', 'h-full', 'bg-bg-main');
                        app.elements.headerMainContent.classList.remove('opacity-0', 'pointer-events-none');
                    } else {
                        // Desktop behavior
                        app.elements.headerMainContent.classList.remove('opacity-0', 'pointer-events-none');
                        app.search.container.classList.add('hidden');
                    }

                    app.search.input.value = '';
                    isSearchActive = false;
                    if (!skipRender) render();
                };

                app.search.icon.addEventListener('click', openSearch);
                app.search.mobileIcon.addEventListener('click', openSearch);
                app.search.closeBtn.addEventListener('click', () => closeSearch());
                app.search.input.addEventListener('input', () => {
                    renderSearchResults(app.search.input.value);
                });

                app.toolbar.editorModeToggle.addEventListener('click', () => {
                    if (!state.settings.activeNoteId) return;
                    state.settings.editorMode = state.settings.editorMode === 'editor' ? 'preview' : 'editor';
                    saveState();
                    renderNoteEditor();
                });

                document.addEventListener('selectionchange', () => {
                    if (isExecutingCommand) return; 
                    if (document.activeElement !== app.elements.noteEditorBody) {
                        app.toolbar.inline.style.opacity = '0';
                        app.toolbar.inline.style.pointerEvents = 'none';
                        return;
                    }
                    const selection = window.getSelection();

                    if (selection.isCollapsed) {
                        app.toolbar.inline.style.opacity = '0';
                        app.toolbar.inline.style.pointerEvents = 'none';
                        return;
                    }

                    if (selection.rangeCount > 0) {
                        editorSelectionRange = selection.getRangeAt(0).cloneRange();
                    }

                    const range = selection.getRangeAt(0);
                    const rect = range.getBoundingClientRect();
                    const toolbarRect = app.toolbar.inline.getBoundingClientRect();
                    app.toolbar.inline.style.top = `${window.scrollY + rect.top - toolbarRect.height - 8}px`;
                    app.toolbar.inline.style.left = `${window.scrollX + rect.left + (rect.width / 2) - (toolbarRect.width / 2)}px`;
                    app.toolbar.inline.style.opacity = '1';
                    app.toolbar.inline.style.transform = 'scale(1)';
                    app.toolbar.inline.style.pointerEvents = 'auto';
                });
                    // ADD THIS NEW EVENT LISTENER
document.getElementById('mobile-sticky-toolbar').addEventListener('mousedown', (e) => {
    const button = e.target.closest('button');
    if (!button) return;

    // Prevent the editor from losing focus
    e.preventDefault();

    // Simulate a click on the corresponding button in the original (but hidden) toolbar
    // This is a clean way to avoid duplicating all the command logic.
    const originalToolbar = document.getElementById('inline-toolbar');
    const { command, value } = button.dataset;
let selector;
if (value) {
  // If the button has a value (like H1, H2), find the exact match
  selector = `[data-command="${command}"][data-value="${value}"]`;
} else {
  // If the button has no value (like Bold, Italic), find the one without that attribute
  selector = `[data-command="${command}"]:not([data-value])`;
}
const originalButton = originalToolbar.querySelector(selector);

    if (originalButton) {
        originalButton.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
    }
});
                
                app.toolbar.inline.addEventListener('mousedown', async (e) => {
    const button = e.target.closest('button');
    if (!button) return;

    if (button.id === 'toolbar-scroll-left' || button.id === 'toolbar-scroll-right') {
        return;
    }

    e.preventDefault();

    isExecutingCommand = true; // Lock is activated
    try {
        const command = button.dataset.command;
        const value = button.dataset.value;

        if (command === 'monospace') {
                        restoreSelectionAndExec(() => {
                            const selection = window.getSelection();
                            if (!selection.rangeCount) return;
                            let parent = selection.getRangeAt(0).commonAncestorContainer;
                            parent = parent.nodeType === 3 ? parent.parentNode : parent;
                            const codeTag = parent.closest('code:not(pre code)');
                            if (codeTag) {
                                const content = document.createDocumentFragment();
                                while(codeTag.firstChild) { content.appendChild(codeTag.firstChild); }
                                codeTag.parentNode.replaceChild(content, codeTag);
                            } else {
                                const selectedText = selection.toString();
                                if (selectedText) document.execCommand('insertHTML', false, `<code>${selectedText}</code>`);
                            }
                        });
                        return;
                    }
                    else if (command === 'textColor') { // NEW CODE STARTS HERE - TEXT COLOR
                        restoreSelectionAndExec(() => {
                            const selection = window.getSelection();
                            if (!selection.rangeCount) return;

                            const range = selection.getRangeAt(0);
                            const selectedText = range.toString();

                            if (!selectedText) return;

                            const span = document.createElement('span');
                            span.setAttribute('data-text-color', value); // Store color for toggling

                            // Check if the selection is already part of a colored span
                            let parentColoredSpan = range.commonAncestorContainer.parentElement.closest('[data-text-color]');

                            if (value === 'none') {
                                // If "Clear Color" is selected
                                if (parentColoredSpan) {
                                    const content = document.createDocumentFragment();
                                    while (parentColoredSpan.firstChild) {
                                        content.appendChild(parentColoredSpan.firstChild);
                                    }
                                    parentColoredSpan.parentNode.replaceChild(content, parentColoredSpan);
                                } else {
                                    // If no direct parent span, try to clear color from selected text
                                    const tempDiv = document.createElement('div');
                                    tempDiv.appendChild(range.extractContents());
                                    tempDiv.querySelectorAll('span[data-text-color]').forEach(s => {
                                        const innerContent = document.createDocumentFragment();
                                        while(s.firstChild) innerContent.appendChild(s.firstChild);
                                        s.parentNode.replaceChild(innerContent, s);
                                    });
                                    range.insertNode(tempDiv);
                                }
                            } else {
                                // Applying a specific color
                                span.classList.add(`text-color-${value}`);

                                if (parentColoredSpan) {
                                    // If already colored, check if it's the same color or change it
                                    if (parentColoredSpan.getAttribute('data-text-color') === value) {
                                        // Same color, so un-color it
                                        const content = document.createDocumentFragment();
                                        while (parentColoredSpan.firstChild) {
                                            content.appendChild(parentColoredSpan.firstChild);
                                        }
                                        parentColoredSpan.parentNode.replaceChild(content, parentColoredSpan);
                                    } else {
                                        // Different color, so change the class
                                        parentColoredSpan.className = ''; // Clear existing classes
                                        parentColoredSpan.classList.add(`text-color-${value}`);
                                        parentColoredSpan.setAttribute('data-text-color', value);
                                    }
                                } else {
                                    // No existing color, apply new span
                                    try {
                                        range.surroundContents(span);
                                    } catch (e) {
                                        // Fallback for partial selections that cannot be surrounded
                                        const fragment = range.extractContents();
                                        span.appendChild(fragment);
                                        range.insertNode(span);
                                    }
                                }
                            }
                        });
                        return;
                    } // NEW CODE ENDS HERE // NEW CODE ENDS HERE
                    if (command === 'toggleCheckboxes') {
                        restoreSelectionAndExec(() => {
                            const selection = window.getSelection();
                            if (!selection.rangeCount) return;
                            const allChecklistItems = app.elements.noteEditorBody.querySelectorAll('.task-list-item');
                            allChecklistItems.forEach(item => {
                                if (selection.containsNode(item, true)) {
                                    item.classList.toggle('checkbox-hidden');
                                }
                            });
                        });
                        return;
                    }
        if (command === 'formatBlock' && value === 'code') {
             restoreSelectionAndExec(() => {
                const selection = window.getSelection();
                const selectedText = selection.toString();
                let lang = 'plaintext';
                if (/<[a-z][\s\S]*>/i.test(selectedText)) lang = 'html';
                else if (/\b(function|const|let|var|import|export)\b/.test(selectedText)) lang = 'javascript';
                else if (/\b(def|import|class|for|while)\b/.test(selectedText)) lang = 'python';
                const escapedCode = selectedText.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const codeBlockHTML = `<div class="code-block-wrapper" contenteditable="false"><div class="code-block-header"><span>${lang}</span><div class="flex items-center gap-1"><button class="copy-code-btn" title="Copy Code"><i data-feather="copy" class="w-4 h-4"></i><span>Copy</span></button><button class="delete-block-btn" title="Delete Block"><i data-feather="trash-2" class="w-4 h-4"></i></button></div></div><pre contenteditable="true"><code>${escapedCode}</code></pre></div><p><br></p>`;
                document.execCommand('insertHTML', false, codeBlockHTML);
                feather.replace();
            });
            return;
        }
        if (command === 'insertChecklist') {
            restoreSelectionAndExec(() => {
                const newDefaultChecklistHTML = `
                <div class="checklist-container" contenteditable="false">
                    <div class="checklist-header">
                        <h4 class="checklist-title font-semibold text-text-primary flex-grow">Untitled Checklist</h4>
                        <button class="checklist-header-btn" data-action="edit" title="Edit Checklist"><i data-feather="edit" class="w-4 h-4"></i></button>
                        <button class="checklist-header-btn delete" data-action="delete" title="Delete Checklist"><i data-feather="trash-2" class="w-4 h-4"></i></button>
                    </div>
                    <div class="checklist-progress-container">
                        <div class="checklist-progress-bar">
                            <div class="checklist-progress-fill" style="width: 0%;"></div>
                        </div>
                        <span class="checklist-progress-text">0% Complete</span>
                    </div>
                    <ul class="checklist-body">
                        <li class="checklist-item" data-checked="false"><input type="checkbox" class="checklist-item-checkbox" onclick="return false;"><span class="checklist-item-text" contenteditable="false">New item</span></li>
                    </ul>
                </div>
                <p><br></p>
                `;
                document.execCommand('insertHTML', false, newDefaultChecklistHTML);
                feather.replace();
            });
            return;
        }
        // ... (other if statements are above this) ...

        if (command === 'insertTable') {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) editorSelectionRange = selection.getRangeAt(0).cloneRange();
            openModal(document.getElementById('table-creator-modal'));
            return;
        }
        if (command === 'createLink') {
    const selection = window.getSelection();
    const parentEl = selection.anchorNode?.parentNode.closest('a');

    if (parentEl) {
        restoreSelectionAndExec(() => { document.execCommand('unlink'); });
    } else {
        const selectedText = selection.toString().trim();
        const { result, range } = await openLinkModal();

        if (result && range) {
            selection.removeAllRanges();
            selection.addRange(range);

            let linkHTML = '';
            if (result.type === 'internal') {
                linkHTML = `<a href="#" class="internal-link" data-note-id="${result.id}">${selectedText || result.name}</a>`;
            } else { 
                let finalUrl = result.url;
                if (!/^(https?|ftp):\/\//i.test(finalUrl)) finalUrl = 'https://' + finalUrl;
                linkHTML = `<a href="${finalUrl}" target="_blank" rel="noopener noreferrer">${selectedText || finalUrl}</a>`;
            }
            
            document.execCommand('insertHTML', false, linkHTML);
            performImmediateSave();
            render();
        }
    }
} else if (command === 'insertImage') { // CORRECTED TO 'else if'
            const url = await showPrompt({ title: 'Insert Image', message: 'Enter the image URL:', placeholder: 'https://example.com/image.png' });
            if (url) restoreSelectionAndExec(() => document.execCommand('insertHTML', false, `<img src="${url}" alt="Image">`));
        } else if (command === 'formatBlock') {
             restoreSelectionAndExec(() => {
                const selection = window.getSelection();
                let parentEl = selection.getRangeAt(0).commonAncestorContainer;
                parentEl = parentEl.nodeType === 3 ? parentEl.parentNode : parentEl;
                const isAlreadyBlock = parentEl.closest(value) || (value === 'blockquote' && parentEl.closest('blockquote'));
                if (isAlreadyBlock) {
                    document.execCommand('formatBlock', false, 'p');
                } else {
                    document.execCommand(command, false, value);
                }
            });
        } else {
            restoreSelectionAndExec(() => document.execCommand(command, false, null));
        }
    } finally {
        // Lock is released on the next browser frame
        requestAnimationFrame(() => {
            isExecutingCommand = false;
        });
    }
});

                app.containers.collectionsList.addEventListener('contextmenu', e => {
                    const itemWrapper = e.target.closest('.collection-item-wrapper');
                    
                    app.contextMenu.togglePinBtn.style.display = 'none';
                    app.contextMenu.renameBtn.style.display = 'none';
                    app.contextMenu.deleteBtn.style.display = 'none';
                    app.contextMenu.duplicateBtn.style.display = 'none';
                    document.querySelector('[data-action="save-as-template"]').style.display = 'none';

                    if (!itemWrapper && e.target.closest('#collections-list-container')) {
                        app.contextMenu.targetId = null;
                        app.contextMenu.targetIsContainer = true;
                    } else if (itemWrapper) {
                        e.preventDefault();
                        app.contextMenu.targetId = itemWrapper.dataset.id;
                        app.contextMenu.targetIsContainer = false;
                        const { item } = findItem(app.contextMenu.targetId);
                        
                        app.contextMenu.renameBtn.style.display = 'flex';
                        app.contextMenu.deleteBtn.style.display = 'flex';
                        app.contextMenu.duplicateBtn.style.display = 'flex';

                        if (item && item.type === 'note') {
    app.contextMenu.togglePinBtn.style.display = 'flex';
    document.querySelector('[data-action="save-as-template"]').style.display = 'flex';
    app.contextMenu.pinActionText.textContent = item.pinned ? 'Unpin' : 'Pin';
}
                    } else {
                        return;
                    }

                    app.contextMenu.menu.style.top = `${e.clientY}px`;
                    app.contextMenu.menu.style.left = `${e.clientX}px`;
                    app.contextMenu.menu.classList.remove('hidden');
                    setTimeout(() => app.contextMenu.menu.classList.remove('scale-95', 'opacity-0'), 10);
                    feather.replace();
                });

                const duplicateItem = (sourceItem) => {
                    const newItem = JSON.parse(JSON.stringify(sourceItem));
                    newItem.id = generateId(sourceItem.type[0]);
                    newItem.name = `${sourceItem.name} (copy)`;
                    
                    const now = new Date().toISOString();
                    if (newItem.type === 'note') {
                        newItem.createdAt = now;
                        newItem.modifiedAt = now;
                    }

                    if (newItem.type === 'folder' && newItem.children) {
                        newItem.children = newItem.children.map(child => duplicateItem(child));
                        if (state.kanbanColumns[sourceItem.id]) {
                            state.kanbanColumns[newItem.id] = JSON.parse(JSON.stringify(state.kanbanColumns[sourceItem.id]));
                        }
                    }
                    return newItem;
                };

                app.contextMenu.menu.addEventListener('click', async e => {
    const button = e.target.closest('button');
    if (!button) return;

    closeContextMenu();

    const action = button.dataset.action;
    const id = app.contextMenu.targetId;

    let findResult, targetItem, parent, parentArray;
    if (id) {
        findResult = findItem(id);
        if (findResult) {
            targetItem = findResult.item;
            parent = findResult.parent;
            parentArray = Array.isArray(parent) ? parent : parent.children;
        }
    }

    switch (action) {
        case 'new-note':
        case 'new-folder':
            {
                const isFolder = action === 'new-folder';
                let parentId = null;
                if (targetItem) {
                    parentId = targetItem.type === 'folder' ? targetItem.id : (Array.isArray(parent) ? null : parent.id);
                }
                if (isFolder) {
                    const name = 'New Folder';
                    const newCollection = {
                        id: generateId('c'), name, type: 'folder', children: [], expanded: true
                    };
                    state.kanbanColumns[newCollection.id] = [{
                        id: generateId('col'),
                        title: 'To Do'
                    }];
                    let destArray = parentId ? findItem(parentId).item.children : state.collections;
                    destArray.unshift(newCollection);
                    saveState();
                    render();
                } else {
                    createNewNote(true, {}, parentId);
                }
                break;
            }

        case 'delete':
            {
                if (!targetItem) return;
                const message = targetItem.type === 'folder' ? 'This will delete the folder and <strong>all notes inside</strong>. This action cannot be undone.' : 'This action cannot be undone.';
                const confirmed = await showConfirm({
                    title: `Delete "${targetItem.name}"`,
                    message: message,
                    confirmText: 'Delete'
                });
                if (confirmed) {
                    const index = parentArray.findIndex(i => i.id === id);
                    parentArray.splice(index, 1);
                    showToast(`"${targetItem.name}" deleted.`);
                    if (state.settings.activeNoteId === id) state.settings.activeNoteId = null;
                    if (state.settings.activeCollectionId === id) state.settings.activeCollectionId = null;
                    saveState();
                    buildLunrIndex();
                    render();
                }
                break;
            }

        case 'rename':
            {
                if (!targetItem) return;
                const newName = await showPrompt({
                    title: 'Rename',
                    message: `Enter a new name for "${targetItem.name}":`,
                    initialValue: targetItem.name
                });
                if (newName && newName !== targetItem.name) {
                    targetItem.name = newName;
                    if (targetItem.type === 'note') {
                        const { doc, updateDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
                        const noteRef = doc(db, "notes", targetItem.id);
                        await updateDoc(noteRef, { name: newName });
                    }
                    saveState();
                    buildLunrIndex();
                    render();
                }
                break;
            }

        case 'toggle-pin':
            {
                if (targetItem && targetItem.type === 'note') {
                    targetItem.pinned = !targetItem.pinned;
                    showToast(targetItem.pinned ? `Pinned "${targetItem.name}"` : `Unpinned "${targetItem.name}"`);
                    saveState();
                    render();
                }
                break;
            }

        case 'save-as-template':
            {
                if (targetItem && targetItem.type === 'note') {
                    saveAsTemplate(targetItem);
                }
                break;
            }

        case 'duplicate':
            {
                if (!targetItem) return;

                const {
                    doc,
                    collection,
                    writeBatch
                } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
                const batch = writeBatch(db);

                const duplicateRecursive = (item) => {
                    const newItemStub = JSON.parse(JSON.stringify(item));
                    const newId = generateId(item.type[0]);
                    newItemStub.id = newId;
                    newItemStub.name = `${item.name} (copy)`;

                    if (item.type === 'note') {
                        const sourceNoteData = window.noteCache[item.id];
                        if (sourceNoteData) {
                            const newNoteData = { ...sourceNoteData,
                                name: newItemStub.name
                            };
                            const newNoteRef = doc(db, "notes", newId);
                            batch.set(newNoteRef, newNoteData);
                        }
                    } else if (item.type === 'folder') {
                        if (state.kanbanColumns[item.id]) {
                            state.kanbanColumns[newId] = JSON.parse(JSON.stringify(state.kanbanColumns[item.id]));
                        }
                        if (item.children) {
                            newItemStub.children = item.children.map(duplicateRecursive);
                        }
                    }
                    return newItemStub;
                };

                const newItem = duplicateRecursive(targetItem);
                parentArray.splice(findResult.index + 1, 0, newItem);

                await batch.commit();
                saveState();
                buildLunrIndex();
                render();
                showToast(`Duplicated "${targetItem.name}"`);
                break;
            }
    }
});
                
                const closeContextMenu = () => {
                    app.contextMenu.menu.classList.add('scale-95', 'opacity-0');
                    setTimeout(() => app.contextMenu.menu.classList.add('hidden'), 100);
                };
                
                document.getElementById('bookmarklet-info-btn').addEventListener('click', () => {
                    const code = `javascript:(()=>{const data=JSON.stringify({url:location.href,title:document.title,clip:window.getSelection().toString()});window.open('${window.location.origin + window.location.pathname}#clip='+encodeURIComponent(data),'_blank');})();`;
                    app.modals.bookmarkletLink.href = code;
                    openModal(app.modals.bookmarklet);
                    feather.replace();
                });
                app.modals.bookmarkletCloseBtn.addEventListener('click', () => closeModal(app.modals.bookmarklet));

                app.elements.notesListPane.addEventListener('click', async e => {
    const button = e.target.closest('button[data-action]');
    if (!button) return;
    const action = button.dataset.action;

    if (action === 'export') {
        const toastId = showToast('Preparing export... This may take a moment.', 'loading');
        
        try {
            // Step 1: Ensure all notes are loaded from Firestore into the cache.
            const allNoteStubs = getAllNotes(state.collections);
            const notesToLoad = allNoteStubs.filter(stub => !window.noteCache[stub.id]);

            if (notesToLoad.length > 0) {
                const { doc, getDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
                const fetchPromises = notesToLoad.map(stub => {
                    const noteRef = doc(db, "notes", stub.id);
                    return getDoc(noteRef).then(noteSnap => {
                        if (noteSnap.exists()) { window.noteCache[stub.id] = noteSnap.data(); }
                    });
                });
                await Promise.all(fetchPromises);
            }

            // Step 2: Create a full state object for export by combining stubs and cached data.
            const stateForExport = JSON.parse(JSON.stringify(state)); // Deep copy to avoid modifying live state
            const populateNotes = (items) => {
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type === 'note') {
                        const fullNoteData = window.noteCache[items[i].id];
                        if (fullNoteData) {
                            items[i] = { ...items[i], ...fullNoteData };
                        }
                    } else if (items[i].type === 'folder' && items[i].children) {
                        populateNotes(items[i].children);
                    }
                }
            };
            populateNotes(stateForExport.collections);
            
            // Step 3: Stringify and download the complete data object.
            const dataStr = JSON.stringify(stateForExport, null, 2);
            const dataBlob = new Blob([dataStr], {type: "application/json"});
            const url = URL.createObjectURL(dataBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `reputifly-notes-backup-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            dismissToast(toastId);
            showToast('✅ Data exported successfully!', 'success');

        } catch (error) {
            dismissToast(toastId);
            console.error("Export failed:", error);
            showToast('❌ Failed to load all note data for export.', 'error');
        }
    }

    // THIS IS THE NEWLY ADDED FIX FOR THE IMPORT BUTTON
    if (action === 'import') {
        app.elements.importFileInput.click();
    }
});

                app.elements.importFileInput.addEventListener('change', async e => {
    const file = e.target.files[0];
    if (!file) return;

    const confirmed = await showConfirm({
        title: 'Import Data',
        message: 'This will <strong>overwrite all current data</strong> in this app. This action cannot be undone. Are you sure you want to continue?',
        confirmText: 'Overwrite and Import',
        confirmClass: 'bg-orange-500'
    });

    if (!confirmed) {
        app.elements.importFileInput.value = ''; // Reset file input
        return;
    }
    
    const toastId = showToast('Importing data... Do not close this tab.', 'loading');

    const reader = new FileReader();
    reader.onload = async (event) => {
        try {
            const importedState = JSON.parse(event.target.result);
            const user = window.auth.currentUser;
            if (!user) {
                dismissToast(toastId);
                showToast('❌ You must be logged in to import data.', 'error');
                return;
            }

            const allImportedNotes = getAllNotes(importedState.collections);
            const fullNoteDataById = {};
            allImportedNotes.forEach(note => {
                const { content, excerpt, properties, createdAt, modifiedAt, tags, links, sharedWith, ownerId, ...stub } = note;
                fullNoteDataById[stub.id] = { content, excerpt, properties, createdAt, modifiedAt, tags, links, sharedWith, ownerId, name: stub.name };
            });

            const newStateForStubs = migrateState(importedState);
            const scrubStubs = (items) => {
                items.forEach(item => {
                    if (item.type === 'note') {
                        const stubKeys = ['id', 'type', 'name', 'excerpt', 'pinned', 'status'];
                        Object.keys(item).forEach(key => {
                            if (!stubKeys.includes(key)) delete item[key];
                        });
                    } else if (item.children) {
                        scrubStubs(item.children);
                    }
                });
            };
            scrubStubs(newStateForStubs.collections);

            const { doc, collection, writeBatch, deleteDoc, getDocs, query, where } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
            const batch = writeBatch(db);

            const notesColRef = collection(db, "notes");
            const userNotesQuery = query(notesColRef, where("ownerId", "==", user.uid));
            const existingNotesSnap = await getDocs(userNotesQuery);
            existingNotesSnap.forEach(doc => batch.delete(doc.ref));

            for (const noteId in fullNoteDataById) {
                const noteRef = doc(db, "notes", noteId);
                batch.set(noteRef, fullNoteDataById[noteId]);
            }
            
            const userDocRef = doc(db, "users", user.uid, "data", "appState");
            batch.set(userDocRef, newStateForStubs);

            await batch.commit();
            
            dismissToast(toastId);
            showToast('✅ Import complete! App will now reload.', 'success');
            setTimeout(() => window.location.reload(), 1500);

        } catch (err) {
            dismissToast(toastId);
            console.error("Import error:", err);
            showToast('❌ Invalid or corrupted data file.', 'error');
        } finally {
            app.elements.importFileInput.value = '';
        }
    };
    reader.readAsText(file);
});
                
                document.addEventListener('keydown', (e) => {
                if (e.key === ' ' && state.settings.activeNoteId) {
    const activeEl = document.activeElement;
    const isTypingElement = activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable;

    // Only run if the user is not already typing somewhere else
    if (!isTypingElement) {
        e.preventDefault(); // Prevents the page from scrolling
        const editorBody = app.elements.noteEditorBody;
        editorBody.focus();

        // Place the cursor at the very end of the existing content
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(editorBody);
        range.collapse(false); // 'false' collapses the range to the end
        selection.removeAllRanges();
        selection.addRange(range);
    }
}
                    // Add this inside the existing keydown listener

                    if ((e.metaKey || e.ctrlKey) && e.key === 'u') {
    e.preventDefault();
    document.getElementById('file-upload-input').click();
    if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'n') {
        e.preventDefault();
        // This re-uses the same logic as the header button
        app.elements.newCollectionBtn.click();
    }
}

                    if (e.key === 'Escape') {
                        if (isSearchActive) {
                            closeSearch();
                        }
                        closeContextMenu();
                        if (app.elements.notesListPane.classList.contains('open')) {
                            toggleMobileSidebar(false);
                        }
                    }
                    // This is the NEW, correct code to add
if ((e.metaKey || e.ctrlKey) && e.key === 'f') {
    const editorView = document.getElementById('note-editor-view');

    // Check if the note editor is visible and you're typing in it
    if (!editorView.classList.contains('hidden') && editorView.contains(document.activeElement)) {
        e.preventDefault();
        // Show the IN-NOTE search bar and focus the input
        document.getElementById('highlight-controls').classList.remove('hidden');
        const input = document.getElementById('in-note-search-input');
        input.focus();
        input.select();
    } else if (!isSearchActive) {
        // Otherwise, if global search isn't already active, open it
        e.preventDefault();
        openSearch();
    }
}
                });
                
                document.addEventListener('click', (e) => {
                    if(!app.contextMenu.menu.contains(e.target)) closeContextMenu();
                    if(!app.containers.mobileControlsDropdown.contains(e.target) && !app.elements.mobileMoreButton.contains(e.target)) {
                        const dropdown = app.containers.mobileControlsDropdown;
                        dropdown.classList.add('scale-95', 'opacity-0');
                        setTimeout(() => dropdown.classList.add('hidden'), 100);
                    }
                });
                // --- START: New Checklist Widget Logic ---

let activeChecklistElement = null; // A reference to the .checklist-container div being edited

// Function to open the checklist editing modal
// REPLACE THE ENTIRE openChecklistModal FUNCTION
// ...WITH THIS ENTIRE FUNCTION
const openChecklistModal = (checklistContainer) => {
    activeChecklistElement = checklistContainer;
    const modal = document.getElementById('checklist-edit-modal');
    const itemsContainer = document.getElementById('checklist-modal-items');
    const titleInput = document.getElementById('checklist-modal-title-input');
    itemsContainer.innerHTML = '';

    const currentTitle = checklistContainer.querySelector('.checklist-title')?.textContent || 'Untitled Checklist';
    titleInput.value = currentTitle;

    const items = checklistContainer.querySelectorAll('.checklist-item');
    items.forEach(item => {
        const text = item.querySelector('.checklist-item-text').textContent;
        const checked = item.classList.contains('checked');
        addChecklistItemToModal(text, checked);
    });

    openModal(modal);
    feather.replace();

    // --- NEW DRAG-AND-DROP LOGIC (NO SortableJS) ---
    let draggedItem = null;

    itemsContainer.addEventListener('dragstart', (e) => {
        draggedItem = e.target.closest('.checklist-modal-item');
        if (!draggedItem) return;
        // Add a class for visual feedback while dragging
        setTimeout(() => draggedItem.classList.add('dragging'), 0);
    });

    itemsContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        const targetItem = e.target.closest('.checklist-modal-item');
        if (!targetItem || targetItem === draggedItem) return;

        const rect = targetItem.getBoundingClientRect();
        // Determine if dragging over the top or bottom half of the item
        const isAfter = e.clientY > rect.top + rect.height / 2;

        if (isAfter) {
            targetItem.after(draggedItem);
        } else {
            targetItem.before(draggedItem);
        }
    });

    itemsContainer.addEventListener('dragend', (e) => {
        if (draggedItem) {
            // Clean up the visual class
            draggedItem.classList.remove('dragging');
            draggedItem = null;
        }
    });
};
// Helper to add a new item row inside the modal
// REPLACE THE ENTIRE addChecklistItemToModal FUNCTION
// REPLACE THIS ENTIRE FUNCTION...
const addChecklistItemToModal = (text = '', checked = false) => {
    const itemsContainer = document.getElementById('checklist-modal-items');
    const newItemRow = document.createElement('div');
    // Make the entire row draggable
    newItemRow.className = 'checklist-modal-item';
    newItemRow.setAttribute('draggable', 'true');

    newItemRow.innerHTML = `
        <i data-feather="grip-vertical" class="handle text-text-tertiary"></i>
        <input type="checkbox" class="checklist-modal-item-checkbox w-5 h-5" ${checked ? 'checked' : ''}>
        <input type="text" class="flex-grow" value="${text.replace(/"/g, '&quot;')}">
        <button class="checklist-modal-item-btn" data-action="delete-item" title="Delete Item">
            <i data-feather="x" class="w-4 h-4"></i>
        </button>
    `;
    itemsContainer.appendChild(newItemRow);
    feather.replace();
};


// Function to save changes from the modal back to the editor
// REPLACE THE ENTIRE saveChecklistFromModal FUNCTION
const saveChecklistFromModal = () => {
    if (!activeChecklistElement) return;

    const modalItems = document.querySelectorAll('#checklist-modal-items .checklist-modal-item');
    const newTitle = document.getElementById('checklist-modal-title-input').value.trim() || 'Untitled Checklist';

    const newItemsHTML = Array.from(modalItems).map(itemRow => {
        const text = itemRow.querySelector('input[type="text"]').value;
        const isChecked = itemRow.querySelector('input[type="checkbox"]').checked;
        return `
            <li class="checklist-item ${isChecked ? 'checked' : ''}" data-checked="${isChecked}">
                <input type="checkbox" class="checklist-item-checkbox" ${isChecked ? 'checked' : ''} onclick="return false;">
                <span class="checklist-item-text" contenteditable="false">${text.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</span>
            </li>
        `;
    }).join('');

    const body = activeChecklistElement.querySelector('.checklist-body');
    const titleEl = activeChecklistElement.querySelector('.checklist-title');

    if (body) {
        body.innerHTML = newItemsHTML;
    }
    if (titleEl) {
        titleEl.textContent = newTitle;
    }
    updateChecklistProgress(activeChecklistElement);

    saveNoteContent();
    closeModal(document.getElementById('checklist-edit-modal'));
    activeChecklistElement = null;
    showToast('Checklist updated!', 'success');
};

// Event listeners for the modal buttons
document.getElementById('checklist-modal-add-item-btn').addEventListener('click', () => {
    addChecklistItemToModal();
    // Focus the new input
    const allInputs = document.querySelectorAll('#checklist-modal-items input[type="text"]');
    allInputs[allInputs.length - 1].focus();
});

document.getElementById('checklist-modal-items').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('[data-action="delete-item"]');
    if (deleteBtn) {
        deleteBtn.closest('.checklist-modal-item').remove();
    }
});
document.getElementById('checklist-modal-save-btn').addEventListener('click', saveChecklistFromModal);
document.getElementById('checklist-modal-cancel-btn').addEventListener('click', () => closeModal(document.getElementById('checklist-edit-modal')));
document.getElementById('checklist-modal-close-btn').addEventListener('click', () => closeModal(document.getElementById('checklist-edit-modal')));

// Main event listener for interacting with the widget in the editor
app.elements.noteEditorBody.addEventListener('click', (e) => {
    const checklistContainer = e.target.closest('.checklist-container');
    if (!checklistContainer) return;

    const editBtn = e.target.closest('.checklist-header-btn[data-action="edit"]');
    const deleteBtn = e.target.closest('.checklist-header-btn[data-action="delete"]');
    const item = e.target.closest('.checklist-item');

    if (editBtn) {
        e.preventDefault();
        openChecklistModal(checklistContainer);
    } else if (deleteBtn) {
        e.preventDefault();
        checklistContainer.remove();
        performImmediateSave();
        showToast('Checklist deleted.', 'info');
    } else if (item) {
    e.preventDefault();
    const checkbox = item.querySelector('.checklist-item-checkbox');
    const checklistContainer = item.closest('.checklist-container');
    const isChecked = !item.classList.contains('checked');

    // Update classes and data attributes
    item.classList.toggle('checked', isChecked);
    item.dataset.checked = isChecked;

    // --- THIS IS THE FIX ---
    // Explicitly set the 'checked' attribute for reliable serialization
    if (isChecked) {
        checkbox.setAttribute('checked', 'checked');
    } else {
        checkbox.removeAttribute('checked');
    }
    // Also set the property for immediate visual feedback
    checkbox.checked = isChecked;
    // --- END OF FIX ---

    // Update progress and save
    updateChecklistProgress(checklistContainer);
    performImmediateSave();
}
});

// --- END: New Checklist Widget Logic ---
                // START: New Table Interaction Logic (Context Menu & Sorting)

// START: Final Table Interaction Logic (ALL FEATURES)

let tableContextMenu = document.getElementById('table-context-menu');
let activeTableRow = null;
let activeTableColIndex = -1;
let activeTableForAction = null;

const hideTableContextMenu = () => {
    if (tableContextMenu && !tableContextMenu.classList.contains('hidden')) {
        tableContextMenu.classList.add('scale-95', 'opacity-0');
        setTimeout(() => tableContextMenu.classList.add('hidden'), 100);
    }
};

app.elements.noteEditorBody.addEventListener('contextmenu', (e) => {
    closeContextMenu();
    const row = e.target.closest('tbody tr');
    const col = e.target.closest('thead tr:last-child th'); // Target the actual header row

    if (row || col) {
        e.preventDefault();
        activeTableForAction = e.target.closest('table');
        document.querySelectorAll('.table-menu-item.with-submenu').forEach(item => item.classList.remove('hover'));

        if (row) {
            activeTableRow = row;
            document.getElementById('table-row-actions').style.display = 'block';
            document.getElementById('table-col-actions').style.display = 'none';
        } else {
            activeTableColIndex = Array.from(col.parentElement.children).indexOf(col);
            document.getElementById('table-row-actions').style.display = 'none';
            document.getElementById('table-col-actions').style.display = 'block';
        }
        
        tableContextMenu.style.top = `${e.clientY}px`;
        tableContextMenu.style.left = `${e.clientX}px`;
        tableContextMenu.classList.remove('hidden');
        setTimeout(() => {
            tableContextMenu.classList.remove('scale-95', 'opacity-0');
            feather.replace();
        }, 10);
    }
});

tableContextMenu.addEventListener('click', (e) => {
    const button = e.target.closest('[data-action]');
    if (!button || !activeTableForAction) return;

    const action = button.dataset.action;
    const colCount = activeTableForAction.querySelector('thead tr:last-child').children.length;

    // --- FIX START: Helper functions are now defined BEFORE the 'actions' object ---
    const createRow = () => {
        const currentHeaderCount = activeTableForAction.querySelector('thead tr:last-child').children.length;
        const newRow = document.createElement('tr');
        newRow.innerHTML = Array(currentHeaderCount).fill('<td contenteditable="true"><br></td>').join('');
        return newRow;
    };

    const addColumn = (index) => {
        activeTableForAction.querySelectorAll('thead tr:last-child, tbody tr').forEach(row => {
            const isHeaderRow = row.parentElement.tagName === 'THEAD';
            const cellType = isHeaderRow ? 'th' : 'td';
            const newCell = document.createElement(cellType);
            newCell.setAttribute('contenteditable', 'true');
            if (isHeaderRow) {
                newCell.classList.add('sortable-header');
                newCell.dataset.sortDir = 'none';
                newCell.textContent = 'Header';
            }
            row.insertBefore(newCell, row.children[index]);
        });
        const newColCount = activeTableForAction.querySelector('thead tr:last-child').children.length;
        const filterHeader = activeTableForAction.querySelector('thead tr:first-child th');
        if (filterHeader) {
            filterHeader.setAttribute('colspan', newColCount);
        }
    };
    // --- FIX END ---

    const actions = {
        'add-row-above': () => activeTableRow.before(createRow()),
        'add-row-below': () => activeTableRow.after(createRow()),
        'duplicate-row': () => activeTableRow.after(activeTableRow.cloneNode(true)),
        'delete-row': () => activeTableRow.remove(),
        'highlight': () => {
            const color = button.dataset.color;
            activeTableRow.className = ''; // Clear other colors
            if (color !== 'none') activeTableRow.classList.add(`bg-highlight-${color}`);
        },
        'add-col-left': () => addColumn(activeTableColIndex),
        'add-col-right': () => addColumn(activeTableColIndex + 1),
        'duplicate-col': () => {
            activeTableForAction.querySelectorAll('tr').forEach(row => {
                const cellToClone = row.children[activeTableColIndex];
                if (cellToClone) cellToClone.after(cellToClone.cloneNode(true));
            });
        },
        'delete-col': () => {
            if (colCount <= 1) return showToast("Cannot delete the last column.", "error");
            activeTableForAction.querySelectorAll('tr').forEach(row => row.children[activeTableColIndex]?.remove());
        },
        'calculate': () => {
            const type = button.dataset.calc;
            let tfoot = activeTableForAction.querySelector('tfoot');
            if (!tfoot) {
                tfoot = activeTableForAction.createTFoot();
                const newRow = tfoot.insertRow(0);
                for (let i = 0; i < colCount; i++) {
                    const newCell = newRow.insertCell();
                    newCell.contentEditable = false;
                }
            }
            const footerCell = tfoot.rows[0].cells[activeTableColIndex];

            if (type === 'clear') {
                footerCell.innerHTML = '';
                footerCell.removeAttribute('data-calc-type');
                const allFooterCells = Array.from(footerCell.parentElement.children);
                const hasOtherCalcs = allFooterCells.some(cell => cell.hasAttribute('data-calc-type'));
                if (!hasOtherCalcs) {
                    tfoot.remove();
                }
            } else {
                footerCell.dataset.calcType = type;
                performStandardCalculation(activeTableForAction, activeTableColIndex, type);
            }
        },
        'custom-calc': async () => {
            const targetHeader = activeTableForAction.querySelector(`thead tr:last-child th:nth-child(${activeTableColIndex + 1})`);
            const existingFormula = targetHeader?.dataset.formula || '';

            const formula = await showPrompt({
                title: 'Custom Column Formula',
                message: 'Enter formula using column names (e.g., Cost * Quantity) or letters (A-Z).',
                placeholder: 'e.g., Cost * 0.07',
                initialValue: existingFormula
            });

            if (formula === null) return;
            
            if (targetHeader) {
                targetHeader.dataset.formula = formula;
                performCustomFormula(activeTableForAction, activeTableColIndex, formula);
                if (formula) {
                   showToast(`Live formula updated.`, 'success');
                } else {
                   showToast(`Formula cleared for column.`, 'info');
                }
            }
        },
    };

    if (actions[action]) {
        actions[action]();
        saveNoteContent();
        hideTableContextMenu();
    }
});

app.elements.noteEditorBody.addEventListener('click', (e) => {
// Add this block inside the noteEditorBody 'click' event listener

    const toggleBtn = e.target.closest('.toggle-filter-btn');
    if (toggleBtn) {
        e.preventDefault();
        const table = toggleBtn.closest('table');
        if (table) {
            table.classList.toggle('filter-collapsed');
            saveNoteContent(); // Save the new state of the table
        }
        return; // Stop further actions
    }
    const sortableHeader = e.target.closest('th.sortable-header');
    if (sortableHeader) {
        const table = sortableHeader.closest('table');
        const tbody = table.querySelector('tbody');
        if (!tbody) return;

        const headerRow = sortableHeader.parentElement;
        const headers = Array.from(headerRow.children);
        const colIndex = headers.indexOf(sortableHeader);
        
        const currentDir = sortableHeader.dataset.sortDir;
        const newDir = currentDir === 'asc' ? 'desc' : (currentDir === 'desc' ? 'none' : 'asc');

        // Store original order if it's the first time sorting this table
        if (!table._originalRows) {
            table._originalRows = Array.from(tbody.querySelectorAll('tr'));
        }

        if (newDir === 'none') {
            tbody.append(...table._originalRows); // Revert to original order
        } else {
            let rows = Array.from(tbody.querySelectorAll('tr'));
            // Validation logic
            const firstCellText = rows.length > 0 ? rows[0].children[colIndex]?.innerText.trim() : '';
            const isNumericColumn = firstCellText && isFinite(firstCellText.replace(/[^0-9.-]+/g, ""));
            
            let canSort = true;
            if (isNumericColumn) {
                for (let row of rows) {
                    const cellText = row.children[colIndex]?.innerText.trim();
                    if (cellText && !isFinite(cellText.replace(/[^0-9.-]+/g, ""))) {
                        canSort = false;
                        break;
                    }
                }
            }
            if(!canSort) return showToast("Cannot sort: column contains mixed data types.", "error");

            // Perform sort
            rows.sort((rowA, rowB) => {
                const cellA = rowA.children[colIndex]?.innerText.trim() || '';
                const cellB = rowB.children[colIndex]?.innerText.trim() || '';
                if (isNumericColumn) {
                    const numA = parseFloat(cellA.replace(/[^0-9.-]+/g, "")) || 0;
                    const numB = parseFloat(cellB.replace(/[^0-9.-]+/g, "")) || 0;
                    return newDir === 'asc' ? numA - numB : numB - numA;
                }
                return newDir === 'asc' ? cellA.localeCompare(cellB) : cellB.localeCompare(cellA);
            });
            tbody.append(...rows);
        }

        headers.forEach(th => {
            th.dataset.sortDir = 'none';
            th.querySelector('.sort-indicator')?.remove();
        });
        if(newDir !== 'none') {
            sortableHeader.dataset.sortDir = newDir;
            sortableHeader.insertAdjacentHTML('beforeend', `<span class="sort-indicator">${newDir === 'asc' ? '▲' : '▼'}</span>`);
        }
        saveNoteContent();
    }
});

// Column Resizing Logic
app.elements.noteEditorBody.addEventListener('mousedown', (e) => {
    const header = e.target.closest('th');
    if (header) {
        const rect = header.getBoundingClientRect();
        // Check if the click is on the right border of the header
        if (rect.width - e.offsetX < 10) { 
            const table = header.closest('table');
            const startX = e.clientX;
            const startWidth = rect.width;

            const handleMouseMove = (moveEvent) => {
                const newWidth = startWidth + (moveEvent.clientX - startX);
                if (newWidth > 40) { // Minimum width
                    header.style.width = `${newWidth}px`;
                }
            };
            const handleMouseUp = () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                saveNoteContent();
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
    }
});
// --- NEW: Live Calculation Trigger ---
app.elements.noteEditorBody.addEventListener('input', (e) => {
    // Check if the edit happened inside a table cell
    const cell = e.target.closest('td');
    if (cell) {
        const table = cell.closest('table');
        if (table) {
            // Use the debounced function to update calculations
            debouncedLiveCalculate(table);
        }
    }
});
// Table Filtering Logic
// Fuzzy Table Filtering Logic
app.elements.noteEditorBody.addEventListener('input', (e) => {
    const filterInput = e.target.closest('.table-filter-input');
    if(filterInput) {
        const table = filterInput.closest('table');
        const tbody = table.querySelector('tbody');
        const filterText = filterInput.value; // No need for toLowerCase() with Fuse.js

        const rows = Array.from(tbody.querySelectorAll('tr'));

        // If the filter is empty, show all rows and exit
        if (!filterText.trim()) {
            rows.forEach(row => row.style.display = '');
            return;
        }

        // Get all rows to create the search data
        const searchData = rows.map((row, index) => ({
            id: index, // Use index as a reference
            text: row.innerText
        }));

        // Configure Fuse.js for fuzzy searching
        const fuseOptions = {
            keys: ['text'],
            includeScore: true,
            threshold: 0.4 // Adjust threshold for desired fuzziness (0.0 = perfect match, 1.0 = match anything)
        };
        const fuse = new Fuse(searchData, fuseOptions);

        // Perform the search
        const results = fuse.search(filterText);
        const visibleRowIds = new Set(results.map(result => result.item.id));

        // Show/hide rows based on search results
        rows.forEach((row, index) => {
            row.style.display = visibleRowIds.has(index) ? '' : 'none';
        });
    }
});

// Global listener to hide menus
document.addEventListener('click', (e) => {
    if (!e.target.closest('#table-context-menu')) hideTableContextMenu();
    if (!e.target.closest('#context-menu')) closeContextMenu();
});
// --- START: NEW Live Calculation Logic ---

/**
 * A debounced function to trigger live updates for a table.
 * This prevents calculations from running on every single keystroke.
 */
const debouncedLiveCalculate = debounce((table) => {
    updateTableCalculations(table);
}, 400); // 400ms delay

/**
 * Main function to update all calculations for a given table.
 * It checks for both footer calculations (sum, avg) and custom column formulas.
 */
function updateTableCalculations(table) {
    if (!table) return;

    // 1. Update footer calculations (Sum, Average, Count)
    const tfoot = table.querySelector('tfoot');
    if (tfoot) {
        tfoot.querySelectorAll('td[data-calc-type]').forEach((cell, index) => {
            performStandardCalculation(table, index, cell.dataset.calcType);
        });
    }

    // 2. Update custom formula columns
    table.querySelectorAll('thead th[data-formula]').forEach((header, index) => {
        performCustomFormula(table, index, header.dataset.formula);
    });
    
    // This ensures the note is saved after calculations are updated
    saveNoteContent();
}

/**
 * Performs a standard calculation (sum, avg, count) for a specific column.
 */
function performStandardCalculation(table, colIndex, calcType) {
    const tfoot = table.querySelector('tfoot');
    if (!tfoot || !calcType) return;
    
    const footerCell = tfoot.rows[0].cells[colIndex];
    if (!footerCell) return;

    const values = Array.from(table.querySelectorAll('tbody tr'))
        .map(row => parseFloat(row.children[colIndex]?.innerText.replace(/[^0-9.-]+/g, "")))
        .filter(n => !isNaN(n));

    if (values.length === 0) {
        footerCell.innerHTML = ''; // Clear if no numbers
        return;
    }

    let result = '';
    if (calcType === 'sum') result = `Sum: ${values.reduce((a, b) => a + b, 0).toLocaleString()}`;
    if (calcType === 'avg') result = `Avg: ${(values.reduce((a, b) => a + b, 0) / values.length).toLocaleString(undefined, {maximumFractionDigits: 2})}`;
    if (calcType === 'count') result = `Count: ${values.length}`;
    footerCell.textContent = result;
}

/**
 * Applies a custom formula to every row in a target column.
 */
function performCustomFormula(table, targetColIndex, formula) {
    const headers = Array.from(table.querySelectorAll('thead tr:last-child th'))
        .map(th => th.innerText.trim());

    const formulaRegex = /(.+?)\s*([+\-*/])\s*(.+)/;
    const match = formula.match(formulaRegex);
    if (!match) return; // Invalid formula stored

    const [, col1Raw, operator, col2Raw] = match.map(s => s.trim());

    const getIndex = (operand) => {
        let op = operand.replace(/[()]/g, '').trim();
        // 1. Check by Header Name (case-insensitive)
        const lowerOp = op.toLowerCase();
        const headerIndex = headers.findIndex(h => h.toLowerCase() === lowerOp);
        if (headerIndex !== -1) return headerIndex;

        // 2. Fallback to Letter (A, B, C...)
        if (/^[A-Z]$/i.test(op)) return op.toUpperCase().charCodeAt(0) - 65;

        return -1; // Not found
    };

    const col1Index = getIndex(col1Raw);
    const col2Index = getIndex(col2Raw);
    const col2Value = (col2Index === -1) ? parseFloat(col2Raw.replace(/[$,]/g, '')) : null;

    if (col1Index === -1 || (col2Index === -1 && isNaN(col2Value))) return; // Invalid columns in formula

    table.querySelectorAll('tbody tr').forEach(row => {
        const getNumericValue = (index) => parseFloat(row.children[index]?.innerText.replace(/[$,]/g, ''));
        const val1 = getNumericValue(col1Index);
        const val2 = col2Index !== -1 ? getNumericValue(col2Index) : col2Value;
        const targetCell = row.children[targetColIndex];

        if (isNaN(val1) || isNaN(val2) || !targetCell) {
            if(targetCell) targetCell.innerText = '';
            return;
        }

        let result;
        switch (operator) {
            case '+': result = val1 + val2; break;
            case '-': result = val1 - val2; break;
            case '*': result = val1 * val2; break;
            case '/': result = val2 !== 0 ? val1 / val2 : 'Error'; break;
            default: return;
        }
        targetCell.innerText = typeof result === 'number' ? result.toLocaleString(undefined, { maximumFractionDigits: 2 }) : result;
    });
}
// --- END: NEW Live Calculation Logic ---

// END: Final Table Interaction Logic

// END: New Table Interaction Logic

                render();
            }

            // Add this inside your init() function

// --- START: Save on Exit/Reload Logic ---
window.addEventListener('beforeunload', (e) => {
    // Check if there's an active note being edited
    if (state.settings.activeNoteId) {
        // Use the performImmediateSave function to bypass the debounce timer
        // This ensures the very latest content is saved before the page closes.
        performImmediateSave();
    }
});
// --- END: Save on Exit/Reload Logic ---
        });
        // START: Interactive Table Logic
app.elements.noteEditorBody.addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('.delete-row-btn');
    const duplicateBtn = e.target.closest('.duplicate-row-btn');
    const sortableHeader = e.target.closest('th.sortable-header');

    // Row Deletion
    if (deleteBtn) {
        e.preventDefault();
        const row = deleteBtn.closest('tr');
        if (row) {
            const confirmed = await showConfirm({
                title: 'Delete Row',
                message: 'Are you sure you want to delete this table row?',
                confirmText: 'Delete'
            });
            if (confirmed) {
                row.remove();
                saveNoteContent();
            }
        }
    }

    // Row Duplication
    if (duplicateBtn) {
        e.preventDefault();
        const row = duplicateBtn.closest('tr');
        if (row) {
            const newRow = row.cloneNode(true);
            row.after(newRow);
            feather.replace(); // Re-render icons on new row
            saveNoteContent();
        }
    }

    // Column Sorting
    if (sortableHeader) {
        e.preventDefault();
        const table = sortableHeader.closest('table');
        const tbody = table.querySelector('tbody');
        const headerRow = sortableHeader.closest('tr');
        const headers = Array.from(headerRow.querySelectorAll('th'));
        const colIndex = headers.indexOf(sortableHeader);

        // Do not sort the 'Actions' column
        if (colIndex === -1 || !headers[colIndex].classList.contains('sortable-header')) return;

        const rows = Array.from(tbody.querySelectorAll('tr'));
        const currentDir = sortableHeader.dataset.sortDir;
        const newDir = currentDir === 'asc' ? 'desc' : 'asc';

        rows.sort((rowA, rowB) => {
            const cellA = rowA.children[colIndex].innerText.trim();
            const cellB = rowB.children[colIndex].innerText.trim();
            const numA = parseFloat(cellA);
            const numB = parseFloat(cellB);

            let valA, valB;
            // Check if both values are valid, finite numbers
            if (!isNaN(numA) && !isNaN(numB) && isFinite(cellA) && isFinite(cellB)) {
                valA = numA;
                valB = numB;
            } else {
                valA = cellA.toLowerCase();
                valB = cellB.toLowerCase();
            }
            
            if (valA < valB) return newDir === 'asc' ? -1 : 1;
            if (valA > valB) return newDir === 'asc' ? 1 : -1;
            return 0;
        });

        // Reset other headers and update the current one
        headers.forEach(th => {
            th.dataset.sortDir = 'none';
            const indicator = th.querySelector('.sort-indicator');
            if (indicator) indicator.remove();
        });
        sortableHeader.dataset.sortDir = newDir;
        sortableHeader.insertAdjacentHTML('beforeend', `<span class="sort-indicator">${newDir === 'asc' ? '▲' : '▼'}</span>`);

        // Re-append sorted rows
        tbody.innerHTML = '';
        rows.forEach(row => tbody.appendChild(row));
        saveNoteContent();
    }
});

app.elements.noteEditorBody.addEventListener('keydown', (e) => {
    const target = e.target;
    if (!target.closest('table')) return;

    const cell = target.closest('td, th');
    // Ensure we are in an editable cell
    if (!cell || cell.contentEditable !== 'true') return;

    // Enter: Save and move down
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        const currentRow = cell.parentElement;
        const nextRow = currentRow.nextElementSibling;
        if (nextRow) {
            const cellInNextRow = nextRow.children[cell.cellIndex];
            if (cellInNextRow && cellInNextRow.contentEditable === 'true') {
                cellInNextRow.focus();
            }
        }
        saveNoteContent(); // Save content on Enter
    }

    // Tab: Move to the next editable cell
    if (e.key === 'Tab' && !e.shiftKey) {
        e.preventDefault();
        const currentRow = cell.parentElement;
        let nextCell = cell.nextElementSibling;

        while (nextCell && nextCell.contentEditable !== 'true') {
            nextCell = nextCell.nextElementSibling;
        }

        if (nextCell) {
            nextCell.focus();
        } else {
            let nextRow = currentRow.nextElementSibling;
            // If we are in the header (THEAD), jump to the body (TBODY)
            if (!nextRow && currentRow.parentElement.tagName === 'THEAD') {
                nextRow = currentRow.parentElement.nextElementSibling?.firstElementChild;
            }
            
            if (nextRow) {
                let firstCellOfNextRow = nextRow.querySelector('td[contenteditable="true"], th[contenteditable="true"]');
                if (firstCellOfNextRow) {
                     firstCellOfNextRow.focus();
                }
            }
        }
    }
});
// END: Interactive Table Logic
    </script>
    <script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js').then(registration => {
        console.log('ServiceWorker registration successful with scope: ', registration.scope);
      }, err => {
        console.log('ServiceWorker registration failed: ', err);
      });
    });
  }
</script>
</body>
<div id="command-prompt-container" class="hidden fixed bottom-5 left-1/2 -translate-x-1/2 w-[90%] max-w-lg z-50">
    <div class="relative">
        <div id="command-suggestions" class="hidden absolute bottom-full left-0 w-full mb-1 bg-bg-pane-dark rounded-md shadow-lg p-1 border border-border-color max-h-60 overflow-y-auto custom-scrollbar">
            </div>
        <div class="flex items-center gap-2 bg-bg-pane-dark p-2 rounded-lg shadow-2xl border border-border-color">
            <i data-feather="slash" class="w-5 h-5 text-text-tertiary"></i>
            <input type="text" id="command-input" class="w-full bg-transparent focus:outline-none text-text-primary" placeholder="Type a command..." autocomplete="off">
        </div>
    </div>
</div>
<div id="link-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-4 rounded-lg shadow-2xl w-[90vw] max-w-lg z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-3 flex-shrink-0">
        <h3 class="text-lg font-semibold">Link</h3>
        <button id="link-modal-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div class="relative flex-shrink-0 mb-2">
        <i data-feather="search" class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-text-tertiary"></i>
        <input type="text" id="link-modal-input" placeholder="Paste link or search notes" class="w-full bg-bg-main border border-border-color rounded-md py-2 pl-9 pr-3 text-sm focus:outline-none focus:ring-1 focus:ring-accent-primary">
    </div>
    <div id="link-modal-results" class="flex-grow overflow-y-auto custom-scrollbar -mr-2 pr-2">
        </div>
</div>
<div id="linked-notes-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-lg z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 id="linked-notes-title" class="text-lg font-semibold flex items-center gap-2"><i data-feather="link" class="w-5 h-5 text-accent-primary"></i>Note Connections</h3>
        <button id="linked-notes-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div id="linked-notes-content" class="flex-grow space-y-4 overflow-y-auto">
        </div>
</div>

<div id="help-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-2xl z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="terminal" class="w-5 h-5 text-accent-primary"></i>Command List</h3>
        <button id="help-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div id="help-content" class="flex-grow space-y-2 overflow-y-auto max-h-[60vh] custom-scrollbar">


        </div>
</div>
<!-- START: New Table Context Menu -->
<div id="table-context-menu" class="context-menu fixed z-50 bg-bg-pane-light shadow-2xl rounded-md p-1 border border-border-color hidden origin-top-left scale-95 opacity-0 text-sm">
    <div id="table-row-actions">
    <div class="table-menu-item" data-action="add-row-above"><i data-feather="arrow-up"></i>Insert Row Above</div>
    <div class="table-menu-item" data-action="add-row-below"><i data-feather="arrow-down"></i>Insert Row Below</div>
    <div class="table-menu-item" data-action="duplicate-row"><i data-feather="copy"></i>Duplicate Row</div>
    <div class="table-menu-item with-submenu">
        <i data-feather="edit-3"></i><span>Highlight Row</span><i data-feather="chevron-right" class="submenu-arrow"></i>
        <div class="submenu">
            <div class="table-menu-item" data-action="highlight" data-color="yellow"><span class="color-swatch bg-highlight-yellow"></span>Yellow</div>
            <div class="table-menu-item" data-action="highlight" data-color="green"><span class="color-swatch bg-highlight-green"></span>Green</div>
            <div class="table-menu-item" data-action="highlight" data-color="blue"><span class="color-swatch bg-highlight-blue"></span>Blue</div>
            <div class="table-menu-item" data-action="highlight" data-color="red"><span class="color-swatch bg-highlight-red"></span>Red</div>
            <hr class="my-1 border-border-color">
            <div class="table-menu-item" data-action="highlight" data-color="none">Clear Highlight</div>
        </div>
    </div>
    <hr class="my-1 border-border-color">
    <div class="table-menu-item text-red-500" data-action="delete-row"><i data-feather="trash-2"></i>Delete Row</div>
</div>
    <div id="table-col-actions" class="hidden">
        <div class="table-menu-item" data-action="add-col-left"><i data-feather="arrow-left"></i>Insert Column Left</div>
        <div class="table-menu-item" data-action="add-col-right"><i data-feather="arrow-right"></i>Insert Column Right</div>
        <div class="table-menu-item" data-action="duplicate-col"><i data-feather="copy"></i>Duplicate Column</div>
        <div class="table-menu-item with-submenu">
             <i data-feather="plus-circle"></i><span>Calculate</span><i data-feather="chevron-right" class="submenu-arrow"></i>
             <div class="submenu">
                <div class="table-menu-item" data-action="calculate" data-calc="sum">Sum</div>
                <div class="table-menu-item" data-action="calculate" data-calc="avg">Average</div>
                <div class="table-menu-item" data-action="calculate" data-calc="count">Count</div>
                <div class="table-menu-item" data-action="custom-calc">Custom Calculation</div>
                <hr class="my-1 border-border-color">
                <div class="table-menu-item" data-action="calculate" data-calc="clear">Clear Calculation</div>
             </div>
        </div>
        <hr class="my-1 border-border-color">
        <div class="table-menu-item text-red-500" data-action="delete-col"><i data-feather="trash-2"></i>Delete Column</div>
    </div>
</div>
<div id="checklist-edit-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-lg z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2">
            <i data-feather="check-square" class="w-5 h-5 text-accent-primary"></i>
            <span>Edit Checklist</span>
        </h3>
        <button id="checklist-modal-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>

    <div class="mb-4 flex-shrink-0">
        <label for="checklist-modal-title-input" class="text-sm font-medium text-text-secondary">Checklist Title</label>
        <input type="text" id="checklist-modal-title-input" class="w-full mt-1 bg-bg-pane-dark border border-border-color rounded-md p-2 focus:ring-2 focus:ring-accent-primary focus:outline-none">
    </div>

    <div id="checklist-modal-items" class="flex-grow space-y-2 overflow-y-auto custom-scrollbar pr-2">
        </div>

    <div class="mt-4 flex-shrink-0">
        <button id="checklist-modal-add-item-btn" class="w-full flex items-center justify-center gap-2 p-2 rounded-md text-sm text-text-secondary hover:bg-bg-pane-dark transition-colors">
            <i data-feather="plus" class="w-4 h-4"></i>
            <span>Add Item</span>
        </button>
    </div>

    <footer class="flex justify-end gap-3 mt-6 flex-shrink-0">
        <button id="checklist-modal-cancel-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Cancel</button>
        <button id="checklist-modal-save-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Save Changes</button>
    </footer>
</div>
<!-- END: New Table Context Menu -->
 <div id="version-history-modal" class="modal hidden fixed inset-0 md:inset-auto md:top-1/2 md:left-1/2 md:-translate-x-1/2 md:-translate-y-1/2 bg-bg-pane-light md:rounded-lg shadow-2xl w-screen h-screen md:w-[90vw] md:max-w-6xl md:h-[80vh] z-[999] transition-all duration-300 transform scale-95 opacity-0 flex flex-col md:border-2 border-border-color">
    <header class="flex justify-between items-center p-4 border-b border-border-color flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2">
            <i data-feather="history" class="w-5 h-5 text-accent-primary"></i>
            <span id="version-history-title">Version History</span>
        </h3>
        <div class="flex items-center gap-3">
            <button id="version-restore-btn" class="brand-button text-sm">Restore</button>
            <button id="version-history-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
        </div>
    </header>
    

    <div class="flex flex-col md:flex-row flex-grow min-h-0">
        <div id="version-sidebar" class="w-full md:w-80 bg-bg-pane-dark p-2 flex flex-col flex-shrink-0 border-b md:border-b-0 md:border-r border-border-color">
            <div class="p-1 flex-shrink-0 hidden md:block">
                <button id="compare-versions-btn" class="w-full text-sm brand-button opacity-50" disabled>
                    <i data-feather="git-pull-request" class="w-4 h-4 mr-2"></i>Compare Selected
                </button>
            </div>
            <div class="p-1 pt-2 flex-shrink-0">
                <div class="relative">
                    <i data-feather="search" class="absolute left-2 top-1/2 -translate-y-1/2 w-4 h-4 text-text-tertiary"></i>
                    <input type="text" id="version-search-input" placeholder="Search versions..." class="w-full bg-bg-main border border-border-color rounded-md py-1 pl-8 pr-2 text-sm focus:outline-none focus:ring-1 focus:ring-accent-primary">
                </div>
            </div>
            <div id="version-list-container" class="space-y-1 overflow-y-auto custom-scrollbar flex-grow h-48 md:h-auto">
                </div>
        </div>

        <div id="version-content-viewer" class="flex-grow p-6 overflow-y-auto custom-scrollbar prose max-w-none">
            </div>
    </div>
</div>
<div id="properties-menu" class="context-menu fixed z-50 bg-bg-pane-light shadow-2xl rounded-md p-2 w-48 border border-border-color hidden origin-top-left scale-95 opacity-0 text-sm">
    <div class="text-xs text-text-tertiary px-2 pt-1 pb-2 font-semibold uppercase">Property Type</div>
    <button data-prop-type="text" class="w-full text-left px-3 py-1.5 hover:bg-bg-pane-dark rounded flex items-center gap-2">
        <i data-feather="type" class="w-4 h-4"></i>Text
    </button>
    <button data-prop-type="number" class="w-full text-left px-3 py-1.5 hover:bg-bg-pane-dark rounded flex items-center gap-2">
        <i data-feather="hash" class="w-4 h-4"></i>Number
    </button>
    <button data-prop-type="date" class="w-full text-left px-3 py-1.5 hover:bg-bg-pane-dark rounded flex items-center gap-2">
        <i data-feather="calendar" class="w-4 h-4"></i>Date
    </button>
    <button data-prop-type="select" class="w-full text-left px-3 py-1.5 hover:bg-bg-pane-dark rounded flex items-center gap-2">
        <i data-feather="chevron-down" class="w-4 h-4"></i>Select
    </button>
    <button data-prop-type="image" class="w-full text-left px-3 py-1.5 hover:bg-bg-pane-dark rounded flex items-center gap-2">
    <i data-feather="image" class="w-4 h-4"></i>Image URL
</button>

</div>
<div id="select-property-menu" class="context-menu fixed z-[60] bg-bg-pane-light shadow-2xl rounded-md p-2 w-56 border border-border-color hidden origin-top-left scale-95 opacity-0 text-sm flex flex-col">
    <div class="px-2 pb-1">
        <input type="text" id="select-property-filter" placeholder="Find or create an option..." class="w-full bg-bg-main border border-border-color rounded-md py-1 px-2 text-sm focus:outline-none focus:ring-1 focus:ring-accent-primary">
    </div>
    <div id="select-property-options" class="flex-grow overflow-y-auto custom-scrollbar space-y-1 py-1">
        </div>
</div>
<div id="add-property-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-md z-50 transition-all duration-300 transform scale-95 opacity-0">
    <header class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold">Add New Property</h3>
        <button id="add-property-modal-close-btn" class="p-2 -mr-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>

    <div class="space-y-4">
        <div>
            <label for="new-prop-name-input" class="text-sm font-medium text-text-secondary">Property Name</label>
            <input type="text" id="new-prop-name-input" placeholder="e.g., Status, Priority..." class="w-full mt-1 bg-bg-pane-dark border border-border-color rounded-md p-2 focus:ring-2 focus:ring-accent-primary focus:outline-none">
        </div>
        <div>
            <label class="text-sm font-medium text-text-secondary">Property Type</label>
            <div id="new-prop-type-selector" class="grid grid-cols-2 gap-2 mt-2">
                <label class="prop-type-option"><input type="radio" name="prop-type" value="text" checked><span><i data-feather="type"></i>Text</span></label>
                <label class="prop-type-option"><input type="radio" name="prop-type" value="number"><span><i data-feather="hash"></i>Number</span></label>
                <label class="prop-type-option"><input type="radio" name="prop-type" value="date"><span><i data-feather="calendar"></i>Date</span></label>
                <label class="prop-type-option"><input type="radio" name="prop-type" value="select"><span><i data-feather="chevron-down"></i>Select</span></label>
                <label class="prop-type-option"><input type="radio" name="prop-type" value="image"><span><i data-feather="image"></i>Image URL</span></label>
            </div>
        </div>
        
        <div id="new-prop-value-container" class="hidden">
            <label for="new-prop-value-input" class="text-sm font-medium text-text-secondary">Initial Value</label>
            <div id="new-prop-value-input-wrapper" class="mt-1"></div>
        </div>

        <p id="add-property-error" class="text-red-500 text-sm h-5"></p>
    </div>

    <footer class="flex justify-end gap-3 mt-6">
        <button id="add-property-cancel-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Cancel</button>
        <button id="create-property-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Create Property</button>
    </footer>
</div>
<div id="notion-style-mobile-menu" class="fixed inset-0 bg-bg-pane-light z-[1000] flex flex-col transition-transform duration-300 ease-in-out -translate-x-full">
    
    <header class="relative flex justify-between items-center p-4 border-b border-border-color flex-shrink-0">
    <div id="mobile-menu-profile-activator" class="flex items-center gap-3 cursor-pointer">
        <button class="w-8 h-8 rounded-full bg-gradient-to-r from-[var(--brand-grad-from)] to-[var(--brand-grad-to)] flex items-center justify-center font-bold text-white pointer-events-none">
            <div id="menu-user-initial">R</div>
        </button>
        <div>
            <div id="menu-workspace-title" class="font-semibold text-text-primary">Workspace</div>
            <div id="menu-user-email" class="text-xs text-text-secondary"></div>
        </div>
    </div>
    <button id="mobile-menu-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark">
        <i data-feather="x" class="w-6 h-6"></i>
    </button>

    <div id="mobile-profile-dropdown" class="dropdown-menu hidden absolute top-full left-4 mt-2 w-60 bg-bg-pane-dark shadow-2xl rounded-md p-1 border border-border-color origin-top-left z-20">
        <div class="px-2 py-2 border-b border-border-color">
            <p class="text-sm font-semibold text-text-primary">Signed in as</p>
            <p id="dropdown-user-email-display" class="text-sm text-text-secondary truncate"></p>
        </div>
        <div class="p-1">
            <a href="#" id="mobile-sign-out-link" class="w-full text-left px-2 py-1.5 text-sm hover:bg-bg-main text-red-500 rounded flex items-center gap-2">
                <i data-feather="log-out" class="w-4 h-4"></i>
                <span>Sign Out</span>
            </a>
        </div>
    </div>
</header>

    <div id="notion-menu-content" class="flex-grow overflow-y-auto custom-scrollbar p-2">
        <div id="jump-back-in-section" class="p-2"></div>

        <div id="private-section" class="p-2"></div>
    </div>
    <footer class="flex justify-around items-center p-2 border-t border-border-color flex-shrink-0">
    <button id="mobile-menu-settings-btn" class="flex-1 flex items-center justify-center gap-2 p-2 rounded-lg hover:bg-bg-pane-dark text-text-secondary">
        <i data-feather="settings" class="w-5 h-5"></i>
        <span>Settings</span>
    </button>
    <button id="mobile-menu-tags-btn" class="flex-1 flex items-center justify-center gap-2 p-2 rounded-lg hover:bg-bg-pane-dark text-text-secondary">
        <i data-feather="tag" class="w-5 h-5"></i>
        <span>Tags</span>
    </button>
    <button id="mobile-menu-add-folder-btn" class="flex-1 flex items-center justify-center gap-2 p-2 rounded-lg hover:bg-bg-pane-dark text-text-secondary">
        <i data-feather="folder-plus" class="w-5 h-5"></i>
        <span>New Folder</span>
    </button>
</footer>

</div>
<div id="mobile-settings-popup" class="fixed inset-0 bg-bg-pane-light z-[1001] flex flex-col transition-transform duration-300 ease-in-out translate-x-full">
    
    <header class="flex items-center p-4 border-b border-border-color flex-shrink-0">
        <button id="mobile-settings-back-btn" class="p-2 -ml-2 rounded-full hover:bg-bg-pane-dark">
            <i data-feather="arrow-left" class="w-6 h-6"></i>
        </button>
        <h3 class="text-lg font-semibold ml-2">Settings</h3>
    </header>

    <div id="mobile-settings-content" class="flex-grow overflow-y-auto custom-scrollbar p-2">
        <div class="space-y-1 p-2">
            <button id="mobile-theme-toggle" class="w-full text-left px-3 py-3 text-base hover:bg-bg-pane-dark rounded-lg flex items-center gap-4 text-text-primary">
               <i data-feather="star" id="mobile-theme-icon" class="w-5 h-5"></i>
               <span id="mobile-theme-text">Reputify Theme</span>
            </button>
            <button data-action="import" class="w-full text-left px-3 py-3 text-base hover:bg-bg-pane-dark rounded-lg flex items-center gap-4 text-text-primary">
                <i data-feather="upload" class="w-5 h-5"></i>
                <span>Import Data</span>
            </button>
            <button data-action="export" class="w-full text-left px-3 py-3 text-base hover:bg-bg-pane-dark rounded-lg flex items-center gap-4 text-text-primary">
                <i data-feather="download" class="w-5 h-5"></i>
                <span>Export Data</span>
            </button>
            <div id="mobile-chatbot-toggle" class="w-full text-left px-3 py-3 text-base rounded-lg flex items-center justify-between gap-4 text-text-primary cursor-pointer hover:bg-bg-pane-dark">
                <div class="flex items-center gap-4">
                    <i data-feather="message-square" class="w-5 h-5"></i>
                    <span>Show Chatbot Button</span>
                </div>
                <div class="toggle-switch" data-setting="chatbotVisible">
                    <div class="toggle-knob"></div>
                </div>
            </div>
            <button id="mobile-bookmarklet-btn" class="w-full text-left px-3 py-3 text-base hover:bg-bg-pane-dark rounded-lg flex items-center gap-4 text-text-primary">
                <i data-feather="book" class="w-5 h-5"></i>
                <span>Web Clipper</span>
            </button>
            <div id="mobile-properties-toggle" class="w-full text-left px-3 py-3 text-base rounded-lg flex items-center justify-between gap-4 text-text-primary cursor-pointer hover:bg-bg-pane-dark">
                <div class="flex items-center gap-4">
                    <i data-feather="eye" class="w-5 h-5"></i>
                    <span>Hide Properties</span>
                </div>
                <div class="toggle-switch" data-setting="propertiesVisible">
                    <div class="toggle-knob"></div>
                </div>
            </div>
        </div>
    </div>
</div>
<div id="mobile-tags-popup" class="fixed inset-0 bg-bg-pane-light z-[1001] flex flex-col transition-transform duration-300 ease-in-out translate-x-full">
    
    <header class="flex items-center p-4 border-b border-border-color flex-shrink-0">
        <button id="mobile-tags-back-btn" class="p-2 -ml-2 rounded-full hover:bg-bg-pane-dark">
            <i data-feather="arrow-left" class="w-6 h-6"></i>
        </button>
        <h3 class="text-lg font-semibold ml-2">Tags</h3>
    </header>

    <div id="mobile-tags-content" class="flex-grow overflow-y-auto custom-scrollbar p-2">
        </div>
</div>
<div id="assign-note-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-4 rounded-lg shadow-2xl w-[90vw] max-w-lg z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-3 flex-shrink-0">
        <h3 id="assign-note-modal-title" class="text-lg font-semibold">Assign Note to Date</h3>
        <button id="assign-note-modal-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div class="relative flex-shrink-0 mb-2">
        <i data-feather="search" class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-text-tertiary"></i>
        <input type="text" id="assign-note-search-input" placeholder="Search notes in this project..." class="w-full bg-bg-main border border-border-color rounded-md py-2 pl-9 pr-3 text-sm focus:outline-none focus:ring-1 focus:ring-accent-primary">
    </div>
    <div id="assign-note-duration-wrapper" class="relative flex-shrink-0 mb-2">
    <label for="assign-note-duration-input" class="text-sm font-medium text-text-secondary">Duration</label>
    <input type="text" id="assign-note-duration-input" placeholder="e.g., 30m, 1.5h, 90 (defaults to 1 hour)" class="w-full mt-1 bg-bg-main border border-border-color rounded-md py-2 px-3 text-sm focus:outline-none focus:ring-1 focus:ring-accent-primary">
</div>
    <div id="assign-note-list" class="flex-grow overflow-y-auto custom-scrollbar -mr-2 pr-2">
        </div>
</div>
<div id="chatbot-context-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-4 rounded-lg shadow-2xl w-[90vw] max-w-lg z-[1000] transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-3 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="file-plus" class="w-5 h-5 text-accent-primary"></i>Add Context from Notes</h3>
        <button id="chatbot-context-modal-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div class="relative flex-shrink-0 mb-2">
        <i data-feather="search" class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-text-tertiary"></i>
        <input type="text" id="chatbot-context-search-input" placeholder="Search notes..." class="w-full bg-bg-main border border-border-color rounded-md py-2 pl-9 pr-3 text-sm focus:outline-none focus:ring-1 focus:ring-accent-primary">
    </div>
    <div id="chatbot-context-note-list" class="flex-grow overflow-y-auto custom-scrollbar -mr-2 pr-2 space-y-1">
        </div>
    <footer class="flex justify-end gap-3 mt-4 flex-shrink-0">
        <button id="chatbot-context-cancel-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Cancel</button>
        <button id="chatbot-context-confirm-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Add Context</button>
    </footer>
</div>
<div id="calculator-modal" class="modal hidden fixed top-1/4 left-1/2 -translate-x-1/2 bg-bg-pane-dark p-3 rounded-lg shadow-2xl w-[280px] z-[1001] transition-all duration-300 transform scale-95 opacity-0 flex flex-col" style="resize: both; overflow: hidden;">
    <header id="calculator-header" class="flex justify-between items-center pb-2 mb-2 border-b border-border-color cursor-move flex-shrink-0">
        <h3 class="text-sm font-semibold flex items-center gap-2">
            <i data-feather="cpu" class="w-4 h-4 text-accent-primary"></i>
            <span>Calculator</span>
        </h3>
        <button id="calculator-close-btn" class="p-1 rounded-full hover:bg-bg-main"><i data-feather="x" class="w-4 h-4"></i></button>
    </header>
    <div class="flex-grow flex flex-col gap-3">
        <input type="text" id="calculator-display" class="w-full bg-bg-main text-right text-3xl font-light p-3 rounded-md border border-border-color focus:outline-none focus:ring-2 focus:ring-accent-primary" readonly>
        <div id="calculator-buttons" class="grid grid-cols-4 gap-2">
            <button class="calc-btn bg-bg-pane-light">C</button>
            <button class="calc-btn bg-bg-pane-light">CE</button>
            <button class="calc-btn bg-bg-pane-light">%</button>
            <button class="calc-btn operator-btn">/</button>
            <button class="calc-btn">7</button>
            <button class="calc-btn">8</button>
            <button class="calc-btn">9</button>
            <button class="calc-btn operator-btn">*</button>
            <button class="calc-btn">4</button>
            <button class="calc-btn">5</button>
            <button class="calc-btn">6</button>
            <button class="calc-btn operator-btn">-</button>
            <button class="calc-btn">1</button>
            <button class="calc-btn">2</button>
            <button class="calc-btn">3</button>
            <button class="calc-btn operator-btn">+</button>
            <button class="calc-btn col-span-2">0</button>
            <button class="calc-btn">.</button>
            <button class="calc-btn equals-btn">=</button>
        </div>
    </div>
</div>
<div id="template-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-4 rounded-lg shadow-2xl w-[90vw] max-w-2xl z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-3 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2">
            <i data-feather="file-plus" class="w-5 h-5 text-accent-primary"></i>
            <span>Create from Template</span>
        </h3>
        <button id="template-modal-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div class="relative flex-shrink-0 mb-2">
        <i data-feather="search" class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-text-tertiary"></i>
        <input type="text" id="template-search-input" placeholder="Search templates..." class="w-full bg-bg-main border border-border-color rounded-md py-2 pl-9 pr-3 text-sm focus:outline-none focus:ring-1 focus:ring-accent-primary">
    </div>
    <div id="template-list-container" class="flex-grow overflow-y-auto custom-scrollbar -mr-2 pr-2 grid grid-cols-1 md:grid-cols-2 gap-2">
        </div>
    <footer class="flex justify-end gap-3 mt-4 flex-shrink-0 border-t border-border-color pt-3">
         <button id="manage-templates-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80 text-sm">Manage Templates</button>
    </footer>
</div>
<div id="manage-templates-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-4 rounded-lg shadow-2xl w-[90vw] max-w-lg z-[999] transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-3 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2">
            <i data-feather="edit" class="w-5 h-5 text-accent-primary"></i>
            <span>Manage Templates</span>
        </h3>
        <button id="manage-templates-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div id="manage-template-list" class="flex-grow overflow-y-auto custom-scrollbar -mr-2 pr-2 space-y-2 max-h-[60vh]">
        </div>
    <footer class="flex justify-end gap-3 mt-4 flex-shrink-0 border-t border-border-color pt-3">
         <button id="manage-templates-done-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90 text-sm">Done</button>
    </footer>
</div>
<div id="timer-modal" class="modal hidden fixed top-1/4 left-1/2 -translate-x-1/2 bg-bg-pane-dark p-3 rounded-lg shadow-2xl w-[280px] z-[1001] transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header id="timer-header" class="flex justify-between items-center pb-2 mb-2 border-b border-border-color cursor-move flex-shrink-0">
        <h3 class="text-sm font-semibold flex items-center gap-2">
            <i data-feather="clock" class="w-4 h-4 text-accent-primary"></i>
            <span>Timer / Stopwatch</span>
        </h3>
        <button id="timer-close-btn" class="p-1 rounded-full hover:bg-bg-main"><i data-feather="x" class="w-4 h-4"></i></button>
    </header>
    <div class="flex-grow flex flex-col gap-3">
        <div id="timer-display" class="w-full bg-bg-main text-center text-5xl font-light p-3 rounded-md border border-border-color tracking-wider">00:00:00</div>
        
        <div id="timer-input-container" class="flex gap-2">
            <input type="text" id="timer-input" placeholder="e.g., 15m, 1.5h" class="w-full bg-bg-pane-light border border-border-color rounded-md p-2 focus:ring-2 focus:ring-accent-primary focus:outline-none">
            <button id="timer-set-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Set</button>
        </div>

        <div id="timer-controls" class="grid grid-cols-2 gap-2">
            <button id="timer-start-stop-btn" class="calc-btn brand-button col-span-2">Start</button>
            <button id="timer-reset-btn" class="calc-btn bg-bg-pane-light">Reset</button>
            <button id="timer-lap-btn" class="calc-btn bg-bg-pane-light" disabled>Lap</button>
        </div>
        <div id="timer-laps-container" class="text-xs text-text-secondary max-h-24 overflow-y-auto custom-scrollbar space-y-1 p-1"></div>
    </div>
</div>
<div id="invitation-toast-container" class="fixed bottom-4 right-4 z-[1001] flex flex-col items-end gap-3">
    </div>
<div id="share-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-lg z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2">
            <i data-feather="users" class="w-5 h-5 text-accent-primary"></i>
            <span>Share Note</span>
        </h3>
        <button id="share-modal-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>

    <div class="mb-4">
        <label for="share-email-input" class="text-sm font-medium text-text-secondary">Invite by Email</label>
        <div class="flex items-center gap-2 mt-1">
            <input type="email" id="share-email-input" placeholder="person@example.com" class="flex-grow bg-bg-pane-dark border border-border-color rounded-md p-2 focus:ring-2 focus:ring-accent-primary focus:outline-none">
            <button id="share-invite-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Invite</button>
        </div>
        <p id="share-error" class="text-red-500 text-sm h-5 mt-1"></p>
    </div>

    <div class="flex-grow space-y-2 overflow-y-auto custom-scrollbar -mr-3 pr-3">
        <h4 class="text-sm font-semibold text-text-secondary">Shared With</h4>
        <div id="share-collaborators-list">
            </div>
    </div>

    <footer class="flex justify-end gap-3 mt-6 flex-shrink-0 pt-4 border-t border-border-color">
        <button id="share-done-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Done</button>
    </footer>
</div>
<div id="sharing-management-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-lg z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="share-2" class="w-5 h-5 text-accent-primary"></i>Manage Sharing</h3>
        <button id="sharing-modal-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>

    <div class="flex-grow overflow-y-auto custom-scrollbar -mr-3 pr-3 space-y-4 max-h-[60vh]">
        <div id="shared-by-me-section">
            <h4 class="font-semibold text-text-secondary mb-2">Notes You Are Sharing</h4>
            <div id="shared-by-me-list" class="space-y-2"></div>
        </div>
        <hr class="my-4 border-border-color">
        <div id="shared-with-me-section">
            <h4 class="font-semibold text-text-secondary mb-2">Notes Shared With You</h4>
            <div id="shared-with-me-list" class="space-y-2"></div>
        </div>
    </div>
    
    <footer class="flex justify-end mt-6 flex-shrink-0 pt-4 border-t border-border-color">
        <button id="sharing-modal-done-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Done</button>
    </footer>
</div>
</body>
</html>
