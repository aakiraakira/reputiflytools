<!DOCTYPE html>
<html lang="en" class="reputify-theme">
<head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reputifly | AI Note Taker</title>
    <link rel="icon" type="image/png" href="https://media.licdn.com/dms/image/v2/D560BAQEScnUkJITXAg/company-logo_200_200/B56ZajOckKHsAI-/0/1746495195792?e=2147483647&v=beta&t=Z7yQpp5jSwm-De46D45WIC5fY_2w0GVgEWLoEOM1aug">
    <meta name="theme-color" id="theme-color-meta" content="#100F1B">
    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://unpkg.com/feather-icons"></script>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css">
    <link rel="manifest" href="manifest.json">
    <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js' defer></script>
    <script src="https://cdn.jsdelivr.net/npm/lunr/lunr.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script> <!-- ADD THIS LINE -->
 
        <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.1/dist/browser-image-compression.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.1/dist/browser-image-compression.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    

    <script>
      // Initialize Tailwind CSS custom theme
      
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'accent-primary': 'var(--accent-primary)',
              'accent-primary-dark': 'var(--accent-primary-dark)',
              'bg-main': 'var(--bg-main)',
              'bg-pane-light': 'var(--bg-pane-light)',
              'bg-pane-dark': 'var(--bg-pane-dark)',
              'text-primary': 'var(--text-primary)',
              'text-secondary': 'var(--text-secondary)',
              'text-tertiary': 'var(--text-tertiary)',
              'border-color': 'var(--border-color)',
            }
          }
        }
      }
    </script>

    <style type="text/tailwindcss">
        /* --- Base & Color Variables --- */

        :root {
            --bg-main: #FFFFFF;
            --bg-pane-light: #F9F9F9;
            --bg-pane-dark: #F4F4F4;
            --text-primary: #1a1a1a;
            --text-secondary: #555555;
            --text-tertiary: #888888;
            --accent-primary: #007aff;
            --accent-primary-dark: #007aff;
            --border-color: #EAEAEA;
            --shadow-color: rgba(0, 0, 0, 0.05);
            --brand-grad-from: #007aff;
            --brand-grad-to: #007aff;
        }
        

        .dark {
            --bg-main: #111827;
            --bg-pane-light: #1f2937;
            --bg-pane-dark: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-tertiary: #9ca3af;
            --accent-primary: #3898ff;
            --accent-primary-dark: #007aff;
            --border-color: #374151;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --brand-grad-from: #3898ff;
            --brand-grad-to: #3898ff;
        }

        .reputify-theme {
            --bg-main: #100F1B;
            --bg-pane-light: #181624;
            --bg-pane-dark: #211F30;
            --text-primary: #F0F0F0;
            --text-secondary: #A0A0B8;
            --text-tertiary: #6C6A7E;
            --accent-primary: #E6397F;
            --accent-primary-dark: #FF8A00;
            --border-color: #2A2837;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --brand-grad-from: #E6397F;
            --brand-grad-to: #FF8A00;
        }
        .reputify-theme .prose {
    color: var(--text-secondary);
}
#version-content-viewer.prose {
    color: var(--text-primary);
}
.help-command-row {
    display: grid;
    grid-template-columns: 160px 1fr;
    align-items: center; /* This is the only change */
    gap: 1rem;
}
.reputify-theme .prose {
    color: var(--text-primary); /* This changes the main text to white */
}
.in-note-highlight.current {
    background-color: var(--accent-primary-dark);
    color: var(--bg-main);
}
.reputify-theme .prose h1,
.reputify-theme .prose h2,
.reputify-theme .prose h3,
.reputify-theme .prose strong {
    color: var(--text-primary);
}
.reputify-theme .prose a {
    color: var(--accent-primary);
}
.reputify-theme .prose code {
    color: var(--accent-primary-dark);
}
.reputify-theme .prose blockquote {
    color: var(--text-tertiary);
    border-color: var(--border-color);
}
/* Add these styles for checklist items */
/* Add these styles for checklist items */
/* UPDATED: Styles for checklist items in editor AND public view */
/* --- START: Simplified Checklist Styles --- */
/* --- START: Enhanced Checklist Styles --- */
/* --- START: Final Checklist Alignment Fix --- */
/* --- START: Final Checklist Alignment Fix --- */
/* --- START: New Checklist Container Styles --- */
.checklist-container {
    background-color: var(--bg-pane-dark);
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    margin: 1em 0;
    padding: 0.75rem 1rem;
    user-select: none; /* Prevent text selection in view mode */
}

.checklist-header {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 0.25rem;
    /* The margin makes the header span the full width of the parent */
    margin: -0.75rem -1rem 0.75rem -1rem;
    padding: 0.5rem 1rem; /* This is the only line that changed */
    border-bottom: 1px solid var(--border-color);
    /* Make the top corners rounded */
    border-radius: 0.5rem 0.5rem 0 0;
    /* Use a subtle, transparent black for a clean look */
    background-color: rgba(0, 0, 0, 0.1); 
}

.checklist-header-btn {
    padding: 0.25rem;
    border-radius: 0.25rem;
    color: var(--text-tertiary);
    background: none;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;
}
.checklist-header-btn:hover {
    background-color: var(--bg-pane-light);
    color: var(--text-primary);
}
.checklist-header-btn.delete:hover {
    color: #ef4444; /* red-500 */
}

.checklist-body {
    padding-left: 0;
    margin: 0;
    list-style: none;
}

.checklist-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.25rem 0;
    cursor: pointer;
}

.checklist-item-checkbox {
    width: 1.25rem;
    height: 1.25rem;
    flex-shrink: 0;
}

.checklist-item-text {
    flex-grow: 1;
    color: var(--text-secondary);
    transition: color 0.2s;
}

.checklist-item.checked .checklist-item-text {
    text-decoration: line-through;
    color: var(--text-tertiary);
}

/* Styles for the Edit Modal */
.checklist-modal-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}
.checklist-modal-item input[type="text"] {
    flex-grow: 1;
    background-color: var(--bg-pane-dark);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 6px 10px;
    color: var(--text-primary);
    outline: none;
}
.checklist-modal-item input[type="text"]:focus {
    border-color: var(--accent-primary);
}
.checklist-modal-item-btn {
    padding: 0.25rem;
    color: var(--text-tertiary);
    cursor: pointer;
}
.checklist-modal-item-btn:hover {
    color: var(--text-primary);
}
/* --- END: New Checklist Container Styles --- */
.checklist-progress-container {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 0.75rem; 
}

.checklist-progress-bar {
    flex-grow: 1;
    height: 8px;
    background-color: var(--bg-pane-light);
    border-radius: 9999px;
    overflow: hidden;
}

.checklist-progress-fill {
    height: 100%;
    background-color: var(--accent-primary);
    border-radius: 9999px;
    transition: width 0.3s ease-in-out;
}

.checklist-progress-text {
    font-size: 0.75rem;
    color: var(--text-tertiary);
    flex-shrink: 0;
}
/* --- END: Final Checklist Alignment Fix --- */
/* --- START: Share Note Checklist Fix --- */
#public-note-content .task-list-item {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    margin: 0.5rem 0;
    list-style: none;
    padding-left: 0;
}

#public-note-content .task-list-item input[type="checkbox"] {
    flex-shrink: 0;
    width: 1.25rem;
    height: 1.25rem;
    
}

/* --- START: Final Interactive Table CSS --- */
/* --- START: Final Polished Table CSS --- */
#note-editor-body table {
    table-layout: fixed;
    width: 100%;
    border-spacing: 0; /* Ensures borders are clean */
}
#note-editor-body th.sortable-header {
    cursor: pointer;
    position: relative;
    padding-right: 20px;
    user-select: none;
}
#note-editor-body th .sort-indicator {
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 1em;
    color: var(--accent-primary);
}
/* --- START: Modal Click Fix --- */
/* --- START: Modal Click Fix --- */
#modal-backdrop { display: none !important; }
/* --- END: Modal Click Fix --- */

/* --- END: Modal Click Fix --- */
#note-editor-body th.sortable-header:hover::after {
    content: 'â†•';
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-tertiary);
    font-weight: normal;
    opacity: 0.7;
}
#note-editor-body th.sortable-header[data-sort-dir="asc"]:hover::after,
#note-editor-body th.sortable-header[data-sort-dir="desc"]:hover::after {
    content: '';
}
/* --- NEW: Cell Focus Outline --- */
#note-editor-body td:focus,
#note-editor-body th:focus {
    outline: 2px solid var(--accent-primary) !important;
    outline-offset: -2px; /* Pulls outline inside the cell */
    z-index: 5;
    position: relative;
}
.column-resizer {
    position: absolute;
    top: 0;
    right: -3px;
    width: 6px;
    height: 100%;
    cursor: col-resize;
    z-index: 10;
}
/* --- NEW: Nicer Filter Bar --- */
.table-filter-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    padding: 4px 0;
}
.table-filter-wrapper .filter-icon {
    position: absolute;
    left: 12px; /* Slightly more space from the edge */
    top: 50%;
    transform: translateY(-50%);
    width: 1rem; /* 16px */
    height: 1rem; /* 16px */
    color: var(--text-tertiary);
    pointer-events: none;
    transition: color 0.2s ease; /* Adds a slick transition */
}
.table-filter-input:focus + .filter-icon,
.table-filter-wrapper:focus-within .filter-icon {
    color: var(--accent-primary);
}
.table-filter-input {
    width: 100%;
    background-color: var(--bg-pane-dark);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 6px 10px 6px 36px; /* Left padding for icon */
    font-size: 0.9em;
    color: var(--text-primary);
    transition: border-color 0.2s;
}
.table-filter-input:focus {
    outline: none;
    border-color: var(--accent-primary);
}
.table-filter-clear-btn {
    position: absolute;
    right: 10px;
    color: var(--text-tertiary);
    cursor: pointer;
    background: none;
    border: none;
    padding: 2px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;
}
.table-filter-input:not(:placeholder-shown) + .table-filter-clear-btn {
    opacity: 1;
    pointer-events: auto;
}
/* --- End Filter Bar --- */
.table-menu-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.5rem;
    border-radius: 4px;
    cursor: pointer;
    position: relative;
}
.table-menu-item:hover { background-color: var(--bg-pane-dark); }
.table-menu-item .submenu-arrow { margin-left: auto; }
.table-menu-item .submenu {
    display: none;
    position: absolute;
    left: 100%;
    top: -5px;
    background-color: var(--bg-pane-light);
    border-radius: 6px;
    padding: 0.25rem;
    border: 1px solid var(--border-color);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    width: max-content;
}
.table-menu-item:hover > .submenu { display: block; }
.color-swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
}
.bg-highlight-yellow { background-color: rgba(250, 204, 21, 0.2); }
.bg-highlight-green { background-color: rgba(74, 222, 128, 0.2); }
.bg-highlight-blue { background-color: rgba(96, 165, 250, 0.2); }
.bg-highlight-red { background-color: rgba(248, 113, 113, 0.2); }
#note-editor-body tfoot td {
    font-weight: bold;
    color: var(--text-secondary);
    background-color: var(--bg-pane-dark);
    padding: 8px;
    border-top: 2px solid var(--border-color);
}
/* --- END: Final Polished Table CSS --- */
/* --- END: New Interactive Table CSS --- */

/* --- START: Public Page Code Block Style Fix --- */
/* --- START: FINAL Public Page Code Block Style Fix --- */
#public-note-content .code-block-wrapper {
    background-color: #211F30; /* A dark background matching your reputify theme */
    border: 1px solid #2A2837;
    border-radius: 8px;
    overflow: hidden;
    margin: 1.5em 0;
}
#public-note-content .code-block-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: rgba(0,0,0,0.2);
    padding: 0.5rem 1rem;
    color: #A0A0B8;
    font-size: 0.8rem;
}
/* --- START: Table Filter Toggle CSS --- */

/* New wrapper to hold the filter and the toggle button */
.table-header-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem; /* 8px */
}

/* Makes the filter input container grow to fill available space */
.table-header-controls .table-filter-wrapper {
    flex-grow: 1;
}

/* Styles for the new collapse/expand button */
.toggle-filter-btn {
    padding: 0.25rem; /* 4px */
    border-radius: 0.25rem; /* 4px */
    background: none;
    border: none;
    color: var(--text-tertiary);
    cursor: pointer;
    flex-shrink: 0; /* Prevents the button from shrinking */
    transition: all 0.2s ease;
}

.toggle-filter-btn:hover {
    background-color: var(--bg-pane-dark);
    color: var(--text-primary);
}

/* The transition for the icon's rotation */
.toggle-filter-btn > i {
    transition: transform 0.2s ease-in-out;
}

/* Hides the filter input when the table is collapsed */
table.filter-collapsed .table-filter-wrapper {
    display: none;
}

/* Rotates the chevron icon down when the table is collapsed */
table.filter-collapsed .toggle-filter-btn > i {
    transform: rotate(180deg);
}

/* --- END: Table Filter Toggle CSS --- */
.exit-code-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 0.25rem 0.5rem;
    border-radius: 5px;
    transition: background-color 0.2s, color 0.2s;
}
.exit-code-btn:hover {
    background-color: var(--bg-pane-light);
    color: var(--accent-primary);
}
#public-note-content .code-block-wrapper pre {
    margin: 0 !important;
    padding: 1em !important;
}
/* This is the most important part: it makes the inner code block transparent */
#public-note-content .code-block-wrapper pre code.hljs {
    background: transparent !important;
    padding: 0 !important;
}
/* --- START: Checklist Interaction Fix --- */
/* Prevents direct text editing of checklist items in the main editor */
#note-editor-body .checklist-item-text {
    pointer-events: none;
    user-select: none;
    cursor: default; /* Reinforces non-interactive nature */
}
/* --- START: Checklist Modal Handle Style --- */
/* --- START: Checklist Modal Handle Style --- */
.checklist-modal-item .handle {
    display: inline-flex;
    touch-action: none;
    cursor: grab;
}

/* Style for the item being dragged */
.checklist-modal-item.dragging {
    opacity: 0.5;
    background-color: var(--bg-pane-dark);
}
/* --- END: Checklist Modal Handle Style --- */
/* --- START: Version History Modal Styles --- */
/* --- START: Version History Modal Styles --- */
#version-sidebar .version-item {
    padding: 0.5rem 0.75rem;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: background-color 0.2s;
    border: 1px solid transparent;
}
#version-sidebar .version-item:hover {
    background-color: var(--bg-pane-light);
}
#version-sidebar .version-item.active {
    background-color: var(--bg-main);
    border-color: var(--border-color);
    font-weight: 600;
}
.version-timestamp {
    color: var(--text-primary);
    font-size: 0.875rem;
}
.version-fulldate {
    font-size: 0.75rem;
    color: var(--text-tertiary);
    font-weight: 400;
}
.version-message {
    font-size: 0.8rem;
    color: var(--text-primary);
    background-color: var(--bg-main);
    border: 1px solid var(--border-color);
    border-radius: 9999px;
    padding: 2px 8px;
    margin-top: 6px;
    display: inline-block;
}

/* Styles for the visual diff viewer */
#version-content-viewer ins {
    background-color: rgba(16, 185, 129, 0.2); /* Green for additions */
    text-decoration: none;
}
#version-content-viewer del {
    background-color: rgba(239, 68, 68, 0.2); /* Red for deletions */
}
/* --- END: Version History Modal Styles --- */
/* --- END: Version History Modal Styles --- */
/* --- END: Checklist Modal Handle Style --- */
/* --- END: Checklist Modal Handle Style --- */
/* --- END: Checklist Interaction Fix --- */
/* --- END: FINAL Public Page Code Block Style Fix --- */
/* --- END: Share Note Checklist Fix --- */


        .brand-button {
    background-image: linear-gradient(to right, var(--brand-grad-from), var(--brand-grad-to));
    color: white;
    border: none;
    padding: 0.5rem 1rem; /* 8px top/bottom, 16px left/right */
    border-radius: 0.375rem; /* 6px rounded corners */
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-weight: 500;
    transition: opacity 0.2s;
}

.brand-button:hover {
    opacity: 0.9;
}
.brand-button.confirm-state {
    background-image: none;
    background-color: #ef4444; /* red-500 */
}
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-main);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        #flashcard-container.flipped #flashcard {
    transform: rotateY(180deg);
}
.flashcard-face {
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
}
.transform-style-3d {
    transform-style: preserve-3d;
}
.perspective-1000 {
    perspective: 1000px;
}
.rotate-y-180 {
    transform: rotateY(180deg);
}
/* --- START: Modal Scroll Fix --- */
#global-ai-modal .modal-content-area {
    overflow-y: auto;
    max-height: 65vh; /* Sets a max height relative to the viewport */
}

/* --- END: Modal Scroll Fix --- */
        
        /* --- UI Polish & Animations --- */
        #note-editor-body {
    overflow-wrap: break-word;
    word-wrap: break-word; /* For older browser compatibility */
}
#command-prompt-container {
    transition: opacity 200ms ease-out, transform 200ms ease-out;
}

#command-prompt-container.hidden {
    opacity: 0;
    transform: translate(-50%, 20px) scale(0.95);
    pointer-events: none;
}

.command-suggestion-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem;
    border-radius: 0.25rem;
    cursor: pointer;
}
.command-suggestion-item:hover {
    background-color: var(--bg-pane-light);
}
.command-suggestion-item.active {
    background-color: var(--accent-primary);
    color: white;
}
.command-suggestion-item .cmd-name {
    font-weight: 600;
}
.command-suggestion-item .cmd-alias {
    font-size: 0.75rem;
    background-color: var(--bg-pane-light);
    color: var(--text-secondary);
    border-radius: 0.25rem;
    padding: 2px 6px;
}
.command-suggestion-item.active .cmd-alias {
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
}
.command-suggestion-item .cmd-desc {
    font-size: 0.875rem;
    color: var(--text-secondary);
}
.command-suggestion-item.active .cmd-desc {
    color: rgba(255, 255, 255, 0.8);
}
#note-editor-title {
    overflow-wrap: break-word;
    word-wrap: break-word;
}
        #notes-list-pane {
            transition: width 300ms ease-in-out, transform 300ms ease-in-out;
            overflow: hidden;
        }
        #toggle-settings-btn.collapsed .feather-chevron-down {
    transform: rotate(-90deg);
}
#settings-list-container.collapsed {
    max-height: 0;
    opacity: 0;
    margin-top: 0;
    overflow: hidden;
}
/* Find and replace the old #command-suggestions CSS with this */

/* Find and replace the old #command-suggestions rule with this one */

/* Replace your existing #command-suggestions rule with this one */
#command-suggestions {
    /* We remove max-height here because JavaScript will now control it */
    overflow-y: auto;
    display: grid;
    grid-template-columns: 100%;
}

/* Add this new rule to style the content-match suggestions */
.command-suggestion-item.content-match {
    display: block; /* Overrides the default flex layout to allow stacking */
    padding: 0.5rem;
}

/* This is the new reusable class for all custom scrollbars */
/* Find and replace the old .custom-scrollbar CSS with this */

.custom-scrollbar {
    /* This makes the scrollbar float over content in compatible browsers (Chrome/Edge) */
    overflow-y: overlay;
    /* Fallback for other browsers like Firefox */
    overflow-y: auto;
    
    scrollbar-width: thin;
    scrollbar-color: var(--bg-pane-dark) transparent;
}

.custom-scrollbar::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.custom-scrollbar::-webkit-scrollbar-track {
    background: transparent;
}

/* Make the scrollbar thumb transparent by default, effectively hiding it */
.custom-scrollbar::-webkit-scrollbar-thumb {
    background-color: transparent;
    border-radius: 10px;
    border: 2px solid transparent;
}

/* ONLY show the scrollbar thumb when you hover over the scrollable container */
.custom-scrollbar:hover::-webkit-scrollbar-thumb {
    background-color: var(--bg-pane-dark);
    border-color: var(--bg-pane-light);
}

/* Hides the default scrollbar and styles a new one for Chrome/Safari/Edge */
#command-suggestions::-webkit-scrollbar {
    width: 8px;
}

#command-suggestions::-webkit-scrollbar-track {
    background: transparent;
}

#command-suggestions::-webkit-scrollbar-thumb {
    background-color: var(--bg-pane-dark);
    border-radius: 10px;
    border: 2px solid var(--bg-pane-light);
}
        #flashcard-front p,
#flashcard-back p {
    color: var(--text-primary) !important;
    margin: 0;
}
#main-content-area {
    min-height: 0;
}
#backlinks-pane {
    background-color: var(--bg-pane-light);
}
/* --- START: Scrollbar Hiding Utility --- */
.no-scrollbar::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
}
.no-scrollbar {
    -ms-overflow-style: none;  /* For Internet Explorer and Edge */
    scrollbar-width: none;  /* For Firefox */
}
/* --- END: Scrollbar Hiding Utility --- */
.backlink-item {
    background-color: var(--bg-main);
    border: 1px solid var(--border-color);
    transition: box-shadow 0.2s;
}
.backlink-item:hover {
    box-shadow: 0 4px 12px var(--shadow-color);
}
#toggle-backlinks-btn.collapsed .feather-chevron-down {
    transform: rotate(-90deg);
}
#current-view-title {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
#backlinks-list.collapsed {
    max-height: 0;
    opacity: 0;
    margin-top: 0;
    overflow: hidden;
}
/* --- START: Selection-based Hide Checkboxes --- */
.task-list-item.checkbox-hidden input[type="checkbox"] {
    display: none;
}
/* --- END: Selection-based Hide Checkboxes --- */
/* Add these styles for the mobile toolbar fix */

        
        #notes-list-pane .sidebar-content-wrapper {
            transition: opacity 150ms ease-in-out;
        }
        #notes-list-pane.collapsed {
            width: 0px !important;
            border-right-width: 0px;
        }
        #notes-list-pane.collapsed .sidebar-content-wrapper {
            opacity: 0;
            pointer-events: none;
        }
        #tag-list-container.collapsed {
    max-height: 0;
    opacity: 0;
    margin-top: 0;
    overflow: hidden;
}
/* --- START: AI Response Copy Button Style --- */
.ai-response-copy-btn {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    padding: 0.35rem;
    border-radius: 0.375rem;
    background-color: var(--bg-pane-light);
    color: var(--text-tertiary);
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    cursor: pointer;
    z-index: 10;
}
.relative:hover .ai-response-copy-btn {
    opacity: 1;
}
.ai-response-copy-btn:hover {
    color: var(--text-primary);
}
/* --- END: AI Response Copy Button Style --- */
/* Add these styles for tables in the editor */
/* UPDATED: Styles for tables in editor AND public view */
/* UPDATED: Styles for tables in editor AND public view */
/* --- START: Public Note Table Scroll Fix --- */
/* --- START: Public Note Table Scroll Fix --- */
#note-editor-body table,
#public-note-content table {
    display: block;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch; /* For smoother scrolling on mobile */
}
#editor-pane {
    min-width: 0;
}
.card-content {
    word-break: break-all;
}
/* --- END: Public Note Table Scroll Fix --- */
/* --- END: Public Note Table Scroll Fix --- */
#note-editor-body table, #public-note-content table {
    width: 100%;
    border-collapse: collapse;
    margin: 1em 0;
}
#note-editor-body th, #note-editor-body td,
#public-note-content th, #public-note-content td {
    border: 1px solid var(--border-color);
    padding: 0.5rem; /* 8px */
    text-align: left;
}
#note-editor-body th, #public-note-content th {
    background-color: var(--bg-pane-dark);
    font-weight: 600;
    color: var(--text-primary); /* This is the fix for the text color */
}

#toggle-tags-btn.collapsed .feather-chevron-down {
    transform: rotate(-90deg);
}

        #sidebar-toggle-btn {
            transition: left 300ms ease-in-out, background-color 0.2s ease;
        }
        #flashcard-front, #flashcard-back {
    color: var(--text-primary);
    font-size: 1.25rem; /* Makes the text a bit bigger */
    line-height: 1.5;
}
        #sidebar-toggle-btn .feather-chevron-left {
            transition: transform 0.3s ease;
        }
        #sidebar-toggle-btn:hover {
            background-color: var(--accent-primary);
            color: white;
        }
        body.sidebar-collapsed #sidebar-toggle-btn .feather-chevron-left {
            transform: rotate(180deg);
        }

        .collection-item .chevron { transition: transform 0.15s ease; }
        .collection-item.open > .chevron { transform: rotate(90deg); }
        .collection-item-wrapper.drop-target-folder { background-color: rgba(230, 57, 127, 0.1); border: 1px dashed var(--accent-primary); }
        .file-attachment-widget {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    background-color: var(--bg-pane-dark);
    border: 1px solid var(--border-color);
    padding: 0.75rem;
    border-radius: 0.5rem;
    margin: 1em 0;
}
.file-attachment-widget .file-info {
    flex-grow: 1;
    min-width: 0;
}
.file-attachment-widget .file-name {
    font-weight: 600;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.file-attachment-widget .file-size {
    font-size: 0.75rem;
    color: var(--text-tertiary);
}
.file-attachment-widget .download-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background-color: var(--accent-primary);
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
    font-size: 0.875rem;
    font-weight: 500;
    text-decoration: none;
    transition: opacity 0.2s;
}
.file-attachment-widget .download-btn:hover {
    opacity: 0.8;
}
.file-attachment-widget {
    position: relative; /* Needed for the delete button */
}
.attachment-delete-btn {
    position: absolute;
    top: 0.25rem; /* 4px */
    right: 0.25rem; /* 4px */
    padding: 0.125rem; /* 2px */
    border-radius: 9999px;
    background-color: var(--bg-pane-light);
    color: var(--text-tertiary);
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    cursor: pointer;
}
.file-attachment-widget:hover .attachment-delete-btn {
    opacity: 1;
}
.attachment-delete-btn:hover {
    color: #ef4444; /* A standard red color */
}
        .kanban-card {
            background-color: var(--bg-main);
            height: 140px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .kanban-card:hover { transform: translateY(-4px); box-shadow: 0 10px 15px -3px var(--shadow-color), 0 4px 6px -4px var(--shadow-color); }
        .kanban-card.dragging { opacity: 0.5; transform: rotate(3deg); }

        .kanban-card.pinned, .list-note-item.pinned {
            border-color: var(--accent-primary);
            box-shadow: 0 0 8px -2px var(--accent-primary);
        }
        .kanban-card.pinned { transform: scale(1.02); }
        .kanban-card.pinned:hover { transform: scale(1.02) translateY(-4px); }
        
        .drop-target-column { background-color: var(--bg-pane-dark) !important; opacity: 0.5; }
        .drop-indicator { height: 2px; background-color: var(--accent-primary); margin: 0; padding: 0; pointer-events: none; }
        
        .context-menu, .dropdown-menu { transition: opacity 100ms ease, transform 100ms ease; }
        
        #note-editor-body:empty:before {
            content: attr(data-placeholder);
            color: var(--text-tertiary);
            pointer-events: none;
            display: block;
        }
        #note-editor-body a, #markdown-preview a, #summary-content a, .chat-bubble a {
            color: var(--accent-primary);
            text-decoration: underline;
            cursor: pointer;
        }
        .internal-link-broken {
            color: #ef4444; /* red-500 */
            text-decoration: underline;
            text-decoration-style: dotted;
            cursor: help;
        }
        #note-editor-body ul:not(.checklist-body), #markdown-preview ul, #summary-content ul, .chat-bubble ul, .ai-summary ul { list-style: disc; padding-left: 2rem; margin-top: 0.5rem; margin-bottom: 0.5rem; }
        #note-editor-body ol, #markdown-preview ol, #summary-content ol, .chat-bubble ol, .ai-summary ol { list-style: decimal; padding-left: 2rem; margin-top: 0.5rem; margin-bottom: 0.5rem; }
        #note-editor-body h1, #note-editor-body h2, #note-editor-body h3,
        #markdown-preview h1, #markdown-preview h2, #markdown-preview h3 #public-note-content h1, #public-note-content h2, #public-note-content h3 {

             font-weight: 700;
             line-height: 1.2;
             margin-top: 1em;
             margin-bottom: 0.5em;
             padding-bottom: 0.3em;
             border-bottom: 1px solid var(--border-color);
        }
        #note-editor-body h1, #markdown-preview h1 { font-size: 2.25rem; }
        #note-editor-body h2, #markdown-preview h2 { font-size: 1.875rem; }
        #note-editor-body h3, #markdown-preview h3 { font-size: 1.5rem; }
        #note-editor-body img, #markdown-preview img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 0.5em 0;
            cursor: default;
        }
        #note-editor-body blockquote, #markdown-preview blockquote, #summary-content blockquote, .chat-bubble blockquote, .ai-summary blockquote {
            border-left: 4px solid var(--border-color);
            padding-left: 1em;
            margin-left: 0;
            color: var(--text-secondary);
        }
        
        /* Inline code and Monospace */
        #note-editor-body code, #markdown-preview code {
            background-color: var(--bg-pane-dark);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9em;
        }

        #note-editor-body pre code, #markdown-preview pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            font-size: 1em;
        }
        
        #markdown-preview pre {
            background-color: var(--bg-pane-dark);
            padding: 1em;
            border-radius: 8px;
            overflow-x: auto;
        }
        #markdown-preview pre code.hljs {
            padding: 0;
            background-color: transparent;
        }
        
        /* Editor Code Block Styles */
        #note-editor-body .code-block-wrapper, #markdown-preview .code-block-wrapper, #public-note-content .code-block-wrapper {
            background-color: #211F30;
            border-radius: 8px;
            margin: 1.5em 0;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }
        html.light #note-editor-body .code-block-wrapper, html.dark #note-editor-body .code-block-wrapper {
             background-color: #1f2937; /* A consistent dark background */
        }
        .code-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(0,0,0,0.2);
            padding: 0.5rem 1rem;
            color: var(--text-secondary);
            font-size: 0.8rem;
            text-transform: uppercase;
        }
        .copy-code-btn, .delete-block-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 5px;
            transition: background-color 0.2s, color 0.2s;
        }
        .copy-code-btn:hover, .delete-block-btn:hover {
            background-color: var(--bg-pane-light);
        }
        .copy-code-btn:hover { color: var(--text-primary); }
        .delete-block-btn:hover { color: #ef4444; }

        #note-editor-body .code-block-wrapper pre, #markdown-preview .code-block-wrapper pre, #public-note-content .code-block-wrapper pre {
            margin: 0 !important;
            padding: 1em !important;
            background-color: transparent !important;
            white-space: pre-wrap;
            /** change to pre if you want horizontal scroll but need fix **/
            word-wrap: break-word;
        }
        #note-editor-body .code-block-wrapper pre code, #markdown-preview .code-block-wrapper pre code, #public-note-content .code-block-wrapper pre code {
            padding: 0 !important;
            background-color: transparent !important;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace !important;
            font-size: 1em !important;
        }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        #search-results-view mark {
            background-color: var(--accent-primary-dark);
            border-radius: 3px;
            padding: 1px 2px;
            color: var(--bg-main);
        }
        
        .column-header:hover .delete-column-btn { opacity: 1; }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .summarize-btn {
    transition: opacity 0.2s ease-in-out;
}
        .list-note-item:hover .summarize-btn { opacity: 1; }

        .chat-bubble { max-width: 80%; }
        .chat-bubble.user { background-image: linear-gradient(to right, var(--brand-grad-from), var(--brand-grad-to)); color: white; }
        .chat-bubble.model { background-color: var(--bg-pane-dark); }
        .chat-bubble.thinking {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: .5; }
        }

        .truncate-multiline {
            display: -webkit-box;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .kanban-card .card-content { -webkit-line-clamp: 3; }
        .list-note-item .card-content { -webkit-line-clamp: 2; }
        
        .view-btn {
             color: var(--text-secondary);
             transition: all 0.2s ease-in-out;
        }
        .view-btn.active {
             background-color: var(--bg-main);
             color: var(--text-primary);
             box-shadow: 0 1px 3px 0 var(--shadow-color);
        }
        .reputify-theme .view-btn.active {
             box-shadow: 0 1px 5px 0 rgba(0,0,0,0.2);
        }

        .settings-footer-item {
            @apply w-full text-left px-3 py-2 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-3 text-text-secondary hover:text-text-primary;
        }
        
        #dictate-btn.recording {
            color: #ef4444; /* red-500 */
            animation: pulse-red 1.5s infinite;
        }
        @keyframes pulse-red {
          0%, 100% { opacity: 1; }
          50% { opacity: .6; }
        }
        
        #tag-list-container .tag-filter-item.active {
            background-color: var(--accent-primary);
            color: white;
            font-weight: 600;
        }
        /* --- START: Mobile Inline Toolbar Scroll --- */
@media (max-width: 767px) {
    #inline-toolbar {
        max-width: 200px; /* Limit the width on mobile */
    }
    #inline-toolbar-buttons {
        scroll-behavior: smooth;
    }
    .toolbar-scroll-btn {
        display: flex; /* Show the scroll buttons on mobile */
        align-items: center;
        justify-content: center;
        cursor: pointer;
    }
}
/* --- END: Mobile Inline Toolbar Scroll --- */

        /* Mobile-specific overrides */
        @media (max-width: 767px) {
            #notes-list-pane {
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                z-index: 40; /* Higher z-index for mobile overlay */
                transform: translateX(-100%);
                width: 280px !important; /* Fixed width for mobile overlay */
                border-right-width: 1px;
            }
            #search-bar-container {
        padding-left: 0.75rem;  /* 12px */
        padding-right: 0.75rem; /* 12px */
    }

    /* Target the inner div that holds the icons and input */
    #search-bar-container > div {
        padding-left: 1rem;     /* 16px padding for the search icon */
        padding-right: 0.5rem;  /* 8px padding for the 'X' icon */
    }

    /* Remove the negative margin on the close button that causes it to protrude */
    #search-bar-container #search-close-btn {
        margin-right: 0;
    }
            #highlight-controls {
        padding-right: 0.75rem; /* Pushes the 'X' icon inward */
    }

    /* START: In-Note Search Bar Mobile Fix */
    /* --- START: In-Note Search Bar Mobile Polish --- */
/* Controls the container to ensure centering and spacing from screen edges */
#highlight-controls {
    padding: 0.5rem 0.75rem; /* 8px top/bottom, 12px left/right for symmetry */
}

/* Main search bar styling */
#in-note-search-bar {
    height: 44px;           /* Reduced height for better proportions */
    gap: 0.25rem;           /* Reduces space between all items */
    padding-left: 0.75rem;   /* 12px padding on the left */
    padding-right: 0.25rem;  /* 4px padding on the right to hug the 'X' button */
}

/* Target the text counter ("1 of 2") to make it narrower */
#in-note-search-bar #in-note-search-count {
    width: auto;        /* Let it size to its content */
    padding: 0 0.25rem; /* Add a little horizontal space */
}

/* Rely on flexbox 'items-center' for vertical alignment of input text */
#in-note-search-bar #in-note-search-input {
    padding-top: 0;
    padding-bottom: 0;
}
/* --- END: In-Note Search Bar Mobile Polish --- */
            #main-header {
           @apply z-10; /* Ensures the header stays above the content area */
        }

        #notes-list-pane .sidebar-content-wrapper {
            transition: opacity 150ms ease-in-out;
        }
            #notes-list-pane.open {
                transform: translateX(0);
                box-shadow: 0 0 20px rgba(0,0,0,0.2);
            }
            #pane-resizer, #sidebar-toggle-btn { display: none; }
            #mobile-menu-button { display: block; }
            #desktop-new-note-btn { display: none; }
            #mobile-new-note-fab { display: flex; }
            #desktop-header-controls { display: none; }
            #mobile-header-controls { display: flex; }
            
        }

        #app-container {
    display: none; /* Hide the main app by default */
}
    </style>
    
    <script>
      try {
        const defaultTheme = 'reputify';
        const theme = localStorage.getItem('codex-notes-theme') || defaultTheme;
        if (theme === 'dark') {
          document.documentElement.classList.add('dark');
        } else if (theme === 'reputify') {
           document.documentElement.classList.add('reputify-theme');
        }
      } catch (e) {}
    </script>
    <script type="module">
  // Import the functions you need from the SDKs
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import {
    getAuth,
    onAuthStateChanged,
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
  import { getFirestore, enableIndexedDbPersistence } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
  import { getFunctions } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-functions.js";

  // Your web app's Firebase configuration
  const firebaseConfig = {
  apiKey: "AIzaSyB5GkZzQaHF9WLBpHIzgTbUDshtb0-TsFM",
  authDomain: "reputifly-notes.firebaseapp.com",
  projectId: "reputifly-notes",
  storageBucket: "reputifly-notes.firebasestorage.app",
  messagingSenderId: "1085743658227",
  appId: "1:1085743658227:web:d90ba48b3b2df9fe1d3386"
};

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  
  // CORRECTED PART: Make auth and db globally available
  // CORRECTED PART: Make auth and db globally available
window.auth = getAuth(app);

// --- ADD THIS BLOCK TO ENABLE OFFLINE ---
const db = getFirestore(app);
enableIndexedDbPersistence(db)
  .catch((err) => {
    if (err.code == 'failed-precondition') {
      // This can happen if you have multiple tabs open.
      console.warn("Firestore persistence failed: multiple tabs open.");
    } else if (err.code == 'unimplemented') {
      // The browser is likely too old to support this feature.
      console.error("Firestore persistence is not supported in this browser.");
    }
  });
// --- END OF NEW BLOCK ---

window.db = db; // This now uses the offline-enabled db instance
window.functions = getFunctions(app,);
    

  // This is our new entry point!
  // This is our new entry point!
  // This is our new entry point!
  onAuthStateChanged(window.auth, (user) => {
    // --- ADD THESE TWO LINES ---
    const params = new URLSearchParams(window.location.search);
    if (params.has('view')) return; // If it's a share link, STOP here.

    const authContainer = document.getElementById('auth-container');
    const appContainer = document.getElementById('app-container');
    
    // START: MODIFIED SECTION
    const chatbotFab = document.getElementById('chatbot-fab');
    const mobileFab = document.getElementById('mobile-new-note-fab');
    // END: MODIFIED SECTION

    if (user) {
          // User is signed in.
          console.log('User is logged in:', user.uid);
          if (authContainer) authContainer.style.display = 'none';
          if (appContainer) appContainer.style.display = 'flex';
          
          // START: MODIFIED SECTION
          // Restore button visibility
          if (chatbotFab) chatbotFab.style.display = 'flex';
          if (mobileFab) mobileFab.style.display = 'flex'; // CSS will handle hiding on desktop
          // END: MODIFIED SECTION

          // --- START: PROFILE LOGIC ---
          const userInitial = document.getElementById('user-initial');
          const userEmailDisplay = document.getElementById('user-email-display');
          const profileButton = document.getElementById('profile-button');
          const profileDropdown = document.getElementById('profile-dropdown');
          const signOutLink = document.getElementById('sign-out-link');

          if (user.email) {
              userInitial.textContent = user.email.charAt(0).toUpperCase();
              userEmailDisplay.textContent = user.email;
              userEmailDisplay.title = user.email;
          }

          if(profileButton) { // Check if button exists before adding listener
            profileButton.addEventListener('click', (e) => {
                e.stopPropagation();
                if(profileDropdown) profileDropdown.classList.toggle('hidden');
                // Re-render icons if the dropdown is shown
                if (profileDropdown && !profileDropdown.classList.contains('hidden')) {
                  feather.replace();
                }
            });
          }

          if(signOutLink) { // Check if link exists
            signOutLink.addEventListener('click', async (e) => {
                e.preventDefault();
                try {
                    // We need to import signOut here to use it
                    const { signOut } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js");
                    await signOut(window.auth);
                } catch (error) {
                    console.error('Sign out error:', error);
                }
            });
          }
          // --- END: PROFILE LOGIC ---
          
          // Make sure init() is defined before calling it
          if (window.appInit) {
              window.appInit();
          }
      } else {
      // User is signed out.
      console.log('User is logged out.');
      if (authContainer) authContainer.style.display = 'flex';
      if (appContainer) appContainer.style.display = 'none';

      // START: MODIFIED SECTION
      // Hide buttons on login/signup page
      if (chatbotFab) chatbotFab.style.display = 'none';
      if (mobileFab) mobileFab.style.display = 'none';
      // END: MODIFIED SECTION
    }
  });
</script>
</head>
<body class="overflow-hidden">
    <div id="auth-container" class="flex items-center justify-center h-screen bg-bg-main">
    <div class="w-full max-w-sm p-8 space-y-6 bg-bg-pane-light rounded-lg shadow-xl">
        <div>
            <h2 id="auth-title" class="text-2xl font-bold text-center text-text-primary">Login to Your Notes</h2>
        </div>
        <form id="login-form" class="space-y-4">
            <div>
                <label for="login-email" class="text-sm font-medium text-text-secondary">Email address</label>
                <input id="login-email" name="email" type="email" required class="w-full px-3 py-2 mt-1 bg-bg-pane-dark border border-border-color rounded-md focus:outline-none focus:ring-2 focus:ring-accent-primary">
            </div>
            <div>
                <label for="login-password" class="text-sm font-medium text-text-secondary">Password</label>
                <input id="login-password" name="password" type="password" required class="w-full px-3 py-2 mt-1 bg-bg-pane-dark border border-border-color rounded-md focus:outline-none focus:ring-2 focus:ring-accent-primary">
            </div>
            <p id="auth-error" class="text-sm text-red-500 h-5"></p>
            <button type="submit" class="w-full brand-button text-white font-semibold py-2 rounded-lg hover:opacity-90 transition-opacity">Login</button>
        </form>
        <p class="text-sm text-center text-text-secondary">
            <span id="login-text-link">Don't have an account? <a href="#" id="show-signup" class="font-medium text-accent-primary hover:underline">Sign up</a></span>
            <span id="signup-text-link" class="hidden">Already have an account? <a href="#" id="show-login" class="font-medium text-accent-primary hover:underline">Login</a></span>
        </p>
    </div>
</div>

    <div id="app-container" class="flex h-screen">

        <aside id="notes-list-pane" class="w-[280px] bg-bg-pane-light border-r border-border-color flex flex-col flex-shrink-0">
            <div class="sidebar-content-wrapper flex flex-col h-full min-w-[280px]">
                <header class="flex justify-between items-center p-4 border-b border-border-color flex-shrink-0 gap-2 h-[65px]">
                    <div class="flex items-center gap-3">
                        <div id="profile-section" class="relative">
                            <button id="profile-button" title="Account Settings" class="w-8 h-8 rounded-full bg-gradient-to-r from-[var(--brand-grad-from)] to-[var(--brand-grad-to)] flex items-center justify-center font-bold text-white hover:opacity-90 transition-opacity">
                                <div id="user-initial">R</div>
                            </button>
                            <div id="profile-dropdown" class="dropdown-menu hidden absolute top-full left-0 mt-2 w-52 bg-bg-pane-light shadow-2xl rounded-md p-1 border border-border-color origin-top-left z-20">
                                <div class="px-2 py-2 border-b border-border-color">
                                    <p class="text-sm font-semibold text-text-primary">Signed in as</p>
                                    <p id="user-email-display" class="text-sm text-text-secondary truncate" title="user-email"></p>
                                </div>
                                <div class="p-1">
                                    <a href="#" id="sign-out-link" class="w-full text-left px-2 py-1.5 text-sm hover:bg-bg-pane-dark text-red-500 rounded flex items-center gap-2">
                                        <i data-feather="log-out" class="w-4 h-4"></i>
                                        <span>Sign Out</span>
                                    </a>
                                </div>
                            </div>
                        </div>
                        <h1 class="text-lg font-bold text-text-primary">Notes</h1>
                    </div>
                    <div class="flex items-center gap-2 flex-shrink-0">
                        <div id="view-switcher-container" class="view-switcher bg-bg-pane-dark p-1 rounded-lg flex">
                          <button class="view-btn px-2.5 py-1 rounded" title="Board View" data-view="board"><i data-feather="trello" class="w-4 h-4"></i></button>
                          <button class="view-btn px-2.5 py-1 rounded" title="List View" data-view="list"><i data-feather="list" class="w-4 h-4"></i></button>
                        </div>
                        <button id="new-collection-btn" class="text-text-secondary hover:text-accent-primary transition-colors flex-shrink-0"><i data-feather="plus"></i></button>
                    </div>
                </header>
                <div id="collections-list-container" class="flex-grow p-2 overflow-y-auto custom-scrollbar"></div>


                
                <div id="tag-panel" class="p-2 border-t border-border-color flex-shrink-0">
    <div class="flex justify-between items-center px-2">
        <h3 class="font-bold text-sm uppercase tracking-wider py-1 text-text-secondary">Tags</h3>
        <button id="toggle-tags-btn" class="p-1 rounded-full hover:bg-bg-pane-dark">
            <i data-feather="chevron-down" class="w-4 h-4 transition-transform duration-200"></i>
        </button>
    </div>
    <div id="tag-list-container" class="mt-1 space-y-1 max-h-32 overflow-y-auto transition-all duration-300 custom-scrollbar"></div>
</div>

                <footer class="p-2 border-t border-border-color flex-shrink-0">
                    <div id="settings-panel">
                        <div class="flex justify-between items-center px-2">
                            <h3 class="font-bold text-sm uppercase tracking-wider py-1 text-text-secondary">Settings</h3>
                            <button id="toggle-settings-btn" class="p-1 rounded-full hover:bg-bg-pane-dark">
                                <i data-feather="chevron-down" class="w-4 h-4 transition-transform duration-200"></i>
                            </button>
                        </div>
                        <div id="settings-list-container" class="mt-1 space-y-1 transition-all duration-300">
                             <button id="theme-toggle" class="settings-footer-item">
                               <i data-feather="star" id="theme-reputify-icon" class="hidden w-5 h-5"></i>
                               <i data-feather="sun" id="theme-sun-icon" class="hidden w-5 h-5"></i>
                               <i data-feather="moon" id="theme-moon-icon" class="hidden w-5 h-5"></i>
                               <span id="theme-text">Reputify Theme</span>
                            </button>
                            <button data-action="import" class="settings-footer-item">
                                <i data-feather="upload" class="w-5 h-5"></i>
                                <span>Import Data</span>
                            </button>
                            <button data-action="export" class="settings-footer-item">
                                <i data-feather="download" class="w-5 h-5"></i>
                                <span>Export Data</span>
                            </button>
                            <button id="chatbot-toggle-btn" class="settings-footer-item">
        <i data-feather="message-square" class="w-5 h-5"></i>
        <span>Show Chatbot Button</span>
    </button>

                            <button id="bookmarklet-info-btn" class="settings-footer-item">
                                <i data-feather="book" class="w-5 h-5"></i>
                                <span>Web Clipper</span>
                            </button>
                        </div>
                    </div>
                    <input type="file" id="import-file-input" class="hidden" accept=".json">
                </footer>
            </div>
        </aside>
        
        <div id="pane-resizer" class="w-1.5 h-full cursor-col-resize z-10 bg-transparent hover:bg-accent-primary hidden md:block"></div>
        
        <button id="sidebar-toggle-btn" title="Toggle Sidebar" class="absolute top-1/2 -translate-y-1/2 w-6 h-12 bg-bg-pane-dark text-text-secondary flex items-center justify-center rounded-r-lg z-20 hidden md:flex">
            <i data-feather="chevron-left" class="w-5 h-5"></i>
        </button>

        <main id="editor-pane" class="flex-grow bg-bg-main flex flex-col">
           <header id="main-header" class="flex justify-between items-center p-4 border-b border-border-color flex-shrink-0 relative h-[65px]">
   <div id="header-main-content" class="flex justify-between items-center w-full transition-opacity duration-200">
       <div class="flex items-center gap-2 flex-shrink min-w-0">
         <button id="mobile-menu-button" class="md:hidden p-1 -ml-1"><i data-feather="menu" class="w-6 h-6"></i></button>
         <h2 id="current-view-title" class="text-lg font-semibold"></h2>
       </div>
       
       <div id="desktop-header-controls" class="hidden md:flex items-center gap-4">
           <div class="flex-grow"></div>
           <div class="flex items-center gap-2">
               <button id="header-search-icon" class="p-2 hover:bg-bg-pane-dark rounded-lg text-text-secondary" title="Search (Cmd+F)"><i data-feather="search" class="w-4 h-4"></i></button>
               <button id="global-ai-btn" class="p-2 hover:bg-bg-pane-dark rounded-lg text-text-secondary" title="Ask Your Notes (AI Search)"><i data-feather="message-circle" class="w-4 h-4"></i></button>
               <div id="list-view-controls" class="hidden items-center gap-2">
                 <label for="sort-order" class="text-sm text-text-secondary">Sort by:</label>
                 <select id="sort-order" class="bg-bg-pane-dark text-text-primary text-sm rounded-md p-1 border-0 focus:ring-2 focus:ring-accent-primary">
                     <option value="modifiedAt-desc">Last Modified</option>
                     <option value="createdAt-desc">Date Created</option>
                     <option value="name-asc">Title (A-Z)</option>
                 </select>
               </div>
               <div class="editor-toolbar flex items-center bg-bg-pane-dark p-1 rounded-lg">
                   <button id="header-summarize-btn" style="display: none;" class="p-2 hover:bg-bg-main rounded-l-md" title="AI Summary"><i data-feather="zap" class="w-4 h-4"></i></button>
                   <button id="header-quiz-btn" style="display: none;" class="p-2 hover:bg-bg-main" title="MCQ Quiz"><i data-feather="help-circle" class="w-4 h-4"></i></button>
                   <button id="header-share-btn" style="display: none;" class="p-2 hover:bg-bg-main" title="Share Note (Read-only)"><i data-feather="share-2" class="w-4 h-4"></i></button>
                   <button id="header-flashcard-btn" style="display: none;" class="p-2 hover:bg-bg-main" title="Flashcard Mode">
                        <i data-feather="copy" class="w-4 h-4"></i>
                   </button>

                   <div id="expandable-toolbar-buttons" class="hidden items-center">
                        <button id="dictate-btn" class="p-2 hover:bg-bg-main" title="Dictate Text"><i data-feather="mic" class="w-4 h-4"></i></button>
                        <button id="graph-btn" class="p-2 hover:bg-bg-main" title="Show Note Graph"><i data-feather="git-merge" class="w-4 h-4"></i></button>
                        <button id="header-checkpoint-btn" class="p-2 hover:bg-bg-main" title="Save Checkpoint"><i data-feather="flag" class="w-4 h-4"></i></button>

                        <button id="history-btn" class="p-2 hover:bg-bg-main" title="Version History"><i data-feather="clock" class="w-4 h-4"></i></button>
                        <button id="editor-mode-toggle" class="p-2 hover:bg-bg-main disabled:opacity-50 disabled:cursor-not-allowed" title="Toggle Markdown Preview"><i data-feather="eye" class="w-4 h-4"></i></button>
                        <button data-command="ocr" class="p-2 hover:bg-bg-main" title="Scan Image for Text"><i data-feather="camera" class="w-4 h-4"></i></button>
                        <input type="file" id="ocr-file-input" class="hidden" accept="image/*">
                   </div>

                   <button id="toggle-toolbar-btn" class="p-2 hover:bg-bg-main rounded-r-md">
                       <i id="toolbar-toggle-icon" data-feather="chevron-right" class="w-4 h-4"></i>
                   </button>
               </div>
               <button id="desktop-new-note-btn" class="brand-button text-white px-4 py-2 rounded-lg font-semibold text-sm flex items-center gap-2 hover:opacity-90 transition-opacity" title="New Note (Cmd+N)">New Note <i data-feather="plus" class="w-4 h-4"></i></button>
           </div>
       </div>

       <div id="mobile-header-controls" class="flex md:hidden items-center gap-2 relative">
         <button id="mobile-search-icon" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="search" class="w-5 h-5"></i></button>
         <button id="mobile-global-ai-btn" class="p-2 rounded-full hover:bg-bg-pane-dark" title="Ask Your Notes"><i data-feather="message-circle" class="w-5 h-5"></i></button>
         <button id="mobile-more-button" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="more-vertical" class="w-5 h-5"></i></button>
         <div id="mobile-controls-dropdown" class="dropdown-menu hidden absolute top-full right-0 mt-2 w-48 bg-bg-pane-light shadow-2xl rounded-md p-2 border-border-color origin-top-right scale-95 opacity-0 z-10">
         </div>
       </div>
   </div>

    <div id="search-bar-container" class="hidden md:absolute md:top-1/2 md:left-1/2 md:-translate-x-1/2 md:-translate-y-1/2 z-10 w-full md:w-[95%] md:max-w-[500px]">
         <div class="bg-bg-pane-dark rounded-full shadow-lg flex items-center px-4 w-full">
             <i data-feather="search" class="text-text-tertiary"></i>
             <input id="search-input" type="text" placeholder="Search notes and folders..." class="w-full bg-transparent p-3 focus:outline-none text-text-primary">
             <button id="search-close-btn" class="p-2 -mr-2 rounded-full text-text-tertiary hover:bg-bg-main">
                <i data-feather="x" class="w-5 h-5"></i>
             </button>
         </div>
     </div>
</header>
<input type="file" id="file-upload-input" class="hidden" accept=".csv, application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, image/*, .pdf, .txt, .md" />

           
           <div id="main-content-area" class="flex-grow overflow-y-auto relative flex flex-col custom-scrollbar">

            
                <div id="board-view" class="notes-view active flex-grow p-4 md:p-5 overflow-x-auto no-scrollbar h-full">
                    <div id="kanban-board" class="flex gap-4 min-h-full"></div>
                </div>
                <div id="list-view" class="notes-view hidden flex-grow p-4 md:p-5">
                    <div id="notes-list-content" class="space-y-3"></div>
                </div>
                <div id="note-editor-view" class="notes-view hidden flex-grow flex flex-col pb-24 md:pb-1">
                    <div id="highlight-controls" class="hidden sticky top-0 z-20 p-2 bg-bg-main">
<div id="in-note-search-bar" class="w-full mx-auto bg-bg-pane-dark shadow-lg rounded-full p-1 flex items-center gap-1 text-base border border-border-color px-4">
        <input id="in-note-search-input" type="text" placeholder="Find in note..." class="flex-grow bg-transparent rounded-full px-3 py-1 focus:outline-none">
        <span id="in-note-search-count" class="text-text-tertiary w-20 text-center flex-shrink-0">No results</span>
        <div class="h-5 w-px bg-border-color"></div>
        <button id="in-note-search-prev" title="Previous" class="p-1 hover:bg-bg-main rounded-full text-text-secondary disabled:opacity-50" disabled><i data-feather="chevron-up" class="w-5 h-5"></i></button>
        <button id="in-note-search-next" title="Next" class="p-1 hover:bg-bg-main rounded-full text-text-secondary disabled:opacity-50" disabled><i data-feather="chevron-down" class="w-5 h-5"></i></button>
        <div class="h-5 w-px bg-border-color"></div>
        <button id="clear-search-btn" title="Close Search & Clear Highlights" class="p-1 hover:bg-bg-main rounded-full text-text-tertiary mr-1">
            <i data-feather="x" class="w-5 h-5"></i>
        </button>
    </div>
</div>
                    <div class="p-4 md:p-8 md:pb-4 flex-shrink-0">
                        
<textarea id="note-editor-title" placeholder="Untitled Note" class="text-3xl md:text-4xl font-bold bg-transparent focus:outline-none mb-4 w-full overflow-hidden resize-none" rows="1"></textarea>
                    </div>
                    <div id="note-editor-body" contenteditable="true" class="flex-grow text-lg leading-relaxed focus:outline-none px-4 md:px-8 pt-2 md:pt-4 pb-4 md:pb-8" data-placeholder="Start writing or drop an image..."></div>
                    <div id="markdown-preview" class="hidden flex-grow text-lg leading-relaxed focus:outline-none p-4 md:p-8 prose"></div>
                    <div id="backlinks-pane" class="hidden p-4 md:px-8 border-t border-border-color">
    <div class="flex justify-between items-center mb-3">
        <div class="flex items-center gap-2">
            <h4 class="font-semibold text-sm uppercase tracking-wider text-text-secondary">Linked Here</h4>
            <button id="toggle-backlinks-btn" class="p-1 rounded-full hover:bg-bg-pane-dark">
                <i data-feather="chevron-down" class="w-4 h-4 transition-transform duration-200"></i>
            </button>
        </div>
        <button id="summarize-backlinks-btn" class="flex items-center gap-2 text-sm text-accent-primary hover:opacity-80 transition-opacity" title="Summarize all linked notes with AI">
            <i data-feather="zap" class="w-4 h-4"></i>
            <span>AI Summary</span>
        </button>
    </div>
    <div id="backlinks-list" class="space-y-3 transition-all duration-300"></div>
</div>
                    <div id="editor-footer" class="p-4 text-xs text-text-tertiary text-left border-t border-border-color flex-shrink-0">
                        <div id="backlinks-pane" class="hidden p-4 md:px-8 border-t border-border-color">
    <h4 class="font-semibold text-sm uppercase tracking-wider text-text-secondary mb-3">Linked here</h4>
    <div id="backlinks-list" class="space-y-2"></div>
</div>
                       <span id="word-count">0</span> Words | <span id="char-count">0</span> Characters
                    </div>
                </div>
                <div id="search-results-view" class="notes-view hidden p-4 md:p-8">
                    <h2 class="text-2xl font-bold mb-6">Search Results</h2>
                    <div id="search-results-list"></div>
                </div>
           </div>
        </main>
        <div id="table-creator-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-sm z-50 transition-all duration-300 transform scale-95 opacity-0">
    <h3 class="text-lg font-semibold mb-4">Create Table</h3>
    <div class="grid grid-cols-2 gap-4">
        <div>
            <label for="table-rows" class="text-sm font-medium text-text-secondary">Rows</label>
            <input id="table-rows" type="number" value="3" min="1" class="w-full px-3 py-2 mt-1 bg-bg-pane-dark border border-border-color rounded-md focus:outline-none focus:ring-2 focus:ring-accent-primary">
        </div>
        <div>
            <label for="table-cols" class="text-sm font-medium text-text-secondary">Columns</label>
            <input id="table-cols" type="number" value="2" min="1" class="w-full px-3 py-2 mt-1 bg-bg-pane-dark border border-border-color rounded-md focus:outline-none focus:ring-2 focus:ring-accent-primary">
        </div>
    </div>
    <div class="flex justify-end gap-3 mt-6">
        <button id="table-cancel-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Cancel</button>
        <button id="table-create-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Create</button>
    </div>
</div>
    </div><div id="public-note-view" class="hidden min-h-screen bg-bg-main text-text-primary">
    <!-- START: NEW HEADER FOR PUBLIC PAGE -->
    <header class="sticky top-0 z-10 bg-bg-main py-4 px-4 md:px-8 border-b border-border-color shadow-sm">
        
        <div class="max-w-4xl mx-auto flex justify-between items-center">
            <a href="https://reputifly.org/note" title="Back to Reputifly">
                <img src="https://reputifly.com/wp-content/uploads/2025/05/cropped-reputifly-new-e1746390492876.png" alt="Reputifly Logo" class="h-8 w-auto">
            </a>
            <a href="https://reputifly.org/note" class="brand-button text-white font-semibold px-4 py-2 rounded-lg text-sm hover:opacity-90 transition-opacity">
                Sign Up Free
            </a>
        </div>
    </header>
    <!-- END: NEW HEADER FOR PUBLIC PAGE -->

    <main class="max-w-4xl mx-auto p-4 md:p-8">
        <!-- Title will be populated by JS -->
        <h1 id="public-note-title" class="text-3xl md:text-4xl font-bold mb-6 border-b border-border-color pb-4"></h1>
        
        <button id="copy-note-btn" class="flex items-center gap-2 mb-4 text-sm text-text-secondary hover:text-text-primary transition">
            <i data-feather="copy" class="w-4 h-4"></i>
            <span>Copy Content</span>
        </button>
        
        <!-- Note content will be populated by JS. `max-w-none` ensures content fills the container. -->
        <div id="public-note-content" class="prose max-w-none"></div>

        <!-- Call to action section -->
        <div class="mt-16 p-6 bg-bg-pane-dark rounded-lg text-center">
            <h3 class="font-bold text-xl text-text-primary">Enjoying this note?</h3>
            <p class="text-text-secondary mt-2 mb-4">Create your own smart notes with AI summaries, quizzes, and more.</p>
            <a href="https://reputifly.org/signup" class="brand-button inline-block text-white font-semibold px-5 py-2.5 rounded-lg hover:opacity-90 transition-opacity">
                Create a Free Account
            </a>
        </div>

        <!-- Footer -->
        <footer class="text-center mt-12 text-sm text-text-tertiary">
            <p>Published with Reputifly AI Note Taker</p>
        </footer>
    </main>
</div>
    
    <button id="chatbot-fab" title="Ask Chatbot" class="bg-gradient-to-r from-[var(--brand-grad-from)] to-[var(--brand-grad-to)] fixed bottom-6 right-6 text-white w-14 h-14 rounded-full shadow-lg flex items-center justify-center z-20 hover:opacity-90 transition-opacity">
        <i data-feather="message-square" class="w-7 h-7"></i>
    </button>
    
    
    <div id="modal-backdrop" class="fixed inset-0 bg-black/50 z-40 transition-opacity duration-300 opacity-0 pointer-events-none"></div>
    <div id="mobile-sidebar-overlay" class="fixed inset-0 bg-black/30 z-30 hidden md:hidden transition-opacity duration-300 opacity-0 pointer-events-none"></div>
    
    <div id="api-key-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-md z-50 transition-all duration-300 transform scale-95 opacity-100">
        <h3 class="text-lg font-semibold mb-2">Gemini API Key Required</h3>
        <p class="text-sm text-text-secondary mb-4">Please enter your Gemini API key to enable AI features. Your key is stored only in your browser's local storage.</p>
        <label for="api-key-input" class="text-xs font-semibold text-text-secondary">API Key</label>
        <input id="api-key-input" type="password" class="w-full text-sm bg-bg-pane-dark border border-border-color rounded-md py-1 px-2 focus:ring-2 focus:ring-accent-primary focus:outline-none" placeholder="Enter your key here...">
        <p id="api-key-error" class="text-red-500 text-sm mt-1 h-5"></p>
        <div class="flex justify-end gap-3 mt-4">
            <button id="api-key-confirm-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Save and Continue</button>
        </div>
    </div>
    
    <div id="prompt-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-md z-50 transition-all duration-300 transform scale-95 opacity-0">
        <h3 id="prompt-title" class="text-lg font-semibold mb-4">Input Required</h3>
        <p id="prompt-message" class="text-sm text-text-secondary mb-3"></p>
        <input id="prompt-input" type="text" class="w-full bg-bg-pane-dark border border-border-color rounded-md p-2 focus:ring-2 focus:ring-accent-primary focus:outline-none">
        <p id="prompt-error" class="text-red-500 text-sm mt-1 h-5"></p>
        <div class="flex justify-end gap-3 mt-4">
            <button id="prompt-cancel-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Cancel</button>
            <button id="prompt-confirm-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Confirm</button>
        </div>
    </div>
    <div id="confirm-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-md z-60 transition-all duration-300 transform scale-95 opacity-0">
        <h3 id="confirm-title" class="text-lg font-semibold mb-4">Are you sure?</h3>
        <p id="confirm-message" class="text-sm text-text-secondary mb-6"></p>
        <div class="flex justify-end gap-3 mt-4">
            <button id="confirm-cancel-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Cancel</button>
            <button id="confirm-confirm-btn" class="px-4 py-2 rounded-md bg-red-600 text-white hover:opacity-90">Delete</button>
        </div>
    </div>
    <div id="bookmarklet-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-lg z-50 transition-all duration-300 transform scale-95 opacity-0">
        <h3 class="text-lg font-semibold mb-2 flex items-center gap-2"><i data-feather="book" class="w-5 h-5 text-accent-primary"></i>Web Clipper Bookmarklet</h3>
        <p class="text-sm text-text-secondary mb-4">Drag the link below to your browser's bookmarks bar to create a web clipper. When you're on any website, click the bookmarklet to clip selected text into a new note.</p>
        <a id="bookmarklet-link" href="#" class="inline-block brand-button text-white font-semibold px-4 py-2 rounded-lg text-sm">Clip to Codex Notes</a>
        <div class="mt-4 flex justify-end">
            <button id="bookmarklet-close-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Close</button>
        </div>
    </div>
    <div id="graph-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-4 rounded-lg shadow-2xl w-[90vw] max-w-3xl h-[60vh] z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
        <header class="flex justify-between items-center mb-2 flex-shrink-0">
            <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="git-merge" class="w-5 h-5 text-accent-primary"></i>Note Graph</h3>
            <button id="graph-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
        </header>
        <div id="graph-container" class="border border-border-color rounded-md flex-grow bg-bg-main"></div>
    </div>
    <div id="ai-prompt-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-lg z-50 transition-all duration-300 transform scale-95 opacity-0">
        <h3 class="text-lg font-semibold mb-4 flex items-center gap-2"><i data-feather="sparkles" class="w-5 h-5 text-accent-primary"></i>Ask AI</h3>
        <p class="text-sm text-text-secondary mb-3">Enter your prompt below. The AI-generated content will be inserted into your note.</p>
        <textarea id="ai-prompt-input" rows="4" class="w-full bg-bg-pane-dark border border-border-color rounded-md p-2 focus:ring-2 focus:ring-accent-primary focus:outline-none" placeholder="e.g., 'Write a short poem about the moon'"></textarea>
        <p id="ai-prompt-error" class="text-red-500 text-sm mt-1 h-5"></p>
        <div class="flex justify-end gap-3 mt-4">
            <button id="ai-cancel-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Cancel</button>
            <button id="ai-generate-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90 flex items-center gap-2">
                <i data-feather="play" class="w-4 h-4"></i>
                <span id="ai-generate-btn-text">Generate</span>
            </button>
        </div>
    </div>
    <div id="summary-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-xl z-50 transition-all duration-300 transform scale-95 opacity-0">
    <h3 class="text-lg font-semibold mb-2 flex items-center gap-2"><i data-feather="align-left" class="w-5 h-5 text-accent-primary"></i>AI Summary</h3>
    
    <div class="relative">
        <div id="summary-content" class="text-sm text-text-secondary mb-4 bg-bg-pane-dark p-4 rounded-md max-h-[50vh] overflow-y-auto"></div>
        <button id="summary-copy-btn" class="ai-response-copy-btn hidden" title="Copy Summary">
            <i data-feather="copy" class="w-4 h-4"></i>
        </button>
    </div>
    <footer class="flex justify-end gap-3 mt-4">
        <button id="summary-close-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Close</button>
    </footer>
</div>
    <div id="chatbot-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light rounded-lg shadow-2xl w-[90vw] max-w-2xl h-[70vh] z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
        <header class="p-4 border-b border-border-color flex justify-between items-center flex-shrink-0">
            <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="message-square" class="w-5 h-5 text-accent-primary"></i>Chat with AI</h3>
            <div class="flex items-center">
                <button id="chatbot-clear-btn" class="p-2 rounded-full hover:bg-bg-pane-dark" title="Clear Chat History"><i data-feather="trash-2" class="w-5 h-5"></i></button>
                <button id="chatbot-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
            </div>
        </header>
        <div id="chatbot-history" class="flex-grow p-4 space-y-4 overflow-y-auto">
        </div>
        <footer class="p-4 border-t border-border-color flex-shrink-0">
            <div id="chatbot-error" class="text-red-500 text-sm mb-2 h-5"></div>
            <div class="flex items-center gap-2">
                <input id="chatbot-input" type="text" class="w-full bg-bg-pane-dark border border-border-color rounded-full py-2 px-4 focus:ring-2 focus:ring-accent-primary focus:outline-none" placeholder="Ask anything...">
                <button id="chatbot-send-btn" class="bg-gradient-to-r from-[var(--brand-grad-from)] to-[var(--brand-grad-to)] text-white rounded-full w-10 h-10 flex-shrink-0 flex items-center justify-center hover:opacity-90">
                    <i data-feather="arrow-up" class="w-5 h-5"></i>
                </button>
            </div>
        </footer>
    </div>
    
    <div id="toast-container" class="fixed top-4 left-1/2 -translate-x-1/2 z-[1000] transition-all duration-300 ease-in-out origin-top flex flex-col items-center gap-2" style="pointer-events: none;"></div>    
    <div id="inline-toolbar" class="absolute z-30 bg-bg-pane-dark p-1 rounded-lg shadow-md flex items-center gap-1 transition-all duration-150 transform scale-95 opacity-0" style="pointer-events: none;">
    <button id="toolbar-scroll-left" class="toolbar-scroll-btn hidden p-2"><i data-feather="chevron-left" class="w-4 h-4"></i></button>
    
    <div id="inline-toolbar-buttons" class="flex items-center gap-1 overflow-x-auto no-scrollbar">
        <button data-command="bold" class="p-2 hover:bg-bg-main rounded flex-shrink-0"><i data-feather="bold" class="w-4 h-4"></i></button>
        <button data-command="italic" class="p-2 hover:bg-bg-main rounded flex-shrink-0"><i data-feather="italic" class="w-4 h-4"></i></button>
        <button data-command="createLink" class="p-2 hover:bg-bg-main rounded flex-shrink-0"><i data-feather="link" class="w-4 h-4"></i></button>
        <button data-command="insertImage" class="p-2 hover:bg-bg-main rounded flex-shrink-0"><i data-feather="image" class="w-4 h-4"></i></button>
        <button id="attach-file-btn" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Attach File"><i data-feather="paperclip" class="w-4 h-4"></i></button>
        <button data-command="formatBlock" data-value="code" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Code Block"><i data-feather="code" class="w-4 h-4"></i></button>
        <button data-command="formatBlock" data-value="blockquote" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Quote"><strong>&ldquo;</strong></button>
        <button data-command="insertTable" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Insert Table"><i data-feather="grid" class="w-4 h-4"></i></button>
        <button data-command="monospace" class="p-2 hover:bg-bg-main rounded font-mono font-bold flex-shrink-0" title="Monospace">M</button>
        <button data-command="insertChecklist" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Checklist"><i data-feather="check-square" class="w-4 h-4"></i></button>
        <button data-command="toggleCheckboxes" class="p-2 hover:bg-bg-main rounded flex-shrink-0" title="Hide/Show Checkboxes"><i data-feather="eye-off" class="w-4 h-4"></i></button>
        <div class="w-px h-5 bg-border-color mx-1 flex-shrink-0"></div>
        <button data-command="formatBlock" data-value="h1" class="p-2 hover:bg-bg-main rounded font-bold text-sm flex-shrink-0">H1</button>
        <button data-command="formatBlock" data-value="h2" class="p-2 hover:bg-bg-main rounded font-bold text-sm flex-shrink-0">H2</button>
        <button data-command="formatBlock" data-value="h3" class="p-2 hover:bg-bg-main rounded font-bold text-sm flex-shrink-0">H3</button>
    </div>

    <button id="toolbar-scroll-right" class="toolbar-scroll-btn hidden p-2"><i data-feather="chevron-right" class="w-4 h-4"></i></button>
</div>

    <div id="context-menu" class="context-menu fixed z-50 bg-bg-pane-light shadow-2xl rounded-md p-2 w-48 border border-border-color hidden origin-top-left scale-95 opacity-0">
        <button data-action="new-note" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="file-plus" class="w-4 h-4"></i>New Note</button>
        <button data-action="new-folder" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="folder-plus" class="w-4 h-4"></i>New Folder</button>
        <hr class="my-1 border-border-color">
        <button data-action="toggle-pin" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="paperclip" class="w-4 h-4"></i><span id="pin-action-text">Pin</span></button>
        <button data-action="duplicate" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="copy" class="w-4 h-4"></i>Duplicate</button>
        <button data-action="rename" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2"><i data-feather="edit-2" class="w-4 h-4"></i>Rename</button>
        <button data-action="delete" class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark text-red-500 rounded flex items-center gap-2"><i data-feather="trash-2" class="w-4 h-4"></i>Delete</button>
    </div>
    <div id="quiz-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-2xl z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="help-circle" class="w-5 h-5 text-accent-primary"></i>MCQ Quiz</h3>
        <button id="quiz-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div id="quiz-content" class="text-text-secondary mb-4 p-1 rounded-md max-h-[60vh] overflow-y-auto custom-scrollbar">
        </div>
    <footer class="flex justify-end gap-3 mt-4 flex-shrink-0">
        <button id="quiz-done-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Done</button>
    </footer>
</div>
<div id="flashcard-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-xl z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="copy" class="w-5 h-5 text-accent-primary"></i>Flashcards</h3>
        <button id="flashcard-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div id="flashcard-content" class="flex-grow flex flex-col items-center justify-center">
        <div id="flashcard-container" class="w-full h-64 perspective-1000">
            <div id="flashcard" class="relative w-full h-full text-center transition-transform duration-700 transform-style-3d">
                <div id="flashcard-front" class="flashcard-face absolute w-full h-full backface-hidden bg-bg-pane-dark rounded-lg p-4 flex items-center justify-center"></div>
                <div id="flashcard-back" class="flashcard-face absolute w-full h-full backface-hidden bg-bg-pane-dark rounded-lg p-4 flex items-center justify-center transform rotate-y-180"></div>
            </div>
        </div>
    </div>
    <footer class="flex justify-between items-center mt-4 flex-shrink-0">
        <div id="flashcard-progress" class="text-sm text-text-secondary"></div>
        <div class="flex gap-3">
            <button id="flashcard-prev-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Previous</button>
            <button id="flashcard-next-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Next</button>
        </div>
    </footer>
</div>
<div id="global-ai-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-2xl z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="message-circle" class="w-5 h-5 text-accent-primary"></i>Ask Your Notes</h3>
        <button id="global-ai-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    
    <div class="modal-content-area custom-scrollbar flex-grow flex flex-col gap-4 p-1">
        <div>
            <label for="global-ai-input" class="text-sm font-medium text-text-secondary">Your Question</label>
            <textarea id="global-ai-input" rows="3" class="w-full mt-1 bg-bg-pane-dark border border-border-color rounded-md p-2 focus:ring-2 focus:ring-accent-primary focus:outline-none" placeholder="e.g., What was the design strategy for Project Centauri?"></textarea>
        </div>
        
        <div id="global-ai-answer-container" class="hidden">
            <label class="text-sm font-medium text-text-secondary">Answer from your notes</label>
            <div class="relative">
                <div id="global-ai-answer" class="text-text-secondary mt-1 bg-bg-pane-dark p-4 rounded-md prose max-w-none"></div>
                <button id="global-ai-copy-btn" class="ai-response-copy-btn hidden" title="Copy Answer">
                    <i data-feather="copy" class="w-4 h-4"></i>
                </button>
            </div>
        </div>

        <div id="global-ai-sources-container" class="hidden">
             <label class="text-sm font-medium text-text-secondary">Sources</label>
             <div id="global-ai-sources" class="mt-1 space-y-2"></div>
        </div>
    </div>
    <footer class="flex justify-between items-center mt-6 flex-shrink-0 pt-4 border-t border-border-color">
    <button id="global-ai-copy-btn-footer" class="hidden flex items-center gap-2 px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">
        <i data-feather="copy" class="w-4 h-4"></i>Copy Answer
    </button>
    <button id="global-ai-ask-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90 flex items-center gap-2 ml-auto">
        <span id="global-ai-btn-text">Ask</span>
    </button>
</footer>
</div>


    <script type="module">
        feather.replace();

        document.addEventListener('DOMContentLoaded', async () => {
            // PASTE THIS ENTIRE BLOCK RIGHT AFTER the 'DOMContentLoaded' line

// ==================================================================
//  START: CORRECT FUNCTION BLOCK
// ==================================================================
// ==================================================================
//  START: UPGRADED FUNCTION BLOCK
// ==================================================================
const formatRelativeTime = (isoString) => {
    const date = new Date(isoString);
    const now = new Date();
    const seconds = Math.round((now - date) / 1000);
    const minutes = Math.round(seconds / 60);
    const hours = Math.round(minutes / 60);
    const days = Math.round(hours / 24);

    if (seconds < 60) return `${seconds}s ago`;
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    if (days < 7) return `${days}d ago`;
    return date.toLocaleDateString();
};

/**
 * Displays a visual diff between a selected version and the current note.
 */
/**
 * Displays a clean, read-only, interactive snapshot of a selected version.
 */
const displayVersionDiff = (selectedVersionContent) => {
    const viewer = document.getElementById('version-content-viewer');
    
    // Create a temporary container to process the HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = selectedVersionContent;

    // --- Make the preview interactive and clean ---
    
    // 1. Remove all 'contenteditable' attributes to make it read-only.
    tempDiv.querySelectorAll('[contenteditable]').forEach(el => el.removeAttribute('contenteditable'));

    // 2. Make checklist items clickable within the preview.
    tempDiv.querySelectorAll('.checklist-container').forEach(checklist => {
        checklist.addEventListener('click', e => {
            const item = e.target.closest('.checklist-item');
            if (item) {
                const checkbox = item.querySelector('.checklist-item-checkbox');
                const isChecked = !item.classList.contains('checked');
                item.classList.toggle('checked', isChecked);
                if (checkbox) checkbox.checked = isChecked;
                updateChecklistProgress(checklist); // Update the progress bar visually
            }
        });
    });

    // Finally, set the viewer's content to our processed HTML.
    viewer.innerHTML = ''; // Clear previous content
    viewer.appendChild(tempDiv);
    
    // Re-render Feather icons inside the new preview content.
    feather.replace();
};
// --- Manual Checkpoint Listener ---
document.getElementById('header-checkpoint-btn').addEventListener('click', async () => {
    const noteId = state.settings.activeNoteId;
    if (!noteId) return showToast('Please select a note first.', 'info');

    const message = await showPrompt({
        title: 'Save Checkpoint',
        message: 'Add a short message to describe this version:',
        placeholder: 'e.g., Initial draft completed'
    });

    if (message) {
        const note = findItem(noteId)?.item;
        if (note) {
            saveNoteVersion(note.id, note.content, message);
            saveState(); // Persist the new version
            showToast('âœ… Checkpoint saved!', 'success');
        }
    }
});
/**
 * Opens the redesigned Version History modal and sets up interactions.
 */
const closeVersionHistoryModal = () => {
    closeModal(document.getElementById('version-history-modal'));
    const toggleBtn = document.getElementById('sidebar-toggle-btn');
    const resizer = document.getElementById('pane-resizer');

    // Reset inline styles to let the stylesheet control visibility
    if (toggleBtn) toggleBtn.style.display = '';
    if (resizer) resizer.style.display = '';
};
const openVersionHistoryModal = () => {
        const toggleBtn = document.getElementById('sidebar-toggle-btn');
    const resizer = document.getElementById('pane-resizer');
    
    // Hide both the button and the resizer
    if (toggleBtn) toggleBtn.style.display = 'none';
    if (resizer) resizer.style.display = 'none';

    const noteId = state.settings.activeNoteId;
    if (!noteId) return;

    const modal = document.getElementById('version-history-modal');
    const listContainer = document.getElementById('version-list-container');
    const searchInput = document.getElementById('version-search-input');
    const allVersions = state.versions?.[noteId] || [];

    // Helper function to render the list of versions
    const renderVersionList = (filteredVersions) => {
        if (filteredVersions.length === 0) {
            listContainer.innerHTML = `<p class="p-4 text-sm text-center text-text-tertiary">No matching versions found.</p>`;
            document.getElementById('version-content-viewer').innerHTML = ''; // Clear viewer
            document.getElementById('version-restore-btn').style.display = 'none';
        } else {
            document.getElementById('version-restore-btn').style.display = 'inline-flex';
            listContainer.innerHTML = filteredVersions.map((version) => {
                const index = allVersions.indexOf(version); // Get original index for data consistency
                const formattedDate = new Date(version.savedAt).toLocaleString();
                const relativeTime = formatRelativeTime(version.savedAt);
                const plainText = version.content.replace(/<[^>]*>?/gm, ' ').trim();
const preview = plainText.substring(0, 75) + (plainText.length > 75 ? '...' : '');

return `
    <div class="version-item flex items-start gap-2 ${index === 0 && !searchInput.value ? 'active' : ''}" data-version-index="${index}" title="${formattedDate}">
        <input type="checkbox" class="version-compare-checkbox mt-1.5 flex-shrink-0">
        <div class="flex-grow">
            <div class="flex justify-between items-center gap-2">
    <div>
        <div class="version-timestamp">${relativeTime}</div>
        <div class="version-fulldate">${formattedDate}</div>
    </div>
    <div class="flex items-center gap-2 ml-auto">
        ${version.message ? `<div class="version-message flex-shrink-0">${version.message.replace(/</g, "&lt;")}</div>` : ''}
        <button class="delete-version-btn p-1 rounded hover:bg-bg-main text-text-tertiary hover:text-red-500" title="Delete this version"><i data-feather="trash-2" class="w-4 h-4 pointer-events-none"></i></button>
    </div>
</div>
            <div class="version-preview mt-2 text-xs text-text-secondary italic border-l-2 border-border-color pl-2">${preview || 'Empty Note'}</div>
        </div>
    </div>
`;
            }).join('');
            
            // Display the diff for the first item in the filtered list
            displayVersionDiff(filteredVersions[0].content);
            listContainer.querySelector('.version-item')?.classList.add('active');
        }
        feather.replace();
    };

    // Initial render
    searchInput.value = ''; // Clear search on open
    if (allVersions.length > 0) {
        renderVersionList(allVersions);
    } else {
        listContainer.innerHTML = `<p class="p-4 text-sm text-center text-text-tertiary">No versions saved yet.</p>`;
        document.getElementById('version-content-viewer').innerHTML = '';
        document.getElementById('version-restore-btn').style.display = 'none';
    }
    // --- START: Compare Versions Logic ---
const compareBtn = document.getElementById('compare-versions-btn');
const versionList = document.getElementById('version-list-container');

const updateCompareButtonState = () => {
    const checked = versionList.querySelectorAll('.version-compare-checkbox:checked');
    if (checked.length === 2) {
        compareBtn.disabled = false;
        compareBtn.classList.remove('opacity-50');
    } else {
        compareBtn.disabled = true;
        compareBtn.classList.add('opacity-50');
    }
};

versionList.addEventListener('change', (e) => {
    if (e.target.classList.contains('version-compare-checkbox')) {
        updateCompareButtonState();
    }
});

compareBtn.addEventListener('click', async () => {
    const checked = versionList.querySelectorAll('.version-compare-checkbox:checked');
    if (checked.length !== 2) return;

    const viewer = document.getElementById('version-content-viewer');
    const titleEl = document.getElementById('version-history-title');

    // Show a loading state immediately
    titleEl.textContent = 'Generating Comparison...';
    viewer.innerHTML = `<div class="p-4 text-center text-text-secondary">ðŸ§  Asking the AI to summarize the changes...</div>`;
    
    // Disable button to prevent multiple clicks
    compareBtn.disabled = true;
    compareBtn.classList.add('opacity-50');

    try {
        const allVersions = state.versions?.[state.settings.activeNoteId] || [];
        const index1 = parseInt(checked[0].closest('.version-item').dataset.versionIndex, 10);
        const index2 = parseInt(checked[1].closest('.version-item').dataset.versionIndex, 10);
        
        // Ensure "Version 1" is always the older content for a logical comparison
        const oldVersion = allVersions[Math.max(index1, index2)];
        const newVersion = allVersions[Math.min(index1, index2)];

        // Convert HTML to plain text for the AI to process
        const plainTextOld = oldVersion.content.replace(/<[^>]*>?/gm, ' ');
        const plainTextNew = newVersion.content.replace(/<[^>]*>?/gm, ' ');
        
        const prompt = `
            You are a helpful assistant that analyzes changes between two versions of a document.
            Summarize the key differences between "Old Version" and "New Version".
            Structure your response with the following three Markdown headings: "## âœ¨ Added", "## âœï¸ Changed", and "## ðŸ—‘ï¸ Removed".
            Under each heading, use bullet points to list the specific changes.
            If there are no changes for a category, state "No major changes."
            Be concise and focus on the most important modifications.

            ---
            ### Old Version (from ${formatRelativeTime(oldVersion.savedAt)}):
            ${plainTextOld}
            ---
            ### New Version (from ${formatRelativeTime(newVersion.savedAt)}):
            ${plainTextNew}
            ---
        `;
        
        const payload = { contents: [{ parts: [{ text: prompt }] }] };
        const aiResponse = await callGeminiAPI(payload);

        if (aiResponse) {
            // Use marked.parse to render the AI's Markdown response as HTML
            viewer.innerHTML = marked.parse(aiResponse);
            titleEl.textContent = 'Comparison Summary';
        } else {
            viewer.innerHTML = `<p class="p-4 text-center text-red-500">The AI could not generate a comparison. Please try again.</p>`;
            titleEl.textContent = 'Error';
        }

    } catch (error) {
        console.error("Error generating AI comparison:", error);
        viewer.innerHTML = `<p class="p-4 text-center text-red-500">A technical error occurred while generating the comparison.</p>`;
        titleEl.textContent = 'Error';
    } finally {
        // Reset the UI state after completion or error
        compareBtn.disabled = true; // Keep it disabled until new boxes are checked
        compareBtn.classList.add('opacity-50');
        checked.forEach(cb => cb.checked = false);
    }
});
// --- END: Compare Versions Logic ---

    // --- Search Event Listener ---
    const handleSearch = () => {
        const query = searchInput.value.toLowerCase().trim();
        if (!query) {
            renderVersionList(allVersions);
            return;
        }
        const filtered = allVersions.filter(v => {
            const contentMatch = (v.content || '').toLowerCase().includes(query);
            const messageMatch = (v.message || '').toLowerCase().includes(query);
            return contentMatch || messageMatch;
        });
        renderVersionList(filtered);
    };

    // Use a variable to prevent adding multiple listeners
    if (!searchInput.hasAttribute('data-listener-added')) {
        searchInput.addEventListener('input', debounce(handleSearch, 200));
        searchInput.setAttribute('data-listener-added', 'true');
    }
    // --- START: Keyboard Navigation for Version History ---
const versionListContainer = document.getElementById('version-list-container');

const handleKeyboardNav = (e) => {
    if (e.key !== 'ArrowUp' && e.key !== 'ArrowDown' && e.key !== 'Enter') return;
    
    e.preventDefault();
    const items = Array.from(versionListContainer.querySelectorAll('.version-item'));
    if (items.length === 0) return;

    let currentIndex = items.findIndex(item => item.classList.contains('active'));

    if (e.key === 'ArrowUp') {
        currentIndex = (currentIndex > 0) ? currentIndex - 1 : 0;
    } else if (e.key === 'ArrowDown') {
        currentIndex = (currentIndex < items.length - 1) ? currentIndex + 1 : items.length - 1;
    } else if (e.key === 'Enter' && currentIndex !== -1) {
        items[currentIndex].click(); // Simulate a click to select
        const restoreButton = document.querySelector('#banner-restore-btn, #version-restore-btn');
        if (restoreButton) {
            restoreButton.click(); // Simulate clicking the restore button
            if(restoreButton.classList.contains('confirm-state')) {
                 restoreButton.click(); // Click again to confirm
            }
        }
        return;
    }
    
    items.forEach(item => item.classList.remove('active'));
    items[currentIndex].classList.add('active');
    items[currentIndex].scrollIntoView({ block: 'nearest' });
    
    // Trigger a click to update the preview pane
    items[currentIndex].click();
};

modal.addEventListener('keydown', handleKeyboardNav);
// --- END: Keyboard Navigation for Version History ---
    
    openModal(modal);
    feather.replace();
};
// --- START: Version Deletion Logic ---
document.getElementById('version-history-modal').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('.delete-version-btn');
    if (deleteBtn) {
        e.stopPropagation(); // Prevent the version item from being selected
        e.preventDefault();

        const versionItem = deleteBtn.closest('.version-item');
        const versionIndex = parseInt(versionItem.dataset.versionIndex, 10);
        const noteId = state.settings.activeNoteId;
        const versions = state.versions?.[noteId];

        if (versions && typeof versions[versionIndex] !== 'undefined') {
            // Remove the version from the array in the state
            versions.splice(versionIndex, 1);
            
            // Save the updated state to the database
            saveState();

            // Provide feedback to the user
            showToast('Version deleted.', 'success');

            // Refresh the modal content to reflect the deletion
            openVersionHistoryModal();
        }
    }
});
// --- END: Version Deletion Logic ---
const saveNoteVersion = (noteId, content, message = null) => {
    if (!state.versions) state.versions = {};
    if (!state.versions[noteId]) state.versions[noteId] = [];

    const newVersion = {
        savedAt: new Date().toISOString(),
        content: content,
        message: message // Add the message to the version object
    };

    state.versions[noteId].unshift(newVersion);

    const MAX_VERSIONS = 20;
    if (state.versions[noteId].length > MAX_VERSIONS) {
        state.versions[noteId] = state.versions[noteId].slice(0, MAX_VERSIONS);
    }
};

// Find and replace the version history close button listener
document.getElementById('version-history-close-btn').addEventListener('click', closeVersionHistoryModal);


// Remove the old listener on 'version-list-container' and add these new ones
document.getElementById('version-sidebar').addEventListener('click', (e) => {
    const versionItem = e.target.closest('.version-item');
    if (!versionItem || versionItem.classList.contains('active')) return;

    // Remove active class from any other item
    document.querySelectorAll('#version-sidebar .version-item.active').forEach(el => el.classList.remove('active'));
    // Add active class to the clicked item
    versionItem.classList.add('active');

    const noteId = state.settings.activeNoteId;
    const versions = state.versions?.[noteId] || [];
    const selectedIndex = parseInt(versionItem.dataset.versionIndex);
    const selectedVersion = versions[selectedIndex];

    if (selectedVersion) {
        displayVersionDiff(selectedVersion.content);
    }
});

// --- Integrated Version Restore Logic ---
let restoreConfirmTimeout; // Holds the timer for reverting the confirm button

document.getElementById('version-restore-btn').addEventListener('click', (e) => {
    const restoreBtn = e.currentTarget;
    const noteId = state.settings.activeNoteId;
    const activeItem = document.querySelector('#version-sidebar .version-item.active');

    if (!noteId || !activeItem) return;

    // If the button is already in the "Confirm?" state, proceed with the restore
    if (restoreBtn.classList.contains('confirm-state')) {
        clearTimeout(restoreConfirmTimeout); // Stop the timer

        const versions = state.versions?.[noteId] || [];
        const selectedIndex = parseInt(activeItem.dataset.versionIndex);
        const versionToRestore = versions[selectedIndex];

        if (versionToRestore) {
            const { item: note } = findItem(noteId);
            if (note) {
                note.content = versionToRestore.content;
                app.elements.noteEditorBody.innerHTML = note.content;
                performImmediateSave();
                closeVersionHistoryModal(); // Replace the old lines with this one
                showToast('Note restored successfully!', 'success');
            }
        }
        // Reset button after restoring
        restoreBtn.classList.remove('confirm-state');
        restoreBtn.textContent = 'Restore this version';

    } else {
        // First click: Change the button to a "Confirm?" state
        restoreBtn.classList.add('confirm-state');
        restoreBtn.textContent = 'Confirm Restore?';

        // Set a timer to automatically revert the button if not clicked again
        restoreConfirmTimeout = setTimeout(() => {
            restoreBtn.classList.remove('confirm-state');
            restoreBtn.textContent = 'Restore this version';
        }, 3000); // Reverts after 3 seconds
    }
});
const updateChecklistProgress = (checklistContainer) => {
    if (!checklistContainer) return;
    const items = checklistContainer.querySelectorAll('.checklist-item');
    const checkedItems = checklistContainer.querySelectorAll('.checklist-item.checked');
    const total = items.length;
    const checkedCount = checkedItems.length;
    const percentage = total > 0 ? Math.round((checkedCount / total) * 100) : 0;
    const fillEl = checklistContainer.querySelector('.checklist-progress-fill');
    const textEl = checklistContainer.querySelector('.checklist-progress-text');
    if (fillEl) fillEl.style.width = `${percentage}%`;
    if (textEl) textEl.textContent = `${percentage}% Complete`;
};

// --- 1. HELPER FUNCTIONS (Lowest Level) ---
// These are needed by other functions, so they must come first.

function findItem(itemId, tree = state.collections) {
    if (!itemId) return null;
    for (let i = 0; i < tree.length; i++) {
        const item = tree[i];
        if (item.id === itemId) return {item, parent: tree, index: i};
        if (item.children) {
            const result = findItem(itemId, item.children);
            if(result) {
               const parentObject = tree.find(parentItem => parentItem.children === result.parent);
               return { ...result, parent: parentObject || tree };
            }
        }
    }
    return null;
}
const handleSpreadsheetUpload = (file) => {
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

            if (json.length === 0) {
                showToast('Spreadsheet is empty.', 'error');
                return;
            }

            const [headers, ...rows] = json;
            const cols = headers.length;

            let tableHTML = '<table style="width:100%"><thead>';
            tableHTML += `<tr><th colspan="${cols}" contenteditable="false"><div class="table-header-controls"><div class="table-filter-wrapper"><i data-feather="search" class="filter-icon"></i><input class="table-filter-input" placeholder="Filter table..."/></div><button class="toggle-filter-btn" title="Toggle Filter"><i data-feather="chevrons-up" class="w-4 h-4"></i></button></div></th></tr>`;
            tableHTML += '<tr>';
            headers.forEach(header => {
                tableHTML += `<th class="sortable-header" data-sort-dir="none" contenteditable="true">${header}</th>`;
            });
            tableHTML += '</tr></thead><tbody>';

            rows.forEach(row => {
                tableHTML += '<tr>';
                for (let i = 0; i < cols; i++) {
                    tableHTML += `<td contenteditable="true">${row[i] || ''}</td>`;
                }
                tableHTML += '</tr>';
            });

            tableHTML += '</tbody></table><p><br></p>';

            restoreSelectionAndExec(() => document.execCommand('insertHTML', false, tableHTML));
            feather.replace();
            showToast(`âœ… Table imported from ${file.name}`);

        } catch (err) {
            console.error("Spreadsheet parsing error:", err);
            showToast("Failed to parse the spreadsheet file.", "error");
        }
    };
    reader.readAsArrayBuffer(file);
};
/**
 * Renders the flashcard data into the modal and handles the UI logic.
 * @param {Array<Object>} cards - An array of flashcard objects [{front, back}].
 */
function renderFlashcardModal(cards) {
    // Get fresh references to all modal elements each time
    const modal = document.getElementById('flashcard-modal');
    const container = document.getElementById('flashcard-container');
    const frontEl = document.getElementById('flashcard-front');
    const backEl = document.getElementById('flashcard-back');
    const progressEl = document.getElementById('flashcard-progress');
    const prevBtn = document.getElementById('flashcard-prev-btn');
    const nextBtn = document.getElementById('flashcard-next-btn');
    const closeBtn = document.getElementById('flashcard-close-btn');

    let currentIndex = 0;

    // --- All event logic is handled by this one function ---
    const handleModalClick = (e) => {
        // Use .closest() to see if a specific button was clicked
        const targetButton = e.target.closest('button');

        if (targetButton === prevBtn) {
            if (currentIndex > 0) {
                currentIndex--;
                updateCard();
            }
        } else if (targetButton === nextBtn) {
            if (currentIndex < cards.length - 1) {
                currentIndex++;
                updateCard();
            } else {
                cleanupAndClose(); // Finish on the last card
            }
        } else if (targetButton === closeBtn) {
            cleanupAndClose();
        } else {
            // If any other part of the modal is clicked, flip the card
            container.classList.toggle('flipped');
        }
    };

    // This function updates the card's content
    const updateCard = () => {
        container.classList.remove('flipped'); // Always show the front first

        // Use marked.parse to correctly render potential markdown from the AI
        frontEl.innerHTML = marked.parse(cards[currentIndex].front || '');
        backEl.innerHTML = marked.parse(cards[currentIndex].back || '');

        progressEl.textContent = `Card ${currentIndex + 1} of ${cards.length}`;
        prevBtn.disabled = currentIndex === 0;
        nextBtn.textContent = (currentIndex === cards.length - 1) ? 'Finish' : 'Next';
    };

    // This function removes the event listener to prevent future bugs
    const cleanupAndClose = () => {
        modal.removeEventListener('click', handleModalClick);
        closeModal(modal);
    };

    // --- Setup ---
    modal.addEventListener('click', handleModalClick); // Add the single listener
    updateCard(); // Display the first card
    openModal(modal);
    feather.replace();
}

/**
 * Handles the AI call to generate flashcards from note content, with caching.
 * @param {Object} note - The full note object from the state.
 */
const handleFlashcardMode = async (note) => {
    // Step 1: Check for a valid cached result first.
    if (note.cachedFlashcards && note.cachedFlashcards.sourceModifiedAt === note.modifiedAt) {
        showToast('Loading Flashcards!', 'info');
        renderFlashcardModal(note.cachedFlashcards.data);
        return;
    }

    // Step 2: If no cache, call the AI.
    const noteContent = (note.content || '').replace(/<[^>]*>?/gm, '').trim();
    if (!noteContent) {
        showToast("Note is empty, cannot generate flashcards.", "info");
        return;
    }

    const toastId = showToast('Generating Flashcards...', 'loading');
    const prompt = `Analyze the following text and identify the key concepts. Create a series of flashcards based on these concepts. For each flashcard, provide a "front" (a question or term) and a "back" (the answer or definition). Return the result as a single, valid JSON object with a key "flashcards" which is an array of objects. Each object in the array must have two keys: "front" (string) and "back" (string). Do not include any text or markdown formatting outside of the JSON object.
    Text:
    ---
    ${noteContent}`;

    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    const jsonResponse = await callGeminiAPI(payload);
    dismissToast(toastId);

    if (jsonResponse) {
        try {
    // Find the start and end of the JSON object
    const startIndex = jsonResponse.indexOf('{');
    const endIndex = jsonResponse.lastIndexOf('}');

    // Extract only the JSON part of the string
    const jsonString = jsonResponse.substring(startIndex, endIndex + 1);

    const flashcardData = JSON.parse(jsonString);

    if (flashcardData.flashcards && Array.isArray(flashcardData.flashcards)) {
         renderFlashcardModal(flashcardData.flashcards);

         // Cache the new result in the note object.
         note.cachedFlashcards = {
             sourceModifiedAt: note.modifiedAt,
             data: flashcardData.flashcards
         };
         saveState(); // Save the note with the cached data.
    } else {
        throw new Error("Invalid flashcard data structure in JSON.");
    }
} catch (err) {
    console.error("Failed to parse flashcard JSON:", err, "Raw response:", jsonResponse);
    showToast('Failed to generate valid flashcards.', 'error');
}
    }
};
const getAllNotes = (items) => {
    let notes = [];
    for (const item of items) {
        if (item.type === 'note') {
            notes.push(item);
        }
        if (item.type === 'folder' && item.children) {
            notes = notes.concat(getAllNotes(item.children));
        }
    }
    return notes;
};
const getAllFolders = (items = state.collections) => {
    let folders = [];
    for (const item of items) {
        if (item.type === 'folder') {
            folders.push(item);
            if (item.children) {
                folders = folders.concat(getAllFolders(item.children));
            }
        }
    }
    return folders;
};
/**
 * Finds all HTML tables in a string and converts them to a plain-text Markdown format.
 * @param {string} htmlString - The HTML content of a note.
 * @returns {string} The content with tables converted to Markdown.
 */
function convertTablesToMarkdown(htmlString) {
    if (!htmlString || !htmlString.includes('<table')) return htmlString;

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlString;

    tempDiv.querySelectorAll('table').forEach(table => {
        let markdownTable = '\n';
        // Process Header
        const headers = table.querySelectorAll('thead tr:last-child th');
        if (headers.length > 0) {
            markdownTable += `| ${Array.from(headers).map(th => th.innerText.trim()).join(' | ')} |\n`;
            markdownTable += `| ${Array(headers.length).fill('---').join(' | ')} |\n`;
        }
        
        // Process Body
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            markdownTable += `| ${Array.from(cells).map(td => td.innerText.trim()).join(' | ')} |\n`;
        });

        table.outerHTML = markdownTable; // Replace the HTML table with the Markdown version
    });

    return tempDiv.innerHTML;
}
const handleGlobalAIQuery = async () => {
    const askBtn = document.getElementById('global-ai-ask-btn');
    const answerContainer = document.getElementById('global-ai-answer-container');
    const answerEl = document.getElementById('global-ai-answer');
    const inputEl = document.getElementById('global-ai-input');
    const sourcesContainer = document.getElementById('global-ai-sources-container');
    const copyBtnFooter = document.getElementById('global-ai-copy-btn-footer');
    const query = inputEl.value.trim();

    if (!query) return;

    // --- START: MODIFIED SECTION ---
    // Clear previous results and set loading state right when a new question is asked
    askBtn.disabled = true;
    askBtn.querySelector('span').textContent = 'Thinking...';
    answerContainer.classList.add('hidden');
    sourcesContainer.classList.add('hidden');
    copyBtnFooter.classList.add('hidden');
    answerEl.innerHTML = '';
    // --- END: MODIFIED SECTION ---

    const searchResults = lunrIndex.search(query);
    const topNotes = searchResults.slice(0, 5).map(res => findItem(res.ref)?.item).filter(Boolean);

    if (topNotes.length === 0) {
        showToast('No relevant notes found.', 'info');
        askBtn.disabled = false;
        askBtn.querySelector('span').textContent = 'Ask';
        return;
    }

    const context = topNotes.map(note => {
    const contentWithMarkdownTables = convertTablesToMarkdown(note.content);
    return `--- Note: "${note.name}" ---\n${contentWithMarkdownTables.replace(/<[^>]*>?/gm, '')}`;
}).join('\n\n');
    const historyContext = askYourNotesHistory.map(item => `Previous Question: ${item.question}\nPrevious Answer: ${item.answer}`).join('\n\n');
    
    const prompt = `You are a helpful assistant.
${historyContext ? `For context, here is the previous turn of our conversation:\n${historyContext}\n\n` : ''}
Based ONLY on the context from the provided notes below, answer the user's new question. If the answer cannot be found in the notes, say "I could not find an answer in your notes." Do not use any external knowledge.

User's Question: "${query}"

Context from Notes:
${context}`;
    
    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    const aiResponse = await callGeminiAPI(payload);

    if (aiResponse) {
        answerEl.innerHTML = marked.parse(aiResponse);
        answerContainer.classList.remove('hidden');
        copyBtnFooter.classList.remove('hidden');
        
        findAndDisplaySourceSnippets(aiResponse, topNotes);
        
        askYourNotesHistory.push({ question: query, answer: aiResponse });
    } else {
        showToast('The AI could not provide an answer.', 'error');
    }

    askBtn.disabled = false;
    askBtn.querySelector('span').textContent = 'Ask';
    feather.replace();
};

const findAndDisplaySourceSnippets = (aiAnswer, sourceNotes) => {
    const sourcesEl = document.getElementById('global-ai-sources');
    const sourcesContainer = document.getElementById('global-ai-sources-container');
    sourcesEl.innerHTML = '';

    const stopWords = new Set(['a', 'an', 'the', 'is', 'was', 'are', 'in', 'on', 'of', 'to', 'and', 'it', 'for', 'from', 'your', 'notes']);
    const keywords = [...new Set(aiAnswer.toLowerCase().match(/\b(\w+)\b/g) || [])]
        .filter(word => word.length > 3 && !stopWords.has(word));

    if (keywords.length === 0) {
        sourcesContainer.classList.add('hidden');
        return;
    }

    // Calculate raw scores first
    const scoredNotes = sourceNotes.map(note => {
        const noteText = note.content.replace(/<[^>]*>?/gm, ' ').toLowerCase();
        let score = 0;
        keywords.forEach(kw => {
            if (noteText.includes(kw)) score++;
        });
        return { note, score };
    });

    const RELEVANCE_THRESHOLD_SCORE = 1; // Note must contain at least 1 keyword
    let relevantNotes = scoredNotes.filter(item => item.score > RELEVANCE_THRESHOLD_SCORE);
    
    // Calculate the total score for normalization
    const totalScore = relevantNotes.reduce((sum, item) => sum + item.score, 0);

    if (totalScore === 0) {
        sourcesContainer.classList.add('hidden');
        return;
    }

    let snippetsHTML = '';
    relevantNotes
      .sort((a, b) => b.score - a.score) // Sort by highest score
      .forEach(item => {
        // --- NEW: Normalization Logic ---
        const normalizedPercentage = Math.round((item.score / totalScore) * 100);

        let relevanceClass = 'bg-gray-600';
        if (normalizedPercentage > 40) relevanceClass = 'bg-green-500';
        else if (normalizedPercentage > 15) relevanceClass = 'bg-yellow-500';

        const noteText = item.note.content.replace(/<[^>]*>?/gm, ' ');
        let bestSnippet = `..."${noteText.substring(0, 120)}"...`;
        for (const kw of keywords) {
            const regex = new RegExp(`[^.!?]*\\b${kw}\\b[^.!?]*[.!?]`, 'i');
            const match = noteText.match(regex);
            if (match) {
                bestSnippet = `..."${match[0].trim()}"...`;
                break;
            }
        }
        keywords.forEach(kw => {
            bestSnippet = bestSnippet.replace(new RegExp(`\\b(${kw})\\b`, 'gi'), `<strong class="text-accent-primary">$1</strong>`);
        });

        // --- NEW: Snippet is now wrapped in an <a> tag ---
        snippetsHTML += `
            <a href="#" class="source-snippet-link block p-2 border border-border-color bg-bg-pane-dark rounded-md text-xs hover:bg-bg-pane-light" data-note-id="${item.note.id}">
                <div class="font-semibold text-text-primary mb-1 flex justify-between items-center">
                    <span>ðŸ§¾ From: â€œ${item.note.name}â€</span>
                    <span class="text-xs text-white font-medium px-1.5 py-0.5 rounded-full ${relevanceClass}">${normalizedPercentage}% Relevant</span>
                </div>
                <div class="text-text-secondary italic pointer-events-none">${bestSnippet}</div>
            </a>
        `;
    });

    sourcesEl.innerHTML = snippetsHTML;
    sourcesContainer.classList.remove('hidden');
    feather.replace();
};
function parseInternalLinks(htmlContent) {
    
    // This check now prevents the function from running if state or state.collections is missing.
    if (!htmlContent || !state || !state.collections) return htmlContent;

    const allNotes = getAllNotes(state.collections);
    return htmlContent.replace(/\[\[(.*?)\]\]/g, (match, noteName) => {
        const trimmedName = noteName.trim();
        const foundNote = allNotes.find(n => n.name.toLowerCase() === trimmedName.toLowerCase());
        if (foundNote) {
            return `<a href="#" class="internal-link" title="Link to '${foundNote.name}'" data-note-id="${foundNote.id}">${trimmedName}</a>`;
        } else {
            return `<span class="internal-link-broken" title="Note not found: '${trimmedName}'">${trimmedName}</span>`;
        }
    });
}

// --- 2. HANDLER FUNCTIONS (Higher Level) ---
// These functions use the helpers defined above.

const handleShareNote = async (noteToShare) => {
    // This now accepts an argument, or defaults to the active note
    const note = noteToShare || findItem(state.settings.activeNoteId)?.item;
    if (!note) {
        showToast('âŒ No note selected to share.', 'error');
        return;
    }

    const toastId = showToast('Creating share link...', 'loading');

    try {
        const { doc, setDoc, collection } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
        const publicNotesCol = collection(window.db, "publishedNotes");
        const publicNoteRef = doc(publicNotesCol);

        await setDoc(publicNoteRef, {
            name: note.name,
            content: note.content,
            originalAuthor: window.auth.currentUser.uid,
            sharedAt: new Date().toISOString()
        });

        const shareUrl = `${window.location.origin}${window.location.pathname}?view=${publicNoteRef.id}`;
        dismissToast(toastId);

        await showPrompt({
            title: 'Share Link Created',
            message: 'Anyone with this link can view a read-only version of this note.',
            initialValue: shareUrl,
            isReadOnly: true
        });

    } catch (error) {
        console.error("Error creating share link:", error);
        dismissToast(toastId);
        // showToast('Could not create share link.', 'error');
    }
};

const handlePublicNoteView = async (noteId) => {
    // --- Initial Setup ---
    document.getElementById('theme-color-meta')?.setAttribute('content', '#100F1B');
    document.body.classList.remove('overflow-hidden');
    document.getElementById('app-container').style.display = 'none';
    document.getElementById('auth-container').style.display = 'none';
    const publicView = document.getElementById('public-note-view');
    publicView.classList.remove('hidden');
    document.getElementById('chatbot-fab').style.display = 'none';

    try {
        const { doc, getDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
        const docRef = doc(window.db, "publishedNotes", noteId);
        const docSnap = await getDoc(docRef);

        if (docSnap.exists()) {
            const noteData = docSnap.data();
            document.getElementById('public-note-title').textContent = noteData.name;
            document.title = `${noteData.name} | Reputifly Notes`;

            const noteContentDiv = document.getElementById('public-note-content');
            let html = noteData.content || '';

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            
            // **THIS IS THE FIX TO REMOVE THE FILTER BAR**
            tempDiv.querySelectorAll('table').forEach(table => {
                // Find and remove the filter row, which is the first row in the table head
                const filterRow = table.querySelector('thead tr:first-child');
                if (filterRow && filterRow.querySelector('.table-filter-input')) {
                    filterRow.remove();
                }

                // Add sortable class to the actual header row
                table.querySelectorAll('thead tr th').forEach(th => {
                    th.classList.add('sortable-header');
                    th.dataset.sortDir = 'none';
                });
                
                const tbody = table.querySelector('tbody');
                if (tbody) {
                    table._originalRows = Array.from(tbody.querySelectorAll('tr'));
                }
            });
            html = tempDiv.innerHTML.replace(/ contenteditable="true"/g, '');
            noteContentDiv.innerHTML = html;

            // Delegated Click Listener for Sorting and Code Copying
            noteContentDiv.addEventListener('click', (e) => {
                const header = e.target.closest('th.sortable-header');
                if (header) {
                    const table = header.closest('table');
                    const tbody = table.querySelector('tbody');
                    if (!tbody) return;
                    const rowsToSort = Array.from(tbody.querySelectorAll('tr'));
                    const headers = Array.from(header.parentElement.children);
                    const colIndex = headers.indexOf(header);
                    const currentDir = header.dataset.sortDir;
                    const newDir = currentDir === 'asc' ? 'desc' : (currentDir === 'desc' ? 'none' : 'asc');
                    headers.forEach(h => { h.dataset.sortDir = 'none'; h.querySelector('.sort-indicator')?.remove(); });

                    if (newDir === 'none') {
                        if(table._originalRows) tbody.append(...table._originalRows);
                    } else {
                        const isNumeric = rowsToSort.every(row => { const cellText = row.children[colIndex]?.innerText.trim() || ''; return cellText === '' || !isNaN(parseFloat(cellText.replace(/[^0-9.-]+/g, ""))); });
                        rowsToSort.sort((rowA, rowB) => {
                            const cellA = rowA.children[colIndex]?.innerText.trim() || '';
                            const cellB = rowB.children[colIndex]?.innerText.trim() || '';
                            if (isNumeric) { const numA = parseFloat(cellA.replace(/[^0-9.-]+/g, "")) || 0; const numB = parseFloat(cellB.replace(/[^0-9.-]+/g, "")) || 0; return newDir === 'asc' ? numA - numB : numB - numA; }
                            return newDir === 'asc' ? cellA.localeCompare(cellB) : cellB.localeCompare(cellA);
                        });
                        tbody.append(...rowsToSort);
                        header.dataset.sortDir = newDir;
                        header.insertAdjacentHTML('beforeend', `<span class="sort-indicator">${newDir === 'asc' ? 'â–²' : 'â–¼'}</span>`);
                    }
                    return;
                }
                const checklistItem = e.target.closest('.checklist-item');
if (checklistItem) {
    e.preventDefault();
    const checkbox = checklistItem.querySelector('.checklist-item-checkbox');
    const isCheckedNow = !checklistItem.classList.contains('checked');

    if (checkbox) {
        checkbox.checked = isCheckedNow;
    }
    checklistItem.classList.toggle('checked', isCheckedNow);
    return; // Stop further processing for this click
}
                const copyBtn = e.target.closest('.copy-code-btn');
                if (copyBtn) {
                    const codeBlock = copyBtn.closest('.code-block-wrapper')?.querySelector('pre, code');
                    if (codeBlock) { navigator.clipboard.writeText(codeBlock.innerText).then(() => showToast('Code copied!', 'success')).catch(() => showToast('Failed to copy code.', 'error')); }
                }
            });

            // Other existing listeners
            noteContentDiv.addEventListener('change', (e) => {
                if (e.target.matches('.task-list-item input[type="checkbox"]')) {
                    const item = e.target.closest('.task-list-item');
                    if (item) item.classList.toggle('checked', e.target.checked);
                }
            });
            document.getElementById('copy-note-btn').addEventListener('click', () => {
                navigator.clipboard.writeText(noteContentDiv.innerText).then(() => showToast('Note content copied!', 'success')).catch(() => showToast('Failed to copy content.', 'error'));
            });

            hljs.highlightAll();

        } else {
            document.getElementById('public-note-title').textContent = 'Note Not Found';
            document.getElementById('public-note-content').innerHTML = '<p>The link you followed may be broken or the note may have been deleted.</p>';
        }
    } catch (error) {
        console.error("Error fetching public note:", error);
        document.getElementById('public-note-title').textContent = 'Error';
        document.getElementById('public-note-content').innerHTML = '<p>Could not load the note due to an error.</p>';
    } finally {
        feather.replace();
    }
};

// ==================================================================
//  END: CORRECT FUNCTION BLOCK
// ==================================================================
            const params = new URLSearchParams(window.location.search);
    const publicNoteId = params.get('view');
    if (publicNoteId) {
        handlePublicNoteView(publicNoteId);
        return; // Stop the normal app from loading
    }
            
            // --- START: FINAL AUTHENTICATION LOGIC ---

            // Import the functions we need at the top of the module.
            const {
                createUserWithEmailAndPassword,
                signInWithEmailAndPassword,
                sendEmailVerification
            } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js");

            // ADD THIS NEW LINE:
            const { doc, setDoc, getDoc } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
            const { httpsCallable } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-functions.js");

            const authContainer = document.getElementById('auth-container');
            const loginForm = document.getElementById('login-form');
            const authTitle = document.getElementById('auth-title');
            const authError = document.getElementById('auth-error');
            const showSignup = document.getElementById('show-signup');
            const showLogin = document.getElementById('show-login');
            const loginTextLink = document.getElementById('login-text-link');
            const signupTextLink = document.getElementById('signup-text-link');

            // Function to toggle between login and signup views
            const setAuthView = (isLoginView) => {
                authError.textContent = '';
                if (isLoginView) {
                    authTitle.textContent = 'Login to Your Notes';
                    loginForm.dataset.authMode = 'login';
                    loginForm.querySelector('button').textContent = 'Login';
                    loginTextLink.classList.remove('hidden');
                    signupTextLink.classList.add('hidden');
                } else {
                    authTitle.textContent = 'Create an Account';
                    loginForm.dataset.authMode = 'signup';
                    loginForm.querySelector('button').textContent = 'Sign Up';
                    loginTextLink.classList.add('hidden');
                    signupTextLink.classList.remove('hidden');
                }
            };
            
            showSignup.addEventListener('click', (e) => {
                e.preventDefault();
                setAuthView(false);
            });

            showLogin.addEventListener('click', (e) => {
                e.preventDefault();
                setAuthView(true);
            });

            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                authError.textContent = '';
                const email = loginForm['login-email'].value;
                const password = loginForm['login-password'].value;
                const mode = loginForm.dataset.authMode || 'login';

                try {
                    if (mode === 'signup') {
    // Use the globally available 'window.auth'
    const userCredential = await createUserWithEmailAndPassword(window.auth, email, password);
    await sendEmailVerification(userCredential.user); // ADD THIS LINE
    console.log('Sign up successful! Verification email sent.');
} else {
                        await signInWithEmailAndPassword(window.auth, email, password);
                        console.log('Login successful!');
                    }
                } catch (error) {
                    console.error('Authentication error:', error.code, error.message);
                    // Provide a more user-friendly error message
                    switch (error.code) {
                        case 'auth/weak-password':
                            authError.textContent = 'Password should be at least 6 characters.';
                            break;
                        case 'auth/email-already-in-use':
                            authError.textContent = 'This email is already in use. Please login.';
                            break;
                        case 'auth/invalid-credential':
                             authError.textContent = 'Invalid email or password.';
                             break;
                        default:
                            authError.textContent = 'An error occurred. Please try again.';
                            break;
                    }
                }
            });

            // We need to expose the init function to the global scope so our module script can call it
            window.appInit = init;
            
            // --- END: FINAL AUTHENTICATION LOGIC ---

            const app = {
                containers: {
                    app: document.getElementById('app-container'),
                    collectionsList: document.getElementById('collections-list-container'),
                    tagList: document.getElementById('tag-list-container'),
                    kanbanBoard: document.getElementById('kanban-board'),
                    notesListContent: document.getElementById('notes-list-content'),
                    noteEditor: document.getElementById('note-editor-view'),
                    toast: document.getElementById('toast-container'),
                    mainContentArea: document.getElementById('main-content-area'),
                    searchResultsList: document.getElementById('search-results-list'),
                    mobileControlsDropdown: document.getElementById('mobile-controls-dropdown'),
                    desktopHeaderControls: document.getElementById('desktop-header-controls'),
                },
                elements: {
                    body: document.body,
                    notesListPane: document.getElementById('notes-list-pane'),
                    paneResizer: document.getElementById('pane-resizer'),
                    sidebarToggleBtn: document.getElementById('sidebar-toggle-btn'),
                    themeToggle: document.getElementById('theme-toggle'),
                    themeReputifyIcon: document.getElementById('theme-reputify-icon'),
                    themeSunIcon: document.getElementById('theme-sun-icon'),
                    themeMoonIcon: document.getElementById('theme-moon-icon'),
                    themeText: document.getElementById('theme-text'),
                    newCollectionBtn: document.getElementById('new-collection-btn'),
                    desktopNewNoteBtn: document.getElementById('desktop-new-note-btn'),
                    chatbotFab: document.getElementById('chatbot-fab'),
                    currentViewTitle: document.getElementById('current-view-title'),
                    noteEditorTitle: document.getElementById('note-editor-title'),
                    noteEditorBody: document.getElementById('note-editor-body'),
                    markdownPreview: document.getElementById('markdown-preview'),
                    wordCount: document.getElementById('word-count'),
                    charCount: document.getElementById('char-count'),
                    mobileMenuBtn: document.getElementById('mobile-menu-button'),
                    mobileSidebarOverlay: document.getElementById('mobile-sidebar-overlay'),
                    sortOrderSelect: document.getElementById('sort-order'),
                    listViewControls: document.getElementById('list-view-controls'),
                    viewSwitcher: document.getElementById('view-switcher-container'),
                    importFileInput: document.getElementById('import-file-input'),
                    mobileMoreButton: document.getElementById('mobile-more-button'),
                    headerMainContent: document.getElementById('header-main-content'),
                    toggleTagsBtn: document.getElementById('toggle-tags-btn'), // Add this line
                },
                modals: {
                    // Add these new lines for the quiz modal
quiz: document.getElementById('quiz-modal'),
quizContent: document.getElementById('quiz-content'),
quizCloseBtn: document.getElementById('quiz-close-btn'),
quizDoneBtn: document.getElementById('quiz-done-btn'),
                    backdrop: document.getElementById('modal-backdrop'),
                    apiKey: document.getElementById('api-key-modal'),
                    apiKeyInput: document.getElementById('api-key-input'),
                    apiKeyConfirmBtn: document.getElementById('api-key-confirm-btn'),
                    apiKeyError: document.getElementById('api-key-error'),
                    prompt: document.getElementById('prompt-modal'),
                    promptTitle: document.getElementById('prompt-title'),
                    promptMessage: document.getElementById('prompt-message'),
                    promptInput: document.getElementById('prompt-input'),
                    promptError: document.getElementById('prompt-error'),
                    promptConfirmBtn: document.getElementById('prompt-confirm-btn'),
                    promptCancelBtn: document.getElementById('prompt-cancel-btn'),
                    confirm: document.getElementById('confirm-modal'),
                    confirmTitle: document.getElementById('confirm-title'),
                    confirmMessage: document.getElementById('confirm-message'),
                    confirmConfirmBtn: document.getElementById('confirm-confirm-btn'),
                    confirmCancelBtn: document.getElementById('confirm-cancel-btn'),
                    bookmarklet: document.getElementById('bookmarklet-modal'),
                    bookmarkletLink: document.getElementById('bookmarklet-link'),
                    bookmarkletCloseBtn: document.getElementById('bookmarklet-close-btn'),
                    graph: document.getElementById('graph-modal'),
                    graphContainer: document.getElementById('graph-container'),
                    graphCloseBtn: document.getElementById('graph-close-btn'),
                    aiPrompt: document.getElementById('ai-prompt-modal'),
                    aiPromptInput: document.getElementById('ai-prompt-input'),
                    aiPromptError: document.getElementById('ai-prompt-error'),
                    aiGenerateBtn: document.getElementById('ai-generate-btn'),
                    aiCancelBtn: document.getElementById('ai-cancel-btn'),
                    aiGenerateBtnText: document.getElementById('ai-generate-btn-text'),
                    summary: document.getElementById('summary-modal'),
                    summaryContent: document.getElementById('summary-content'),
                    summaryCloseBtn: document.getElementById('summary-close-btn'),
                    chatbot: document.getElementById('chatbot-modal'),
                    chatbotHistory: document.getElementById('chatbot-history'),
                    chatbotInput: document.getElementById('chatbot-input'),
                    chatbotSendBtn: document.getElementById('chatbot-send-btn'),
                    chatbotCloseBtn: document.getElementById('chatbot-close-btn'),
                    chatbotClearBtn: document.getElementById('chatbot-clear-btn'),
                    chatbotError: document.getElementById('chatbot-error'),
                },
                search: {
                    icon: document.getElementById('header-search-icon'),
                    mobileIcon: document.getElementById('mobile-search-icon'),
                    container: document.getElementById('search-bar-container'),
                    input: document.getElementById('search-input'),
                    closeBtn: document.getElementById('search-close-btn'),
                },
                toolbar: {
                    inline: document.getElementById('inline-toolbar'),
                    editorModeToggle: document.getElementById('editor-mode-toggle'),
                    ocrBtn: document.querySelector('[data-command="ocr"]'),
                    ocrFileInput: document.getElementById('ocr-file-input'),
                    dictateBtn: document.getElementById('dictate-btn'),
                    graphBtn: document.getElementById('graph-btn'),
                },
                views: {
                    board: document.getElementById('board-view'),
                    list: document.getElementById('list-view'),
                    searchResults: document.getElementById('search-results-view'),
                },
                contextMenu: {
                    menu: document.getElementById('context-menu'),
                    targetId: null,
                    targetIsContainer: false,
                    pinActionText: document.getElementById('pin-action-text'),
                    togglePinBtn: document.querySelector('[data-action="toggle-pin"]'),
                    renameBtn: document.querySelector('[data-action="rename"]'),
                    deleteBtn: document.querySelector('[data-action="delete"]'),
                    duplicateBtn: document.querySelector('[data-action="duplicate"]'),
                }
            };

            let state = {};
            let isSearchActive = false;
            let editorSelectionRange = null;
            let speechRecognizer = null;
            let isDictating = false;
            let saveNoteContent;
            let performImmediateSave;
            const restoreSelectionAndExec = (execFn) => {
                        app.elements.noteEditorBody.focus();
                        if (editorSelectionRange) {
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(editorSelectionRange);
                        }
                        execFn();
                        saveNoteContent();
                        if (window.getSelection().rangeCount > 0) {
                           editorSelectionRange = window.getSelection().getRangeAt(0).cloneRange();
                        }
                    };
            let lunrIndex;
            let hasInitialized = false;
            let askYourNotesHistory = [];
            const showToast = (message, type = 'info') => {
                const id = generateId('toast');
                const toast = document.createElement('div');
                const colors = {
                    info: 'bg-bg-pane-dark text-text-primary',
                    success: 'bg-green-500 text-white',
                    error: 'bg-red-500 text-white',
                    loading: 'bg-blue-500 text-white animate-pulse'
                }
                toast.id = id;
                toast.className = `toast-item ${colors[type]} rounded-full px-4 py-2 text-sm shadow-lg transition-all duration-300 transform translate-y-[-20px] opacity-0`;
                toast.textContent = message;
                
                app.containers.toast.appendChild(toast);
                app.containers.toast.style.pointerEvents = 'auto';

                setTimeout(() => {
                    toast.classList.remove('translate-y-[-20px]', 'opacity-0');
                }, 10);
                
                if (type !== 'loading') {
                    setTimeout(() => {
                        toast.classList.add('opacity-0', 'scale-90');
                        toast.addEventListener('transitionend', () => {
                             if(toast.parentElement) toast.parentElement.removeChild(toast);
                             if (app.containers.toast.childElementCount === 0) {
                                app.containers.toast.style.pointerEvents = 'none';
                             }
                        });
                    }, 3000);
                }
                return id;
            };
            
            const dismissToast = (toastId) => {
                const toast = document.getElementById(toastId);
                if (toast) {
                    toast.classList.add('opacity-0', 'scale-90');
                    toast.addEventListener('transitionend', () => {
                         if(toast.parentElement) toast.parentElement.removeChild(toast);
                         if (app.containers.toast.childElementCount === 0) {
                            app.containers.toast.style.pointerEvents = 'none';
                         }
                    });
                }
            };
            function saveCurrentNoteImmediately() {
    if (!state.settings.activeNoteId) return;
    const findResult = findItem(state.settings.activeNoteId);
    if (findResult && findResult.item) {
        const note = findResult.item;
        const newName = app.elements.noteEditorTitle.value;
        const newContent = app.elements.noteEditorBody.innerHTML;

        // Update the state object in memory right away
        note.name = newName;
        note.content = newContent;
        note.modifiedAt = new Date().toISOString();
        updateNoteLinks(note);
        updateNoteTags(note);

        // Trigger the async save to the database
        saveState();

        // Update the UI
        buildLunrIndex();
        renderCollectionsList();
    }
}
            // --- START: In-Note Search Logic ---
            // Add this new function
function closeAndClearSearch() {
    const editorBody = app.elements.noteEditorBody;
    const highlightControls = document.getElementById('highlight-controls');

    if (highlightControls) {
        highlightControls.classList.add('hidden');
    }

    clearInNoteHighlights();
    const inNoteInput = document.getElementById('in-note-search-input');
    if (inNoteInput) {
        inNoteInput.value = '';
    }
    updateInNoteUI();

    const marks = Array.from(editorBody.querySelectorAll('mark:not(.in-note-highlight)'));

    if (marks.length > 0) {
        marks.forEach(mark => {
            const parent = mark.parentNode;
            while (mark.firstChild) {
                parent.insertBefore(mark.firstChild, mark);
            }
            parent.removeChild(mark);
            parent.normalize();
        });
    }

    // This is the key: Instantly update the note's content in the state 
    // and trigger the database save, fixing the refresh bug.
    saveCurrentNoteImmediately();
}
let inNoteMatches = [];
let inNoteCurrentIndex = -1;

function clearInNoteHighlights() {
    const editorBody = app.elements.noteEditorBody;
    const marks = Array.from(editorBody.querySelectorAll('mark.in-note-highlight'));
    marks.forEach(mark => {
        const parent = mark.parentNode;
        parent.replaceChild(document.createTextNode(mark.textContent), mark);
        parent.normalize(); // Merges adjacent text nodes
    });
    inNoteMatches = [];
    inNoteCurrentIndex = -1;
}

function updateInNoteUI() {
    const countEl = document.getElementById('in-note-search-count');
    const nextBtn = document.getElementById('in-note-search-next');
    const prevBtn = document.getElementById('in-note-search-prev');

    if (inNoteMatches.length === 0) {
        countEl.textContent = 'No results';
        nextBtn.disabled = true;
        prevBtn.disabled = true;
    } else {
        countEl.textContent = `${inNoteCurrentIndex + 1} of ${inNoteMatches.length}`;
        nextBtn.disabled = inNoteCurrentIndex >= inNoteMatches.length - 1;
        prevBtn.disabled = inNoteCurrentIndex <= 0;
    }
}

function navigateToMatch(index) {
    if (inNoteMatches[inNoteCurrentIndex]) {
        inNoteMatches[inNoteCurrentIndex].classList.remove('current');
    }
    inNoteCurrentIndex = index;
    const currentMatch = inNoteMatches[inNoteCurrentIndex];
    currentMatch.classList.add('current');

    // --- ROBUST SCROLL LOGIC TO PREVENT CUT-OFF HEADER ---
    // This is the new, more reliable scrolling logic.
// This new logic correctly calculates scroll position, accounting for the header
            const mainContentArea = document.getElementById('main-content-area');
            const header = document.getElementById('highlight-controls');
            const headerHeight = header.offsetHeight;
            const elementRect = currentMatch.getBoundingClientRect();
            const containerRect = mainContentArea.getBoundingClientRect();
            const scrollTop = mainContentArea.scrollTop;
            const desiredPadding = 20; // A little space between the header and the highlight

            const elementTopRelativeToContainer = elementRect.top - containerRect.top;
            const targetScrollTop = scrollTop + elementTopRelativeToContainer - headerHeight - desiredPadding;

            mainContentArea.scrollTo({
                top: targetScrollTop,
                behavior: 'smooth'
            });
    // --- END OF NEW LOGIC ---

    updateInNoteUI();
}

function performInNoteSearch() {
    clearInNoteHighlights();
    const query = document.getElementById('in-note-search-input').value;
    if (!query) {
        updateInNoteUI();
        return;
    }

    const editorBody = app.elements.noteEditorBody;
    const regex = new RegExp(`(${query.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')})`, 'gi');

    const walker = document.createTreeWalker(editorBody, NodeFilter.SHOW_TEXT, null, false);
    let node;
    const nodesToReplace = [];
    while (node = walker.nextNode()) {
        if (node.parentElement.tagName !== 'SCRIPT' && node.parentElement.tagName !== 'STYLE' && regex.test(node.textContent)) {
            nodesToReplace.push(node);
        }
    }

    nodesToReplace.forEach(node => {
        const newHtml = node.textContent.replace(regex, `<mark class="in-note-highlight">$1</mark>`);
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = newHtml;
        // Make checklist widget interactive on public page
tempDiv.querySelectorAll('.checklist-container').forEach(el => el.removeAttribute('contenteditable'));
tempDiv.querySelectorAll('.checklist-item-checkbox').forEach(cb => cb.removeAttribute('onclick'));
        const parent = node.parentNode;
        while(tempDiv.firstChild) {
            parent.insertBefore(tempDiv.firstChild, node);
        }
        parent.removeChild(node);
    });

    inNoteMatches = Array.from(editorBody.querySelectorAll('mark.in-note-highlight'));
    if (inNoteMatches.length > 0) {
        navigateToMatch(0);
    } else {
        updateInNoteUI();
    }
}

function setupInNoteSearchListeners() {
    const searchInput = document.getElementById('in-note-search-input');
    document.getElementById('clear-search-btn').addEventListener('click', closeAndClearSearch);

    document.getElementById('in-note-search-next').addEventListener('click', () => {
        if (inNoteCurrentIndex < inNoteMatches.length - 1) {
            navigateToMatch(inNoteCurrentIndex + 1);
        }
    });

    document.getElementById('in-note-search-prev').addEventListener('click', () => {
        if (inNoteCurrentIndex > 0) {
            navigateToMatch(inNoteCurrentIndex - 1);
        }
    });

    searchInput.addEventListener('input', performInNoteSearch);
    searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            if(e.shiftKey) {
                document.getElementById('in-note-search-prev').click();
            } else {
                document.getElementById('in-note-search-next').click();
            }
        }
        if (e.key === 'Escape') {
             // Use the correct button ID for the smart bar's 'X'
             document.getElementById('clear-search-btn').click();
        }
    });
}
// --- END: In-Note Search Logic ---

            // REPLACE THE OLD OBJECT WITH THIS NEW ONE
const defaultState = {
    collections: [
        {
            id: 'c1', name: 'My First Project', type: 'folder', children: [
                {
                    id: 'n1',
                    name: 'ðŸš€ Getting Started',
                    type: 'note',
                    content: `<h1>Welcome to Your AI Notes!</h1><p>This is an interactive note to help you get started. Here are some of the key features you should know:</p><h2>The Command Palette</h2><p>The fastest way to do anything is with the command palette. Press <code>Ctrl + /</code> (or <code>Cmd + /</code>) to open it. Try typing:</p><ul><li><code>/nn</code> to create a new note.</li><li><code>/nf</code> to create a new folder.</li><li><code>/go</code> to quickly jump to any note or folder.</li><li><code>/help</code> to see all available commands!</li></ul><h2>Pro-Editing Tips (Force Escape with CTRL + Enter)</h2><p>To make writing faster, use these shortcuts:</p><blockquote>To escape a special block like this quote, a code block, or a table, just press <code>Ctrl + Enter</code>!</blockquote><p>You can also create links between notes using the <code>[[Note Name]]</code> syntax. For example, here's a link to the other note in this project: [[Sample Code Snippets]].</p><h2>AI-Powered Features âœ¨</h2><p>You can generate summaries and quizzes from your notes! Open the command palette and type <code>/summary</code> or <code>/quiz</code> to try it on this note.</p><h2>Your First Checklist</h2><p>You can create checklists for your tasks. Just select some text and use the inline formatting bar.</p><div class="task-list-item"><input type="checkbox" contenteditable="false"><div class="task-list-item-text" contenteditable="true">Explore the Command Palette with <code>Ctrl + /</code></div></div><div class="task-list-item"><input type="checkbox" contenteditable="false"><div class="task-list-item-text" contenteditable="true">Create a new note and try the <code>[[Link]]</code> syntax</div></div><div class="task-list-item checked" checked><input type="checkbox" contenteditable="false" checked><div class="task-list-item-text" contenteditable="true">Review the "Getting Started" guide</div></div><p>Enjoy taking smarter notes! #gettingstarted</p>`,
                    links: ['Sample Code Snippets'],
                    tags: ['gettingstarted'],
                    status: 'col1',
                    pinned: true,
                    createdAt: new Date().toISOString(),
                    modifiedAt: new Date().toISOString()
                },
                {
                    id: 'n2',
                    name: 'Sample Code Snippets',
                    type: 'note',
                    content: '<h2>JavaScript Code Example</h2><div class="code-block-wrapper"><div class="code-block-header"><span>javascript</span><button class="copy-code-btn"><i data-feather="copy" class="w-4 h-4"></i><span>Copy</span></button></div><pre contenteditable="true"><code>function sayHello(name) {\n  console.log(\`Hello, \${name}!\`);\n}\nsayHello("World");</code></pre></div><p>This is an example of a syntax-highlighted code block. You can press <code>Ctrl + Enter</code> to exit it. #javascript #example</p>',
                    links: [],
                    tags: ['javascript', 'example'],
                    status: 'col2',
                    pinned: false,
                    createdAt: new Date().toISOString(),
                    modifiedAt: new Date().toISOString()
                },
            ], expanded: true
        }
    ],
    settings: {
        theme: 'reputify',
        activeCollectionId: 'c1',
        activeNoteId: 'n1',
        paneWidth: 280,
        sidebarCollapsed: false,
        activeView: 'list',
        listSortOrder: 'modifiedAt-desc',
        editorMode: 'editor',
        activeTag: null,
        tagsCollapsed: false,
        backlinksCollapsed: false,
        chatbotVisible: true,
    },
    kanbanColumns: {
        'c1': [{ id: 'col1', title: 'To Do' }, { id: 'col2', title: 'In Progress' }, { id: 'col3', title: 'Done' }]
    },
    chatHistory: []
};

            async function saveState() {
                // Get the current user from Firebase Auth
                const user = window.auth.currentUser;

                // If no user is logged in, do nothing.
                if (!user) return;

                try {
                    // Create a reference to a specific document in Firestore.
                    // The path is /users/{the_user's_ID}/data/appState
                    // This ensures every user has their own private data document.
                    const userDocRef = doc(window.db, "users", user.uid, "data", "appState");

                    // Save the entire state object to that document.
                    await setDoc(userDocRef, state);

                } catch (error) {
                    console.error("Failed to save state to Firestore:", error);
                    showToast("Error saving data to the cloud.", 'error');
                }
            }
            function renderTagsState() {
    const isCollapsed = state.settings.tagsCollapsed;
    app.elements.toggleTagsBtn.classList.toggle('collapsed', isCollapsed);
    app.containers.tagList.classList.toggle('collapsed', isCollapsed);
}
            function migrateState(loadedState) {
    // This function ensures that data loaded from the cloud has all the necessary properties,
    // preventing errors if the data structure is old or incomplete.

    const migrateNode = (node) => {
        if (node.type === 'note') {
            if (typeof node.pinned === 'undefined') node.pinned = false;
            if (!Array.isArray(node.links)) node.links = [];
            if (!Array.isArray(node.tags)) node.tags = [];
            const now = new Date().toISOString();
            if (typeof node.createdAt === 'undefined') node.createdAt = now;
            if (typeof node.modifiedAt === 'undefined') node.modifiedAt = node.createdAt;
        }
        if (node.children) {
            // Ensure children is an array before trying to loop through it
            if (Array.isArray(node.children)) {
                node.children.forEach(migrateNode);
            } else {
                node.children = [];
            }
        }
    };
    if (typeof loadedState.settings.backlinksCollapsed === 'undefined') loadedState.settings.backlinksCollapsed = false; // Add this line


    if (!loadedState) loadedState = {};
    if (!loadedState.settings) loadedState.settings = {};
        if (typeof loadedState.settings.chatbotVisible === 'undefined') loadedState.settings.chatbotVisible = true; // ADD THIS LINE


    // THIS IS THE KEY FIX: Ensure .collections is always an array.
    if (!Array.isArray(loadedState.collections)) {
        loadedState.collections = [];
    }

    if (!loadedState.kanbanColumns) loadedState.kanbanColumns = {};
    if (!Array.isArray(loadedState.chatHistory)) loadedState.chatHistory = [];

    // Now that we've confirmed .collections is an array, we can safely loop through it.
    loadedState.collections.forEach(migrateNode);

    // Set default settings if they are missing
    if (typeof loadedState.settings.sidebarCollapsed === 'undefined') loadedState.settings.sidebarCollapsed = false;
    if (typeof loadedState.settings.paneWidth === 'undefined') loadedState.settings.paneWidth = 280;
    if (typeof loadedState.settings.activeTag === 'undefined') loadedState.settings.activeTag = null;
    if (typeof loadedState.settings.tagsCollapsed === 'undefined') loadedState.settings.tagsCollapsed = false; // Add this line
    if (!loadedState.settings.listSortOrder) loadedState.settings.listSortOrder = 'modifiedAt-desc';
    if (!loadedState.settings.editorMode) loadedState.settings.editorMode = 'editor';

    return loadedState;
}

            // REPLACE the old loadState function with this one.

async function loadState() {
    const user = window.auth.currentUser;
    if (!user) return; // Should not happen, but good practice.

    const toastId = showToast('Loading Notes...', 'loading');
    const userDocRef = doc(window.db, "users", user.uid, "data", "appState");

    try {
        // Attempt to get the document from Firestore.
        // With persistence enabled, this will first try the cache, then the server.
        const docSnap = await getDoc(userDocRef);

        if (docSnap.exists()) {
            // Data was successfully loaded from cache or server.
            console.log("Successfully loaded state from Firestore.");
            const loadedState = docSnap.data();
            state = migrateState(loadedState);
        } else {
            // This is a confirmed new user because we got a response from the server
            // saying the document does not exist. It's safe to load defaults.
            console.log("No data in cloud, loading default state for new user.");
            state = JSON.parse(JSON.stringify(defaultState));
            await saveState(); // Save the default state for the new user.
        }

    } catch (error) {
        // This block now only runs if the user is offline AND data is not in the cache.
        console.error("Failed to load state:", error.message);

        // THE KEY FIX: Do NOT reset the state to default.
        // Instead, we trust the 'state' object that might already be in memory.
        // If 'state' is empty, we initialize it to an empty shell to prevent errors.
        if (!state || Object.keys(state).length === 0) {
            console.log("Could not fetch from cache or network. Initializing empty state.");
            state = migrateState({}); // Initializes with empty arrays/objects.
        }
        showToast("Offline: Could not sync with cloud.", 'error');

    } finally {
        dismissToast(toastId);
        // This was in the old function; keep it for theme consistency.
        state.settings.theme = localStorage.getItem('codex-notes-theme') || 'reputify';
    }
}

            const generateId = (prefix = 'id') => `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            function formatBytes(bytes, decimals = 2) {
    if (!+bytes) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}

const handleFileUpload = async (file) => {
    const user = window.auth.currentUser;
    if (!file || !user) return;
    const spreadsheetTypes = [
        'text/csv',
        'application/vnd.ms-excel',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    ];
    if (spreadsheetTypes.includes(file.type)) {
        handleSpreadsheetUpload(file);
        return; // Stop further execution
    }

    // --- Overall file size limit ---
    const OVERALL_MAX_SIZE = 5 * 1024 * 1024; // 5 MB

    let fileToUpload = file;

    // --- Step 1: Perform local compression if the file is an image ---
    if (file.type.startsWith('image/')) {
        const localToast = showToast(`Optimizing ${file.name}...`, 'loading');
        try {
            const options = {
                maxWidthOrHeight: 1920,
                initialQuality: 0.8,
                fileType: 'image/webp',
                useWebWorker: true,
            };
            fileToUpload = await imageCompression(file, options);
            dismissToast(localToast);
        } catch (error) {
            dismissToast(localToast);
            console.error('Local compression failed.', error);
            // If local compression fails, we continue with the original file.
        }
    }

    // --- Step 2: Check the final file size against the 5MB limit ---
    if (fileToUpload.size > OVERALL_MAX_SIZE) {
        showToast(`File is too large (${(fileToUpload.size / 1024 / 1024).toFixed(2)} MB). Max size is 5MB.`, 'error');
        return;
    }

    // --- Step 3: Upload the processed file directly to Firebase Storage ---
    const uploadToastId = showToast(`Uploading ${fileToUpload.name}... 0%`, 'loading');
    try {
        const { getStorage, ref, uploadBytesResumable, getDownloadURL } = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js");
        const storage = getStorage();
        const storageRef = ref(storage, `users/${user.uid}/${Date.now()}-${fileToUpload.name}`);
        const uploadTask = uploadBytesResumable(storageRef, fileToUpload);

        const downloadURL = await new Promise((resolve, reject) => {
            uploadTask.on('state_changed',
                (snapshot) => {
                    const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                    const toastElement = document.getElementById(uploadToastId);
                    if (toastElement) toastElement.textContent = `Uploading ${fileToUpload.name}... ${Math.round(progress)}%`;
                },
                (error) => reject(error),
                async () => {
                    const url = await getDownloadURL(uploadTask.snapshot.ref);
                    resolve(url);
                }
            );
        });

        // --- Step 4: Insert the final file/image into the editor ---
        dismissToast(uploadToastId);
        showToast('Upload complete!', 'success');

        const escapedFileName = fileToUpload.name.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        let fileHTML = '';

        if (fileToUpload.type.startsWith('image/')) {
            fileHTML = `<p><img src="${downloadURL}" alt="${escapedFileName}" style="max-width: 100%; height: auto; border-radius: 8px;" contenteditable="false" /></p>`;
        } else {
            fileHTML = `<div class="file-attachment-widget" contenteditable="false">
                            <i data-feather="file-text" class="w-6 h-6 text-text-secondary flex-shrink-0"></i>
                            <div class="file-info">
                                <div class="file-name">${escapedFileName}</div>
                                <div class="file-size">${formatBytes(fileToUpload.size)}</div>
                            </div>
                            <a href="${downloadURL}" target="_blank" class="brand-button p-2" download title="Download ${escapedFileName}"><i data-feather="download" class="w-5 h-5"></i></a>
                        </div>`;
        }

        app.elements.noteEditorBody.focus();
        document.execCommand('insertHTML', false, fileHTML + "<p><br></p>");
        feather.replace();
        saveNoteContent();

    } catch (error) {
        dismissToast(uploadToastId);
        showToast(`Upload failed: ${error.code || error.message}`, 'error');
        return;
    }
};
            
            

            const debounce = (func, delay) => {
                let timeout;
                return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), delay);
                };
            };
            
            
            
            const formatDateTime = (isoString) => {
                 return new Date(isoString).toLocaleString(undefined, {
                    year: 'numeric', month: 'short', day: 'numeric',
                    hour: 'numeric', minute: '2-digit', hour12: true
                 }).replace(/, /g, ', ');
            };
            
            async function callGeminiAPI(payload, elementForError) {
                // Clear any previous errors
                if (elementForError) elementForError.textContent = '';

                try {
                    // Create a reference to our deployed Cloud Function
                    const callGeminiFunction = httpsCallable(window.functions, 'callGemini');
                    
                    // Call the function with our prompt.
                    // The Firebase SDK automatically handles sending the user's auth token.
                    const response = await callGeminiFunction({ prompt: payload.contents[0].parts[0].text });

                    // The actual result from our function is in response.data.result
                    const generatedText = response.data.result;

                    if (!generatedText) {
                        throw new Error('Cloud function returned an empty response.');
                    }
                    return generatedText;

                } catch (err) {
                    console.error("Error calling Cloud Function:", err);
                    const errorMsg = `AI Error: ${err.message}`;
                    if (elementForError) elementForError.textContent = errorMsg;
                    else showToast(errorMsg, 'error');
                    return null;
                }
            }

            const openModal = (modal, isBlocking = false) => {
                const backdrop = app.modals.backdrop;
                
                if (isBlocking) {
                    backdrop.classList.add('bg-black/50');
                    backdrop.classList.remove('bg-black/30');
                } else {
                    backdrop.classList.add('bg-black/30');
                    backdrop.classList.remove('bg-black/50');
                }
                backdrop.style.opacity = '1';
                modal.classList.remove('hidden');
                setTimeout(() => {
                    modal.classList.remove('scale-95', 'opacity-0');
                }, 10);
            };

            const closeModal = (modal) => {
                const backdrop = app.modals.backdrop;
                backdrop.style.opacity = '0';
                backdrop.style.pointerEvents = 'none';

                modal.classList.add('scale-95', 'opacity-0');
                setTimeout(() => {
                    modal.classList.add('hidden');
                }, 300);
            };

            const showPrompt = ({ title, message, initialValue = '', placeholder = '', isReadOnly = false }) => {
    return new Promise((resolve) => {
        app.modals.promptTitle.textContent = title;
        app.modals.promptMessage.textContent = message;
        app.modals.promptInput.value = initialValue;
        app.modals.promptInput.placeholder = placeholder;
        app.modals.promptInput.readOnly = isReadOnly;
        app.modals.promptError.textContent = '';

        app.modals.promptConfirmBtn.textContent = isReadOnly ? 'Copy Link' : 'Confirm';

        openModal(app.modals.prompt);
        app.modals.promptInput.focus();
        app.modals.promptInput.select();

        const confirmHandler = () => {
            if (isReadOnly) {
                navigator.clipboard.writeText(app.modals.promptInput.value)
                    .then(() => showToast('Link copied to clipboard!', 'success'))
                    .catch(() => showToast('Failed to copy link.', 'error'));
                cleanup();
                resolve(null);
            } else {
                const value = app.modals.promptInput.value.trim();
                if (value) {
                    cleanup();
                    resolve(value);
                } else {
                    app.modals.promptError.textContent = 'Input cannot be empty.';
                }
            }
        };

        const cancelHandler = () => { cleanup(); resolve(null); };
        const cleanup = () => {
            app.modals.promptConfirmBtn.removeEventListener('click', confirmHandler);
            app.modals.promptCancelBtn.removeEventListener('click', cancelHandler);
            app.modals.backdrop.removeEventListener('click', backdropHandler);
            closeModal(app.modals.prompt);
        };

        const backdropHandler = () => cancelHandler();

        app.modals.promptConfirmBtn.addEventListener('click', confirmHandler);
        app.modals.promptCancelBtn.addEventListener('click', cancelHandler);
        app.modals.backdrop.addEventListener('click', backdropHandler);
    });
};
            
            const showConfirm = ({ title, message, confirmText = 'Confirm', confirmClass = 'bg-red-600' }) => {
     return new Promise((resolve) => {
        app.modals.confirmTitle.textContent = title;
        app.modals.confirmMessage.innerHTML = message;
        app.modals.confirmConfirmBtn.textContent = confirmText;
        
        app.modals.confirmConfirmBtn.className = "px-4 py-2 rounded-md text-white hover:opacity-90";
        if (state.settings.theme === 'reputify' && confirmClass.includes('red')) {
            app.modals.confirmConfirmBtn.classList.add('bg-red-600');
        } else {
            app.modals.confirmConfirmBtn.classList.add('brand-button');
        }

        openModal(app.modals.confirm);
        app.modals.backdrop.style.pointerEvents = 'auto'; // <-- ADD THIS LINE

        const confirmHandler = () => { cleanup(); resolve(true); };
        const cancelHandler = () => { cleanup(); resolve(false); };
        const backdropHandler = () => cancelHandler();

        const cleanup = () => {
            app.modals.backdrop.style.pointerEvents = 'none'; // <-- ADD THIS LINE
            app.modals.confirmConfirmBtn.removeEventListener('click', confirmHandler);
            app.modals.confirmCancelBtn.removeEventListener('click', cancelHandler);
            app.modals.backdrop.removeEventListener('click', backdropHandler);
            closeModal(app.modals.confirm);
        };

        app.modals.confirmConfirmBtn.addEventListener('click', confirmHandler);
        app.modals.confirmCancelBtn.addEventListener('click', cancelHandler);
        app.modals.backdrop.addEventListener('click', backdropHandler);
    });
};
            
            function render() {
    renderTheme();
    renderSidebarState();
    renderCollectionsList();
    renderTagList();
    renderTagsState();
    //renderChatbotState(); // This line is removed
    renderMainView();
    renderMobileControls();

    // --- START: NEW CONSOLIDATED LOGIC ---
    const fab = document.getElementById('chatbot-fab');
    const toggleBtn = document.getElementById('chatbot-toggle-btn');

    if (state.settings.chatbotVisible) {
        fab.style.display = 'flex'; // Use style.display for direct control
        toggleBtn.querySelector('span').textContent = 'Hide Chatbot Button';
    } else {
        fab.style.display = 'none'; // Use style.display for direct control
        toggleBtn.querySelector('span').textContent = 'Show Chatbot Button';
    }
    // --- END: NEW CONSOLIDATED LOGIC ---


    const noteActive = !!state.settings.activeNoteId;
    document.getElementById('header-share-btn').style.display = noteActive ? 'flex' : 'none';
    document.getElementById('header-summarize-btn').style.display = noteActive ? 'flex' : 'none';
    document.getElementById('header-quiz-btn').style.display = noteActive ? 'flex' : 'none';
    document.getElementById('header-flashcard-btn').style.display = noteActive ? 'flex' : 'none';

    app.toolbar.editorModeToggle.disabled = !noteActive;
    app.toolbar.dictateBtn.disabled = !noteActive || !speechRecognizer;
    app.toolbar.graphBtn.disabled = !noteActive;

    feather.replace();
}
            
            function renderTheme() {
                const docEl = document.documentElement;
                docEl.classList.remove('reputify-theme', 'dark', 'light');
                app.elements.themeReputifyIcon.classList.add('hidden');
                app.elements.themeSunIcon.classList.add('hidden');
                app.elements.themeMoonIcon.classList.add('hidden');

                if (state.settings.theme === 'dark') {
                    docEl.classList.add('dark');
                    app.elements.themeMoonIcon.classList.remove('hidden');
                    app.elements.themeText.textContent = 'Dark Theme';
                } else if (state.settings.theme === 'reputify') {
                    docEl.classList.add('reputify-theme');
                    app.elements.themeReputifyIcon.classList.remove('hidden');
                    app.elements.themeText.textContent = 'Reputify Theme';
                } else {
                    docEl.classList.add('light');
                    app.elements.themeSunIcon.classList.remove('hidden');
                    app.elements.themeText.textContent = 'Light Theme';
                }
                const themeColor = getComputedStyle(document.documentElement).getPropertyValue('--bg-main').trim();
const themeMeta = document.getElementById('theme-color-meta');
if (themeMeta) {
    themeMeta.setAttribute('content', themeColor);
}
            }
            
            function renderSidebarState() {
                const pane = app.elements.notesListPane;
                const resizer = app.elements.paneResizer;
                const body = app.elements.body;
                const toggleBtn = app.elements.sidebarToggleBtn;

                if (state.settings.sidebarCollapsed) {
                    pane.classList.add('collapsed');
                    resizer.classList.add('hidden');
                    body.classList.add('sidebar-collapsed');
                    toggleBtn.style.left = '0px';
                } else {
                    pane.classList.remove('collapsed');
                    pane.style.width = `${state.settings.paneWidth}px`;
                    resizer.classList.remove('hidden');
                    body.classList.remove('sidebar-collapsed');
                    toggleBtn.style.left = `${state.settings.paneWidth}px`;
                }
            }

            function renderCollectionsList(collections = state.collections, level = 0) {
    const createItemHTML = (item, currentLevel) => {
        const isActive = item.id === state.settings.activeCollectionId;
        const isNoteActive = item.id === state.settings.activeNoteId;
        const isFolder = item.type === 'folder';

        if (isFolder && item.children) {
            item.children.sort((a, b) => {
                if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
                return a.name.localeCompare(b.name);
            });
        }

        return `
            <li data-id="${item.id}" draggable="true" class="collection-item-wrapper rounded-md">
                <a href="#" class="collection-item flex items-center gap-2 p-2 rounded-md hover:bg-bg-pane-dark ${isActive || isNoteActive ? 'bg-bg-pane-dark font-semibold' : ''}" style="padding-left: ${8 + currentLevel * 16}px;">
                    ${isFolder ? `<i data-feather="chevron-right" class="chevron w-4 h-4 flex-shrink-0 text-text-tertiary ${item.expanded ? 'open' : ''}"></i>` : ''}
                    <i data-feather="${isFolder ? 'folder' : (item.pinned ? 'paperclip' : 'file-text')}" class="w-4 h-4 flex-shrink-0 text-text-secondary ${item.pinned ? 'text-accent-primary': ''}"></i>
                    <span class="truncate flex-grow">${item.name}</span>
                </a>
                ${isFolder && item.expanded && item.children ? `<ul class="collection-children">${renderCollectionsList(item.children, currentLevel + 1)}</ul>` : ''}
            </li>
        `;
    };

    collections.sort((a, b) => {
        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
        return a.name.localeCompare(b.name);
    });
    const listHTML = collections.map(item => createItemHTML(item, level)).join('');

    if (level === 0) {
        app.containers.collectionsList.innerHTML = `<ul class="space-y-1">${listHTML}</ul>`;
        // This is the key fix. It ensures icons are re-rendered every time the main list is updated.
        feather.replace();
    }
    return listHTML;
}
            
            function renderTagList() {
    const allNotes = getAllNotes(state.collections);
    // Get a flat list of all tags, including duplicates.
    const allTagsRaw = allNotes.flatMap(note => note.tags || []);

    if (allTagsRaw.length === 0) {
        app.containers.tagList.innerHTML = `<p class="px-2 text-xs text-text-tertiary">No tags found.</p>`;
        return;
    }

    // Create a frequency map to count how many times each tag is used.
    const tagCounts = allTagsRaw.reduce((acc, tag) => {
        acc[tag] = (acc[tag] || 0) + 1;
        return acc;
    }, {});

    // Get the unique tags and sort them alphabetically.
    const uniqueTags = [...new Set(allTagsRaw)].sort();

    // Update the HTML to include the count in a styled badge.
    app.containers.tagList.innerHTML = uniqueTags.map(tag => {
        const count = tagCounts[tag];
        return `
            <a href="#" class="tag-filter-item flex justify-between items-center text-sm p-1 px-2 rounded-md text-text-secondary hover:bg-bg-pane-dark hover:text-text-primary ${state.settings.activeTag === tag ? 'active' : ''}" data-tag="${tag}">
                <span>#${tag}</span>
                <span class="text-xs bg-bg-pane-dark rounded-full px-1.5 py-0.5 ml-2">${count}</span>
            </a>
        `
    }).join('');
}

            

            function updateNoteTags(note) {
                if (!note || typeof note.content !== 'string') return;
                const plainText = note.content.replace(/<[^>]*>?/gm, '');
                const matches = plainText.match(/#(\w+)/g) || [];
                note.tags = [...new Set(matches.map(tag => tag.substring(1)))];
            }

            function updateNoteLinks(note) {
                if (!note || typeof note.content !== 'string') return;
                const plainText = note.content.replace(/<[^>]*>?/gm, '');
                const matches = plainText.matchAll(/\[\[(.*?)\]\]/g);
                note.links = [...matches].map(match => match[1].trim());
            }

            function renderMainView() {
                document.querySelectorAll('.notes-view').forEach(v => v.classList.add('hidden'));

                if (isSearchActive) {
                    renderSearchResults(app.search.input.value);
                    return;
                }
                
                const isNoteActive = !!state.settings.activeNoteId;
                const isTagActive = !!state.settings.activeTag;
                const activeCollection = findItem(state.settings.activeCollectionId)?.item;

                if (isTagActive) {
                    app.elements.currentViewTitle.textContent = `Tag: #${state.settings.activeTag}`;
                } else {
                    app.elements.currentViewTitle.textContent = activeCollection?.name || "All Notes";
                }
                
                const showListControls = !isNoteActive && (state.settings.activeView === 'list' || !activeCollection || isTagActive);

                app.elements.viewSwitcher.style.display = isNoteActive || !activeCollection || isTagActive ? 'none' : 'flex';
                app.elements.listViewControls.style.display = showListControls ? 'flex' : 'none';
                

                if (isNoteActive) {
                    renderNoteEditor();
                } else if (isTagActive) {
                    renderListView();
                } else if (activeCollection) {
                     document.querySelectorAll('#view-switcher-container .view-btn').forEach(b => b.classList.remove('active'));
                     document.querySelector(`#view-switcher-container .view-btn[data-view="${state.settings.activeView}"]`)?.classList.add('active');
                    
                    if (state.settings.activeView === 'board') {
                        renderKanbanView();
                    } else {
                        renderListView();
                    }
                } else {
                     renderListView();
                }
            }
            
            function renderMobileControls() {
    const activeCollection = findItem(state.settings.activeCollectionId)?.item;
    const note = findItem(state.settings.activeNoteId)?.item;
    const isNoteActive = !!note;

    let controlsHTML = '';
    
    if (isNoteActive) {
        // This block now contains BOTH AI Tools and Note Tools
        const pinText = note.pinned ? 'Unpin Note' : 'Pin Note';
        controlsHTML = `
            <div class="text-xs text-text-tertiary px-3 pt-2 pb-1 font-semibold uppercase">AI Tools</div>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-summarize">
                <i data-feather="zap" class="w-4 h-4"></i>AI Summary
            </button>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-quiz">
                <i data-feather="help-circle" class="w-4 h-4"></i>MCQ Quiz
            </button>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-flashcard">
    <i data-feather="copy" class="w-4 h-4"></i>Flashcards
</button>

            <hr class="my-1 border-border-color">

            <div class="text-xs text-text-tertiary px-3 pt-2 pb-1 font-semibold uppercase">Note Tools</div>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-new-note">
    <i data-feather="file-plus" class="w-4 h-4"></i>New Note
</button>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-rename">
                <i data-feather="edit-2" class="w-4 h-4"></i>Rename
            </button>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-duplicate">
                <i data-feather="copy" class="w-4 h-4"></i>Duplicate
            </button>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-share">
    <i data-feather="share-2" class="w-4 h-4"></i>Share Note
</button>

<button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-upload">
    <i data-feather="upload-cloud" class="w-4 h-4"></i>Upload File
</button>
<button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-add-checklist">
    <i data-feather="check-square" class="w-4 h-4"></i>Add Checklist
</button>
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-pin">
                <i data-feather="paperclip" class="w-4 h-4"></i>${pinText}
            </button>
            <hr class="my-1 border-border-color">
            <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2 text-red-500" data-action="mobile-delete">
                <i data-feather="trash-2" class="w-4 h-4"></i>Delete
            </button>
        `;
    }  else if (activeCollection) {
    controlsHTML += `
        <div class="text-xs text-text-tertiary px-3 pt-2 pb-1 font-semibold uppercase">Actions</div>
        <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-new-note">
            <i data-feather="file-plus" class="w-4 h-4"></i>New Note
        </button>
        <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2" data-action="mobile-rename-folder">
    <i data-feather="edit-2" class="w-4 h-4"></i>Rename Folder
</button>
        <hr class="my-1 border-border-color">
        <div class="text-xs text-text-tertiary px-3 pt-2 pb-1 font-semibold uppercase">View</div>
        <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2 view-btn-mobile" data-view="board"><i data-feather="trello" class="w-4 h-4"></i>Board</button>
        <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2 view-btn-mobile" data-view="list"><i data-feather="list" class="w-4 h-4"></i>List</button>
    `; 
//...
        if (state.settings.activeView === 'list') {
            controlsHTML += `<hr class="my-1 border-border-color">
                <div class="text-xs text-text-tertiary px-3 pt-2 pb-1 font-semibold uppercase">Sort By</div>
                <select id="sort-order-mobile" class="w-full bg-transparent text-text-primary text-sm rounded-md p-2 border-0 focus:ring-0">
                    <option value="modifiedAt-desc">Last Modified</option>
                    <option value="createdAt-desc">Date Created</option>
                    <option value="name-asc">Title (A-Z)</option>
                </select>
            `;
        }controlsHTML += `
        <hr class="my-1 border-border-color">
        <button class="w-full text-left px-3 py-1.5 text-sm hover:bg-bg-pane-dark rounded flex items-center gap-2 text-red-500" data-action="mobile-delete-folder">
            <i data-feather="trash-2" class="w-4 h-4"></i>Delete Folder
        </button>
    `;
    } else {
        controlsHTML = `<div class="px-3 py-2 text-sm text-text-secondary">No options available</div>`;
    }

    app.containers.mobileControlsDropdown.innerHTML = controlsHTML;

    const mobileSortSelect = document.getElementById('sort-order-mobile');
    if (mobileSortSelect) {
        mobileSortSelect.value = state.settings.listSortOrder;
        mobileSortSelect.addEventListener('change', (e) => {
            state.settings.listSortOrder = e.target.value;
            app.elements.sortOrderSelect.value = e.target.value;
            saveState();
            renderListView();
        });
    }

    document.querySelectorAll('.view-btn-mobile').forEach(btn => {
        if (btn.dataset.view === state.settings.activeView) {
            btn.classList.add('bg-bg-pane-dark', 'font-semibold');
        }
    });
    feather.replace();
}
            function renderKanbanView() {
                app.views.board.classList.remove('hidden');
                const collectionId = state.settings.activeCollectionId;
                const collection = findItem(collectionId)?.item;

                if (!collection || collection.type !== 'folder') {
                    app.containers.kanbanBoard.innerHTML = `<div class="text-center p-10 text-text-secondary"><i data-feather="trello" class="w-12 h-12 mx-auto mb-4"></i><h3 class="font-semibold">Board View</h3><p>This view is only available for project folders.</p></div>`;
                    feather.replace();
                    return;
                }
                
                const columns = state.kanbanColumns[collectionId] || [];
                const notesInCollection = collection.children.filter(c => c.type === 'note') || [];
                
                const columnsHTML = columns.map(column => {
                    const notesInColumn = [...notesInCollection]
                        .filter(note => note.status === column.id)
                        .sort((a,b) => notesInCollection.indexOf(a) - notesInCollection.indexOf(b));
                        
                    const cardsHTML = notesInColumn.map(note => {
                            const date = formatDateTime(note.modifiedAt);
                            const pinnedClass = note.pinned ? 'pinned' : '';
                            return `
                                <div class="kanban-card p-3 rounded-md shadow-sm border border-border-color mb-3 cursor-pointer hover:shadow-lg transition-all ${pinnedClass}" draggable="true" data-note-id="${note.id}">
                                    <div class="pointer-events-none flex-grow overflow-hidden">
                                        <h4 class="font-semibold pointer-events-none truncate">${note.name}</h4>
                                        <p class="text-sm text-text-secondary mt-1 pointer-events-none truncate-multiline card-content">${note.content.replace(/<[^>]*>?/gm, '')}</p>
                                    </div>
                                    <div class="text-xs text-text-tertiary mt-2 pointer-events-none flex-shrink-0">Modified: ${date}</div>
                                </div>
                            `;
                        }).join('');

                    return `
                        <div class="kanban-column w-[280px] md:w-[300px] flex-shrink-0 bg-bg-pane-dark p-3 rounded-lg" data-column-id="${column.id}">
                            <div class="column-header flex justify-between items-center font-semibold mb-3 text-text-primary">
                                <span class="rename-column-btn cursor-pointer flex-grow p-1">${column.title}</span>
                                <button class="delete-column-btn text-text-tertiary hover:text-red-500 opacity-0 transition-opacity p-1"><i data-feather="x" class="w-4 h-4"></i></button>
                            </div>
                            <div class="cards-container min-h-[100px]">${cardsHTML}</div>
                        </div>
                    `;
                }).join('');
                
                const addColumnBtnHTML = columns.length < 5 ? `
                     <div class="w-[280px] md:w-[300px] flex-shrink-0">
                        <button id="add-column-btn" class="w-full bg-bg-pane-light p-3 rounded-lg text-text-secondary hover:bg-main hover:text-accent-primary transition-colors">
                            <i data-feather="plus" class="inline-block mr-2"></i>Add Column
                        </button>
                    </div>` : '';

                app.containers.kanbanBoard.innerHTML = columnsHTML + addColumnBtnHTML;
            }

            function renderListView() {
                 app.views.list.classList.remove('hidden');
                 let notes = [];
                 const activeTag = state.settings.activeTag;
                 
                 if (activeTag) {
                     notes = getAllNotes(state.collections).filter(note => (note.tags || []).includes(activeTag));
                 } else {
                     const collectionId = state.settings.activeCollectionId;
                     const collection = findItem(collectionId)?.item;
                     notes = collection 
                        ? (collection.children || []).filter(c => c.type === 'note') 
                        : getAllNotes(state.collections);
                 }


                 if (notes.length === 0) {
                     app.containers.notesListContent.innerHTML = `<div class="text-center p-10 text-text-secondary"><i data-feather="inbox" class="w-12 h-12 mx-auto mb-4"></i><h3 class="font-semibold">No Notes Here</h3><p>Create a new note to get started.</p></div>`;
                     feather.replace();
                     return;
                 }
                 
                 const sortOrder = state.settings.listSortOrder;
                 const [key, direction] = sortOrder.split('-');

                 notes.sort((a,b) => {
                     let valA = a[key];
                     let valB = b[key];
                     if(key === 'name') {
                         return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                     } else {
                         return direction === 'desc' ? new Date(valB) - new Date(valA) : new Date(valA) - new Date(valB);
                     }
                 });

                 app.containers.notesListContent.innerHTML = notes.map(note => {
                    const date = formatDateTime(note.modifiedAt);
                    const pinnedClass = note.pinned ? 'pinned' : '';
                    return `
    <div class="list-note-item bg-bg-pane-light p-4 rounded-lg shadow-sm border border-border-color cursor-pointer hover:shadow-md transition-all relative ${pinnedClass}" data-note-id="${note.id}">
        <div class="flex justify-between items-start">
            <div class="flex-grow min-w-0">
                <h3 class="font-semibold text-lg truncate">${note.name}</h3>

                <p class="text-sm text-text-secondary mt-1 truncate-multiline card-content">${note.content.replace(/<[^>]*>?/gm, '')}</p>

                <p class="text-xs text-text-tertiary mt-3">Last Modified: ${date}</p>
            </div>

            <div class="flex items-center flex-shrink-0 ml-4">
                <button class="summarize-btn p-2 rounded-full hover:bg-bg-pane-dark text-text-secondary" title="Summarize Note with AI" data-note-id="${note.id}">
                    <i data-feather="zap" class="w-4 h-4"></i>
                </button>
                <button class="quiz-btn p-2 rounded-full hover:bg-bg-pane-dark text-text-secondary" title="Generate Quiz with AI" data-note-id="${note.id}">
                    <i data-feather="help-circle" class="w-4 h-4"></i>
                </button>
            </div>
        </div>
    </div>`
                 }).join('');
            }
            
            function updateEditorStats() {
                const text = app.elements.noteEditorBody.innerText || '';
                const charCount = text.length;
                const wordCount = text.trim().split(/\s+/).filter(Boolean).length;
                app.elements.charCount.textContent = charCount;
                app.elements.wordCount.textContent = wordCount;
            }
            function createAttachmentWidgetHTML(data) {
    if (data.isImage) {
        return `<p><img src="${data.downloadURL}" alt="${data.fileName}" style="max-width: 100%; height: auto; border-radius: 8px;" contenteditable="false" /></p>`;
    } else {
        return `<div class="file-attachment-widget" contenteditable="false">
                    <i data-feather="file-text" class="w-6 h-6 text-text-secondary flex-shrink-0"></i>
                    <div class="file-info">
                        <div class="file-name">${data.fileName}</div>
                        <div class="file-size">${formatBytes(data.fileSize)}</div>
                    </div>
                    <a href="${data.downloadURL}" target="_blank" class="brand-button p-2" download title="Download ${data.fileName}"><i data-feather="download" class="w-5 h-5"></i></a>
                </div>`;
    }
}
            function renderNoteEditor() {
    app.containers.noteEditor.classList.remove('hidden');
    const note = findItem(state.settings.activeNoteId)?.item;
    const highlightControls = document.getElementById('highlight-controls');
    const editorBody = app.elements.noteEditorBody;

    if (!note) {
        app.elements.noteEditorBody.querySelectorAll('.checklist-container').forEach(updateChecklistProgress);
        state.settings.activeNoteId = null;
        if (highlightControls) highlightControls.classList.add('hidden');
        renderMainView();
        return;
    }

    const highlightQuery = state.settings.searchHighlightQuery;

    app.elements.noteEditorTitle.value = note.name;
    app.elements.noteEditorTitle.style.height = 'auto';
    app.elements.noteEditorTitle.style.height = (app.elements.noteEditorTitle.scrollHeight) + 'px';

    let contentToRender = note.content || '';

    if (state.settings.editorMode === 'preview') {
        editorBody.classList.add('hidden');
        app.elements.markdownPreview.classList.remove('hidden');
        let html = marked.parse(contentToRender);
        html = parseInternalLinks(html);
        app.elements.markdownPreview.innerHTML = html;
        app.toolbar.editorModeToggle.classList.add('active');
    } else {
        editorBody.classList.remove('hidden');
        app.elements.markdownPreview.classList.add('hidden');
        editorBody.innerHTML = contentToRender;
        app.toolbar.editorModeToggle.classList.remove('active');
    }

    if (highlightQuery && state.settings.editorMode === 'editor') {
        const regex = new RegExp(`(${highlightQuery.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')})`, 'gi');

        const walker = document.createTreeWalker(editorBody, NodeFilter.SHOW_TEXT, null, false);
        let node;
        const nodesToReplace = [];
        while (node = walker.nextNode()) {
            if (node.parentElement.tagName !== 'SCRIPT' && node.parentElement.tagName !== 'STYLE' && regex.test(node.textContent)) {
                nodesToReplace.push(node);
            }
        }

        nodesToReplace.forEach(node => {
            const newHtml = node.textContent.replace(regex, `<mark>$1</mark>`);
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = newHtml;
            const parent = node.parentNode;
            while(tempDiv.firstChild) {
                parent.insertBefore(tempDiv.firstChild, node);
            }
            parent.removeChild(node);
        });

        const firstHighlight = editorBody.querySelector('mark');
        if (firstHighlight) {
            highlightControls.classList.remove('hidden');

            const clearBtn = document.getElementById('clear-search-btn');
            clearBtn.replaceWith(clearBtn.cloneNode(true));
            document.getElementById('clear-search-btn').addEventListener('click', closeAndClearSearch);
            app.elements.noteEditorBody.addEventListener('mousedown', closeAndClearSearch, { once: true });

            document.getElementById('in-note-search-input').value = highlightQuery;
            performInNoteSearch();

            // ROBUST SCROLL LOGIC
            setTimeout(() => {
                const mainContentArea = document.getElementById('main-content-area');
                const mainRect = mainContentArea.getBoundingClientRect();
                const highlightRect = firstHighlight.getBoundingClientRect();

                const barHeight = highlightControls.offsetHeight;
                const desiredPadding = 20; 

                const targetScrollTop = mainContentArea.scrollTop + (highlightRect.top - mainRect.top) - barHeight - desiredPadding;

                mainContentArea.scrollTo({
                    top: Math.max(0, targetScrollTop),
                    behavior: 'smooth'
                });
            }, 100);
        }
        state.settings.searchHighlightQuery = null;
    } else {
        highlightControls.classList.add('hidden');
    }
    

    // --- START: New Backlinks Logic ---
const backlinksPane = document.getElementById('backlinks-pane');
const backlinksList = document.getElementById('backlinks-list');
const summarizeBtn = document.getElementById('summarize-backlinks-btn');
const toggleBtn = document.getElementById('toggle-backlinks-btn');

const allNotes = getAllNotes(state.collections);
const backlinks = allNotes.filter(n =>
    n.id !== note.id && (n.links || []).some(link => link.toLowerCase() === note.name.toLowerCase())
);

if (backlinks.length > 0) {
    backlinksList.innerHTML = backlinks.map(b => {
        const parentResult = findItem(b.id);
        const parent = parentResult ? parentResult.parent : null;
        const parentName = parent && !Array.isArray(parent) ? parent.name : 'Uncategorized';
        
        const plainContent = b.content.replace(/<[^>]*>?/gm, '').trim();
        const excerpt = plainContent.substring(0, 120) + (plainContent.length > 120 ? '...' : '');
        const lastModified = formatDateTime(b.modifiedAt);

        return `
            <a href="#" class="backlink-item block p-3 rounded-lg" data-note-id="${b.id}">
                <div class="font-semibold text-text-primary">${b.name} <span class="text-text-tertiary font-normal">| ${parentName}</span></div>
                <p class="text-sm text-text-secondary mt-1">${excerpt || 'No content preview'}</p>
                <p class="text-xs text-text-tertiary mt-2">Modified: ${lastModified}</p>
            </a>`;
    }).join('');

    summarizeBtn.onclick = () => handleBacklinksSummary(note, backlinks);
    toggleBtn.onclick = () => {
        state.settings.backlinksCollapsed = !state.settings.backlinksCollapsed;
        saveState();
        renderBacklinksState();
    };

    backlinksPane.classList.remove('hidden');
    renderBacklinksState(); // Render initial state
} else {
    backlinksPane.classList.add('hidden');
}
// --- END: New Backlinks Logic ---

    updateEditorStats();
    feather.replace();
}
function renderBacklinksState() {
    const isCollapsed = state.settings.backlinksCollapsed;
    const list = document.getElementById('backlinks-list');
    const btn = document.getElementById('toggle-backlinks-btn');
    if (list && btn) {
        list.classList.toggle('collapsed', isCollapsed);
        btn.classList.toggle('collapsed', isCollapsed);
    }
}

const handleBacklinksSummary = async (currentNote, backlinkingNotes) => {
    // --- 1. Caching Logic ---
    const cacheKey = backlinkingNotes.map(n => n.id + n.modifiedAt).join('');
    if (currentNote.cachedBacklinksSummary && currentNote.cachedBacklinksSummary.key === cacheKey) {
        app.modals.summaryContent.innerHTML = currentNote.cachedBacklinksSummary.summary;
        openModal(app.modals.summary);
        document.getElementById('summary-copy-btn').classList.remove('hidden');
        feather.replace();
        showToast('Loaded summary from cache.', 'info');
        return;
    }

    // --- 2. AI Call Logic ---
    const toastId = showToast('Summarizing linked notes...', 'loading');
    const combinedContent = backlinkingNotes.map(n => `Note: ${n.name}\nContent: ${n.content.replace(/<[^>]*>?/gm, '')}`).join('\n\n---\n\n');
    const prompt = `Based on the following notes that all link to "${currentNote.name}", provide a concise summary of their collective content. Synthesize the information into a cohesive overview.

Combined Content:
---
${combinedContent}`;

    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    const summaryText = await callGeminiAPI(payload);
    dismissToast(toastId);

    if (summaryText) {
        const summaryHtml = marked.parse(summaryText).trim();
        app.modals.summaryContent.innerHTML = summaryHtml;
        openModal(app.modals.summary);
        feather.replace();

        // --- 3. Save to Cache ---
        currentNote.cachedBacklinksSummary = {
            key: cacheKey,
            summary: summaryHtml
        };
        saveState();
    } else {
        showToast('Could not generate summary.', 'error');
    }
};
            
            function renderSearchResults(query) {
                app.views.searchResults.classList.remove('hidden');

                if (!query) {
                    app.containers.searchResultsList.innerHTML = `<p class="text-text-secondary text-center"><i data-feather="search" class="w-12 h-12 mx-auto mb-4"></i><br>Start typing to search for notes.</p>`;
                    feather.replace();
                    return;
                }

                const results = lunrIndex.search(query);
                const resultNotes = results.map(res => findItem(res.ref)?.item).filter(Boolean);

                if(resultNotes.length === 0) {
                     app.containers.searchResultsList.innerHTML = `<p class="text-text-secondary text-center"><i data-feather="x-circle" class="w-12 h-12 mx-auto mb-4"></i><br>No results found for "${query}".</p>`;
                     feather.replace();
                     return;
                }

                const highlightText = (text, query) => {
                    if (!query || !text) return text;
                    // Escape special characters for the regex
                    const escapedQuery = query.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    const regex = new RegExp(`(${escapedQuery})`, 'gi');
                    // Escape HTML characters before returning
                    return text.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(regex, `<mark>$1</mark>`);
                };

                app.containers.searchResultsList.innerHTML = resultNotes.map(note => {
                    const parentResult = findItem(note.id);
                    const parent = parentResult ? parentResult.parent : null;
                    const parentName = parent && !Array.isArray(parent) ? parent.name : null;
                    const plainContent = note.content.replace(/<[^>]*>?/gm, '');
                    
                    // This is the new, more robust excerpt logic. It shows the beginning of the note.
                    const excerpt = highlightText(plainContent, query);

                    return `
                        <div class="search-result-item p-4 mb-3 rounded-lg hover:shadow-md border border-border-color bg-bg-pane-light transition-shadow cursor-pointer" data-note-id="${note.id}">
                            <div class="flex justify-between items-start">
                                <div class="flex-grow min-w-0">
                                    <div class="font-semibold text-text-secondary text-sm">
                                        ${parentName ? `${highlightText(parentName, query)} / ` : ''}<span class="text-text-primary">${highlightText(note.name, query)}</span>
                                    </div>
                                    
                                    <p class="text-text-secondary mt-2 truncate-multiline card-content" style="-webkit-line-clamp: 2;">${excerpt}</p>
                                </div>
                                <div class="flex items-center flex-shrink-0 ml-4">
                                    <button class="summarize-btn p-2 rounded-full hover:bg-bg-pane-dark text-text-secondary" title="Summarize Note with AI" data-note-id="${note.id}">
                                        <i data-feather="zap" class="w-4 h-4"></i>
                                    </button>
                                    <button class="quiz-btn p-2 rounded-full hover:bg-bg-pane-dark text-text-secondary" title="Generate Quiz with AI" data-note-id="${note.id}">
                                        <i data-feather="help-circle" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                feather.replace();
            }
            
            function renderChatHistory() {
                app.modals.chatbotHistory.innerHTML = state.chatHistory.map(msg => {
                    const bubbleClass = msg.role === 'user'
                        ? 'user'
                        : 'model';
                    const formattedHtml = marked.parse(msg.text);
                    return `
                        <div class="chat-bubble w-fit rounded-lg px-3 py-2 self-${msg.role === 'user' ? 'end' : 'start'} ${bubbleClass}">
                            ${formattedHtml}
                        </div>`;
                }).join('');
                app.modals.chatbotHistory.scrollTop = app.modals.chatbotHistory.scrollHeight;
            }
            // ADD THIS NEW HELPER FUNCTION
// REPLACE THE OLD 'upgradePastedTables' FUNCTION
// REPLACE 'upgradePastedTables' FUNCTION
const upgradePastedTables = (html) => {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    const tables = tempDiv.querySelectorAll('table');
    if (tables.length === 0) return html;

    tables.forEach(table => {
        table.querySelectorAll('th, td').forEach(cell => cell.setAttribute('contenteditable', 'true'));
        const headers = table.querySelectorAll('th');
        const headerRow = table.querySelector('thead tr');
        const colCount = headerRow ? headerRow.children.length : 1;

        headers.forEach(th => {
            th.classList.add('sortable-header');
            th.dataset.sortDir = 'none';
        });

        const thead = table.querySelector('thead');
        if (thead) {
            const filterRow = document.createElement('tr');
            // This is the updated filter row HTML with the toggle button
            filterRow.innerHTML = `<th colspan="${colCount}" contenteditable="false"><div class="table-header-controls"><div class="table-filter-wrapper"><i data-feather="search" class="filter-icon"></i><input class="table-filter-input" placeholder="Filter table..."/></div><button class="toggle-filter-btn" title="Toggle Filter"><i data-feather="chevrons-up" class="w-4 h-4"></i></button></div></th>`;
            thead.prepend(filterRow);
        }
    });
    return tempDiv.innerHTML;
};            
            const createNewNote = (andSwitchToIt = true, initialContent = '') => {
                let parentCollection;
                let targetArray;
                let parentId = state.settings.activeCollectionId;

                const parentResult = findItem(parentId);

                if (parentResult && parentResult.item.type === 'folder') {
                    parentCollection = parentResult.item;
                    targetArray = parentCollection.children;
                } else if(parentResult) {
                    const parentOfNoteResult = findItem(parentResult.parent.id);
                    parentId = parentOfNoteResult ? parentOfNoteResult.item.id : null;
                    parentCollection = parentOfNoteResult ? parentOfNoteResult.item : null;
                    targetArray = parentCollection ? parentCollection.children : state.collections;
                } else {
                    parentId = null;
                    targetArray = state.collections;
                }
                
                if (parentCollection) {
                    parentCollection.expanded = true;
                }

                const now = new Date().toISOString();
                const newNote = {
                    id: generateId('n'), name: 'Untitled Note', type: 'note', content: initialContent,
                    status: parentId ? state.kanbanColumns[parentId]?.[0]?.id || null : null,
                    createdAt: now,
                    modifiedAt: now,
                    pinned: false,
                    links: [],
                    tags: []
                };

                if (initialContent) {
                   updateNoteLinks(newNote);
                   updateNoteTags(newNote);
                   const titleMatch = initialContent.match(/<h1>(.*?)<\/h1>/);
                   if (titleMatch && titleMatch[1]) {
                       newNote.name = titleMatch[1];
                   } else {
                       // Try to find title from markdown
                       const mdTitleMatch = initialContent.match(/^# (.*)/m);
                       if(mdTitleMatch && mdTitleMatch[1]) {
                           newNote.name = mdTitleMatch[1];
                       }
                   }
                }
                
                targetArray.unshift(newNote);
                
                if(andSwitchToIt) {
                    state.settings.activeNoteId = newNote.id;
                    state.settings.activeTag = null;
                    // Switch to editor mode when creating a new note
                    state.settings.editorMode = 'editor';
                }
                
                saveState();
                buildLunrIndex();
                render();
                app.elements.noteEditorTitle.focus();
    app.elements.noteEditorTitle.select();
                return newNote;
            };

            function initSpeechRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    showToast('Speech recognition is not supported in this browser.', 'error');
                    return;
                }
                
                speechRecognizer = new SpeechRecognition();
                speechRecognizer.continuous = true;
                speechRecognizer.interimResults = false;

                speechRecognizer.onresult = (event) => {
                    const last = event.results.length - 1;
                    const text = event.results[last][0].transcript;
                    
                    app.elements.noteEditorBody.focus();
                    document.execCommand('insertText', false, text.trim() + ' ');
                    saveNoteContent();
                };

                speechRecognizer.onend = () => {
                    if (isDictating) {
                        speechRecognizer.start(); // Keep listening if it stops unexpectedly
                    }
                };
                 speechRecognizer.onerror = (event) => {
                    console.error('Speech recognition error', event.error);
                    showToast(`Speech recognition error: ${event.error}`, 'error');
                    isDictating = false;
                    app.toolbar.dictateBtn.classList.remove('recording');
                };
            }

            function initClipper() {
                if (!window.location.hash.startsWith('#clip=')) return;

                try {
                    const encodedData = window.location.hash.substring(6);
                    const data = JSON.parse(decodeURIComponent(encodedData));
                    
                    let clippedContent = `<h1>${data.title}</h1>\n<p><em>Source: <a href="${data.url}" target="_blank">${data.url}</a></em></p>\n<hr>\n<blockquote>${data.clip.replace(/\n/g, '<br>')}</blockquote>`;

                    const newNote = createNewNote(true, clippedContent);
                    showToast(`Clipped content saved to "${newNote.name}"`, 'success');

                } catch (e) {
                    console.error('Error parsing clipped data:', e);
                    showToast('Could not import clipped content.', 'error');
                } finally {
                    // Clear the hash
                    history.pushState("", document.title, window.location.pathname + window.location.search);
                }
            }
            
            function buildLunrIndex() {
                const allNotes = getAllNotes(state.collections);
                lunrIndex = lunr(function () {
                    this.ref('id');
                    this.field('name');
                    this.field('content');
                    this.field('tags');
                    
                    allNotes.forEach(note => {
                        this.add({
                            id: note.id,
                            name: note.name,
                            content: note.content.replace(/<[^>]*>?/gm, ''), // Index plain text
                            tags: note.tags ? note.tags.join(' ') : ''
                        });
                    });
                });
            }
            /**
 * Renders the generated quiz data into the quiz modal.
 * @param {Array<Object>} quizArray - An array of quiz question objects.
 */
function renderQuizModal(quizArray) {
    let quizHTML = '<div class="space-y-6">';
    quizArray.forEach((q, index) => {
        const isMultiSelect = q.type === 'msq';
        // The correct answer is now stringified to be stored in the data attribute
        const correctAnswer = JSON.stringify(q.answer); 

        quizHTML += `
            <div class="quiz-question-container border-b border-border-color pb-4" data-correct-answer='${correctAnswer}' data-question-type="${q.type || 'mcq'}">
                <p class="font-semibold text-text-primary">${index + 1}. ${q.question} ${isMultiSelect ? '<span class="text-xs font-normal text-text-tertiary">(Select all that apply)</span>' : ''}</p>
                <div class="mt-3 space-y-2">
                    ${Object.entries(q.options).map(([key, value]) => `
                        <label class="block flex items-start p-2 rounded-md border border-border-color cursor-pointer hover:bg-bg-pane-dark transition-colors duration-200">
                            <input type="${isMultiSelect ? 'checkbox' : 'radio'}" name="question-${index}" value="${key}" class="mr-3 mt-1 shrink-0">
                            <span>${key}: ${value}</span>
                        </label>
                    `).join('')}
                </div>
                ${isMultiSelect ? `<button class="submit-msq-btn mt-3 px-3 py-1 text-sm brand-button rounded-md">Submit Answer</button>` : ''}
                <p class="quiz-feedback text-sm mt-2 h-5 font-medium"></p>
            </div>
        `;
    });
    quizHTML += '</div>';

    app.modals.quizContent.innerHTML = quizHTML;
    openModal(app.modals.quiz);
}

/**
 * Handles the AI call to generate an MCQ quiz from note content.
 * @param {string} noteContent - The plain text content of the note.
 */
const handleGenerateQuiz = async (noteContent, note) => {
    // Check for a valid cached quiz first.
    if (note.cachedQuiz && note.cachedQuiz.sourceModifiedAt === note.modifiedAt) {
        showToast('Loading Quiz!', 'info');
        renderQuizModal(note.cachedQuiz.data);
        return;
    }

    // NEW: Determine quiz length based on content
    const contentLength = noteContent.length;
    let numQuestions = 3;
    if (contentLength > 1000) numQuestions = 5;
    if (contentLength > 2500) numQuestions = 7;

    const toastId = showToast(`Generating quiz...`, 'loading');
    
    // NEW: Enhanced prompt for smarter, varied, and multi-select questions
    const prompt = `Based on the following text, generate a multiple-choice quiz with exactly ${numQuestions} questions.

Instructions for the AI:
1.  Create a mix of question types: some for simple fact recall, and others that test understanding of concepts, consequences, or relationships between ideas in the text.
2.  For some questions, allow for multiple correct answers (multi-select).
3.  Return the result as a single, valid JSON object with a key "quiz" which is an array of objects.
4.  Each question object MUST have four keys:
    - "question" (string): The question text.
    - "options" (object): An object with A, B, C, D keys for the options.
    - "answer" (string OR array of strings): For single-answer questions, this is a string (e.g., "A"). For multi-select questions, this is an array of strings (e.g., ["B", "D"]).
    - "type" (string): Use "mcq" for single-answer questions and "msq" for multi-select questions.
5.  Do not include any text, notes, or markdown formatting like \`\`\`json before or after the JSON object itself.

Text:
---
${noteContent}`;

    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    const jsonResponse = await callGeminiAPI(payload);
    dismissToast(toastId);

    if (jsonResponse) {
        try {
            const cleanedJsonResponse = jsonResponse.replace(/^```json\n?/, '').replace(/\n?```$/, '');
            const quizData = JSON.parse(cleanedJsonResponse);

            if (quizData.quiz && Array.isArray(quizData.quiz)) {
                 renderQuizModal(quizData.quiz);
                 note.cachedQuiz = {
                     sourceModifiedAt: note.modifiedAt,
                     data: quizData.quiz
                 };
                 saveState();
            } else {
                throw new Error("Invalid quiz data structure.");
            }
        } catch (err) {
            console.error("Failed to parse quiz JSON:", err, "Raw Response:", jsonResponse);
            showToast('Failed to generate a valid quiz.', 'error');
        }
    }
};

            async function init() {
                // --- START: SLASH COMMAND CONSOLE ---
                // --- START: SLASH COMMAND CONSOLE ---

// --- START: SLASH COMMAND CONSOLE ---

// --- START: SLASH COMMAND CONSOLE ---

// --- START: SLASH COMMAND CONSOLE ---

const createContentSnippet = (content, query) => {
    const plainText = content.replace(/<[^>]*>?/gm, ' ').replace(/\s+/g, ' ');
    const lowerQuery = query.toLowerCase();
    const queryIndex = plainText.toLowerCase().indexOf(lowerQuery);
    if (queryIndex === -1) return null;
    const start = Math.max(0, queryIndex - 20);
    const end = Math.min(plainText.length, queryIndex + query.length + 40);
    let snippet = plainText.substring(start, end);
    const regex = new RegExp(`(${query.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')})`, 'gi');
    snippet = snippet.replace(regex, '<b class="text-accent-primary">$1</b>');
    return `...${snippet}...`;
};

const findBestMatch = (query, items) => {
    if (!query || !items || items.length === 0) return null;
    
    // These options tell Fuse.js to search by the 'name' key and to be lenient with typos.
    const fuseOptions = {
        keys: ['name'],
        includeScore: true,
        threshold: 0.4 
    };

    const fuse = new Fuse(items, fuseOptions);
    const results = fuse.search(query);
    
    // Return the best match (the first item in the results)
    return results.length > 0 ? results[0].item : null;
};

const getAllTags = () => {
    const allNotes = getAllNotes(state.collections);
    const allTagsRaw = allNotes.flatMap(note => note.tags || []);
    return [...new Set(allTagsRaw)];
};

const commandPromptContainer = document.getElementById('command-prompt-container');
const commandInput = document.getElementById('command-input');
const commandSuggestionsContainer = document.getElementById('command-suggestions');
let isCommandPromptOpen = false;
let suggestionIndex = -1;

const renderHelpModal = () => {
    const helpContent = document.getElementById('help-content');
    helpContent.innerHTML = commands.sort((a,b) => a.name.localeCompare(b.name)).map(cmd => `
        <div class="help-command-row p-2 rounded-md hover:bg-bg-pane-dark">
            <code class="font-semibold text-text-primary bg-bg-pane-dark px-2 py-1 rounded-md whitespace-nowrap">/${cmd.name}</code>
            <p class="text-sm text-text-secondary">${cmd.description}</p>
        </div>
    `).join('');
    openModal(document.getElementById('help-modal'));
    feather.replace();
};

const renderLinkedNotesModal = (note) => {
    const modalTitle = document.getElementById('linked-notes-title');
    const modalContent = document.getElementById('linked-notes-content');
    modalTitle.innerHTML = `<i data-feather="link" class="w-5 h-5 text-accent-primary"></i> Connections for "${note.name}"`;
    
    const allNotes = getAllNotes(state.collections);
    const outgoingLinks = (note.links || []).map(linkName => allNotes.find(n => n.name === linkName)).filter(Boolean);
    const incomingLinks = allNotes.filter(n => n.id !== note.id && (n.links || []).some(linkName => linkName === note.name));

    const createNoteHTML = (n) => {
        const findResult = findItem(n.id);
        const parentName = (findResult && findResult.parent && !Array.isArray(findResult.parent)) ? findResult.parent.name : 'Uncategorized';

        return `
            <li class="border-2 border-border-color rounded-lg hover:bg-bg-pane-dark transition-colors duration-150">
                <a href="#" class="linked-note-jump block p-3" data-note-id="${n.id}">
                    <div class="flex items-center gap-3">
                        <i data-feather="file-text" class="w-5 h-5 text-text-secondary flex-shrink-0"></i>
                        <div class="min-w-0">
                            <div class="font-semibold text-text-primary truncate">${n.name}</div>
                            <div class="text-sm text-text-secondary truncate">${parentName}</div>
                        </div>
                    </div>
                </a>
            </li>`;
    };

    let contentHTML = '';
    if (outgoingLinks.length > 0) {
        contentHTML += `<div><h4 class="font-semibold text-text-primary mb-2">Links from this note:</h4><ul class="space-y-2">` + outgoingLinks.map(createNoteHTML).join('') + `</ul></div>`;
    }
    if (incomingLinks.length > 0) {
        contentHTML += `<div><h4 class="font-semibold text-text-primary mb-2">Linked here (Backlinks):</h4><ul class="space-y-2">` + incomingLinks.map(createNoteHTML).join('') + `</ul></div>`;
    }
    if (!contentHTML) {
        contentHTML = `<p class="text-text-secondary">No connections found for this note.</p>`;
    }

    modalContent.innerHTML = contentHTML;
    openModal(document.getElementById('linked-notes-modal'));
    feather.replace();
};

const executeWithSmartFind = async (args, itemType, action) => {
    let allItems, targetItem = null;
    if (itemType === 'notes') allItems = getAllNotes(state.collections);
    else if (itemType === 'folders') allItems = getAllFolders();
    else allItems = [...getAllNotes(state.collections), ...getAllFolders()];
    if (args) {
        targetItem = findBestMatch(args, allItems);
        if (!targetItem && itemType !== 'folders') {
            const contentResults = lunrIndex.search(args);
            if (contentResults.length > 0) {
                const item = findItem(contentResults[0].ref)?.item;
                if (item && item.type === 'note' && (itemType === 'notes' || itemType === 'items')) targetItem = item;
            }
        }
    }
    if (!targetItem) {
        if (itemType === 'notes' && state.settings.activeNoteId) targetItem = findItem(state.settings.activeNoteId)?.item;
        else if (itemType === 'folders' && state.settings.activeCollectionId) {
            const res = findItem(state.settings.activeCollectionId);
            if (res?.item.type === 'folder') targetItem = res.item;
        } else if (itemType === 'items') {
             const activeId = state.settings.activeNoteId || state.settings.activeCollectionId;
             if (activeId) targetItem = findItem(activeId)?.item;
        }
    }
    if (!targetItem) {
        const typeName = itemType.slice(0, -1);
        return showToast(`âŒ ${typeName.charAt(0).toUpperCase() + typeName.slice(1)} not found.`, 'error');
    }
    action(targetItem);
};

const commands = [
    { name: 'nn', description: 'New Note. Usage: /nn [note name]', execute: (args)=>{const n=createNewNote(true,'');n.name=args||'Untitled Note';saveState();render();showToast(`âœ… Note "${n.name}" created`)} },
    { name: 'nf', description: 'New Folder. Usage: /nf [folder name]', execute: (args)=>{const n=args||'Untitled Folder';const c={id:generateId('c'),name:n,type:'folder',children:[],expanded:true};state.kanbanColumns[c.id]=[{id:generateId('col'),title:'To Do'}];state.collections.push(c);saveState();buildLunrIndex();render();showToast(`âœ… Folder "${n}" created`)}},
    { name: 'rename', description: 'Rename item. Usage: /rename [old] to [new]', suggest: 'items', execute: async(args)=>{const s=/\s+to\s+/i;if(!s.test(args))return showToast('âŒ Use: /rename [old] to [new]','error');const p=args.split(s);const o=p[0].trim();const n=p[1].trim();if(!o||!n)return showToast('âŒ Both names required.','error');const i=findBestMatch(o,[...getAllNotes(state.collections),...getAllFolders()]);if(!i)return showToast(`âŒ Not found: "${o}"`,'error');const c=await showConfirm({title:'Confirm Rename',message:`Rename "${i.name}" to "${n}"?`,confirmText:'Rename'});if(c){i.name=n;saveState();buildLunrIndex();render();showToast(`âœ… Renamed to "${n}"`)}} },
    { name: 'link', description: 'Link notes. Usage: /link [source] to [target]', suggest: 'notes', execute: (args)=>{const s=/\s+to\s+/i;if(!s.test(args))return showToast('âŒ Use: /link [source] to [target]','error');const p=args.split(s);const sN=p[0].trim();const tN=p[1].trim();if(!sN||!tN)return showToast('âŒ Both notes required.','error');const aN=getAllNotes(state.collections);const sO=findBestMatch(sN,aN);const tO=findBestMatch(tN,aN);if(!sO)return showToast(`âŒ Source not found: "${sN}"`,'error');if(!tO)return showToast(`âŒ Target not found: "${tN}"`,'error');if(sO.id===tO.id)return showToast('âŒ Cannot link a note to itself.','error');sO.content+=`\n<p>[[${tO.name}]]</p>`;updateNoteLinks(sO);sO.modifiedAt=new Date().toISOString();saveState();if(state.settings.activeNoteId===sO.id)renderNoteEditor();showToast(`âœ… Linked "${sO.name}" to "${tO.name}"`)}},
    { name: 'unlink', description: 'Unlink notes. Usage: /unlink [target] from [source]', suggest: 'notes', execute: (args)=>{const s=/\s+from\s+/i;if(!s.test(args))return showToast('âŒ Use: /unlink [target] from [source]','error');const p=args.split(s);const tN=p[0].trim();const sN=p[1].trim();if(!sN||!tN)return showToast('âŒ Both notes required.','error');const aN=getAllNotes(state.collections);const sO=findBestMatch(sN,aN);const tO=findBestMatch(tN,aN);if(!sO)return showToast(`âŒ Source not found: "${sN}"`,'error');if(!tO)return showToast(`âŒ Target not found: "${tN}"`,'error');const r=new RegExp(`\\[\\[\\s*${tO.name}\\s*\\]\\]`,'gi');if(!r.test(sO.content))return showToast(`âŒ Link to "${tO.name}" not found in "${sO.name}".`,'info');sO.content=sO.content.replace(r,'').replace(/<p>\s*<\/p>|\n\s*\n/gi,'');updateNoteLinks(sO);sO.modifiedAt=new Date().toISOString();saveState();if(state.settings.activeNoteId===sO.id)renderNoteEditor();showToast(`âœ… Unlinked "${tO.name}" from "${sO.name}"`)}},
    { name: 'go', description: 'Go to item or tag. Usage: /go [item] or /go #[tag] [item]', suggest: 'items_or_tags', execute: (args)=>{if(!args)return showToast('âŒ Specify item or tag.','error');if(args.startsWith('#')){const tN=args.split(' ')[0].substring(1).trim();const nN=args.substring(tN.length+2).trim();if(!tN)return showToast('âŒ Tag name needed.','error');if(!getAllTags().includes(tN))return showToast(`âŒ Tag not found: #${tN}`,'error');if(nN){const nT=getAllNotes(state.collections).filter(n=>(n.tags||[]).includes(tN));const t=findBestMatch(nN,nT);if(t){executeWithSmartFind(t.name,'notes',(i)=>{state.settings.activeTag=null;if(i.type==='note'){const{parent}=findItem(i.id);state.settings.activeCollectionId=(Array.isArray(parent)||!parent)?null:parent.id;state.settings.activeNoteId=i.id}showToast(`ðŸš€ Navigated to "${i.name}"`);saveState();render()})}else{showToast(`âŒ Note "${nN}" not in tag #${tN}.`,'error')}}else{state.settings.activeTag=tN;state.settings.activeNoteId=null;state.settings.activeCollectionId=null;showToast(`ðŸ·ï¸ Showing notes tagged with #${tN}`);saveState();render()}}else{executeWithSmartFind(args,'items',(i)=>{state.settings.activeTag=null;if(i.type==='note'){const{parent}=findItem(i.id);state.settings.activeCollectionId=(Array.isArray(parent)||!parent)?null:parent.id;state.settings.activeNoteId=i.id}else{state.settings.activeCollectionId=i.id;state.settings.activeNoteId=null}showToast(`ðŸš€ Navigated to "${i.name}"`);saveState();render()})}} },
    { name: 'theme', description: 'Toggle through color themes.', execute: ()=>document.getElementById('theme-toggle')?.click() },
    { name: 'voice', description: 'Start/stop voice dictation in current note.', execute: ()=>{if(!state.settings.activeNoteId)return showToast('âŒ Must be in a note.','error');document.getElementById('dictate-btn')?.click()} },
    { name: 'linked', description: 'Show all connections for a note. Usage: /linked [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args, 'notes', (note)=>renderLinkedNotesModal(note)) },
    { name: 'help', description: 'Shows this list of all available commands.', execute: renderHelpModal },
    { name: 'commands', description: 'Alias for /help.', execute: renderHelpModal },
    { name: 'ask', description: 'Ask Your Notes AI. Usage: /ask [question]', execute: (args)=>{if(!args)return showToast('âŒ Question needed.','error');openModal(document.getElementById('global-ai-modal'));document.getElementById('global-ai-input').value=args;document.getElementById('global-ai-ask-btn').click();feather.replace()} },
    { name: 'summary', description: 'Summarize a note. Usage: /summary [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args,'notes',(n)=>{const c=(n.content||'').replace(/<[^>]*>?/gm,'').trim();if(!c)return showToast('Note empty.','info');handleSummarize(c)})},
    { name: 'quiz', description: 'Generate quiz. Usage: /quiz [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args,'notes',(n)=>{const c=(n.content||'').replace(/<[^>]*>?/gm,'').trim();if(!c)return showToast('Note empty.','info');handleGenerateQuiz(c,n)})},
    { name: 'flashcard', description: 'Open flashcards. Usage: /flashcard [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args,'notes',(n)=>handleFlashcardMode(n))},
    { name: 'share', description: 'Create share link. Usage: /share [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args,'notes',(n)=>handleShareNote(n))},
    {
        name: 'checkpoint',
        description: 'Save a manual version of the current note. Usage: /checkpoint [message]',
        execute: (args) => {
            const noteId = state.settings.activeNoteId;
            if (!noteId) {
                return showToast('âŒ You must be in a note to save a checkpoint.', 'error');
            }
            if (!args) {
                return showToast('âŒ A message is required for the checkpoint.', 'error');
            }
            performImmediateSave();
            const { item: note } = findItem(noteId);
            if (note) {
                saveNoteVersion(note.id, note.content, args);
                saveState();
                showToast(`âœ… Checkpoint saved: "${args}"`, 'success');
            }
        }
    },
    {
        name: 'history',
        description: 'Open version history for a note. Usage: /history [note name]',
        suggest: 'notes',
        execute: (args) => {
            executeWithSmartFind(args, 'notes', (note) => {
                state.settings.activeNoteId = note.id;
                openVersionHistoryModal();
            });
        }
    },
    { name: 'dup', description: 'Duplicate an item. Usage: /dup [item name]', suggest: 'items', execute: (args)=>executeWithSmartFind(args,'items',(i)=>{const r=findItem(i.id);const nI=duplicateItem(i);const pA=Array.isArray(r.parent)?r.parent:r.parent.children;pA.splice(r.index+1,0,nI);showToast(`âœ… Duplicated "${i.name}"`);saveState();buildLunrIndex();render()})},
    { name: 'pin', description: 'Toggle pin on a note. Usage: /pin [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args,'notes',(n)=>{n.pinned=!n.pinned;showToast(n.pinned?`ðŸ“Œ Pinned "${n.name}"`:`ðŸ‘Ž Unpinned "${n.name}"`);saveState();render()})},
    { name: 'tag', description: 'Add a tag to current note. Usage: /tag [tagname]', execute: (args)=>{if(!state.settings.activeNoteId)return showToast('âŒ Must be in a note.','error');if(!args)return showToast('âŒ Tag name needed.','error');const tN=args.split(' ')[0].replace(/#/g,'');if(!tN)return;app.elements.noteEditorBody.innerHTML+=` #${tN}`;performImmediateSave();showToast(`ðŸ·ï¸ Tagged with #${tN}`)}},
    {
        name: 'clear',
        description: 'Clear all content from a note. Usage: /clear [note name]',
        suggest: 'notes',
        execute: (args) => executeWithSmartFind(args, 'notes', async (note) => {
            const confirmed = await showConfirm({
                title: `Clear Content of "${note.name}"`,
                message: 'This will permanently delete all content inside this note. This action cannot be undone.',
                confirmText: 'Clear Content',
                confirmClass: 'bg-red-600'
            });

            if (confirmed) {
                note.content = '';
                note.modifiedAt = new Date().toISOString();
                updateNoteLinks(note);
                updateNoteTags(note);
                
                saveState();
                buildLunrIndex();
                render();
                
                showToast(`âœ… Content cleared from "${note.name}"`, 'success');
            }
        })
    },{
    name: 'notegraph',
    description: 'Show note graph. Usage: /notegraph [note name]',
    suggest: 'notes',
    execute: (args) => {
        executeWithSmartFind(args, 'notes', (note) => {
            // This reuses the same logic as the toolbar button
            const graphBtn = document.getElementById('graph-btn');
            if (graphBtn) {
                // Temporarily set the active note to the one we want to graph
                const originalActiveNote = state.settings.activeNoteId;
                state.settings.activeNoteId = note.id;
                graphBtn.click();
                // Restore the original active note so the UI doesn't jump
                state.settings.activeNoteId = originalActiveNote;
            }
        });
    }
},{
    name: 'checklist',
    description: 'Adds a new interactive checklist to the current note.',
    execute: () => {
    if (!state.settings.activeNoteId) {
        return showToast('âŒ You must be in a note to add a checklist.', 'error');
    }

    restoreSelectionAndExec(() => {
        const newDefaultChecklistHTML = `
<div class="checklist-container" contenteditable="false">
    <div class="checklist-header">
        <h4 class="checklist-title font-semibold text-text-primary flex-grow">Untitled Checklist</h4>
        <button class="checklist-header-btn" data-action="edit" title="Edit Checklist"><i data-feather="edit" class="w-4 h-4"></i></button>
        <button class="checklist-header-btn delete" data-action="delete" title="Delete Checklist"><i data-feather="trash-2" class="w-4 h-4"></i></button>
    </div>
    <div class="checklist-progress-container">
        <div class="checklist-progress-bar">
            <div class="checklist-progress-fill" style="width: 0%;"></div>
        </div>
        <span class="checklist-progress-text">0% Complete</span>
    </div>
    <ul class="checklist-body">
        <li class="checklist-item" data-checked="false"><input type="checkbox" class="checklist-item-checkbox" onclick="return false;"><span class="checklist-item-text" contenteditable="false">New item</span></li>
    </ul>
</div>
<p><br></p>
`;
        // THE FIX: Use the 'newDefaultChecklistHTML' variable defined above.
        document.execCommand('insertHTML', false, newDefaultChecklistHTML);
        feather.replace();
    });
    showToast('âœ… Checklist added.');
}
},// ... inside the 'commands' array
{
    name: 'move',
    description: 'Move a note to a folder. Usage: /move [note] to [folder]',
    suggest: 'items', // This will suggest both notes and folders
    execute: (args) => {
        const separator = /\s+to\s+/i;
        if (!separator.test(args)) {
            return showToast('âŒ Invalid format. Use: /move [note name] to [folder name]', 'error');
        }

        const [noteName, folderName] = args.split(separator).map(s => s.trim());

        if (!noteName || !folderName) {
            return showToast('âŒ Both a note and folder name are required.', 'error');
        }

        const allNotes = getAllNotes(state.collections);
        const allFolders = getAllFolders();

        const noteToMove = findBestMatch(noteName, allNotes);
        const targetFolder = findBestMatch(folderName, allFolders);

        if (!noteToMove) {
            return showToast(`âŒ Note not found: "${noteName}"`, 'error');
        }
        if (!targetFolder) {
            return showToast(`âŒ Target folder not found: "${folderName}"`, 'error');
        }

        // Find the note in the state tree to remove it from its current location
        const sourceResult = findItem(noteToMove.id);
        if (!sourceResult) return; // Should not happen, but a good safeguard

        const sourceArray = Array.isArray(sourceResult.parent) ? sourceResult.parent : sourceResult.parent.children;
        
        // Check if the note is already in the target folder
        if (sourceResult.parent && sourceResult.parent.id === targetFolder.id) {
            return showToast(`Note is already in "${targetFolder.name}".`, 'info');
        }

        // Remove the note from its original array
        const [movedNote] = sourceArray.splice(sourceResult.index, 1);

        // Add the note to the target folder's children array
        if (!targetFolder.children) {
            targetFolder.children = [];
        }
        targetFolder.children.unshift(movedNote);

        // Update the note's Kanban status to the first column of the new folder
        movedNote.status = state.kanbanColumns[targetFolder.id]?.[0]?.id || null;
        movedNote.modifiedAt = new Date().toISOString();

        // Save changes and update the UI
        saveState();
        buildLunrIndex();
        render();
        showToast(`âœ… Moved "${movedNote.name}" to "${targetFolder.name}"`, 'success');
    }
},{
    name: 'table',
    description: 'Create a table. Usage: /table [rows]x[cols]. Defaults to 3x2.',
    execute: (args) => {
        if (!state.settings.activeNoteId) {
            return showToast('âŒ You must be in a note to create a table.', 'error');
        }

        let rows = 3;
        let cols = 2;

        if (args) {
            const match = args.match(/(\d+)\s*x\s*(\d+)/i);
            if (match) {
                rows = parseInt(match[1], 10) || 3;
                cols = parseInt(match[2], 10) || 2;
            } else {
                 return showToast('âŒ Invalid format. Use [rows]x[cols], e.g., 4x3.', 'error');
            }
        }
        
        if (rows > 50 || cols > 20) {
            return showToast('âŒ Table size is too large (max 50x20).', 'error');
        }

        let tableHTML = '<table style="width:100%"><thead>';
tableHTML += `<tr><th colspan="${cols}" contenteditable="false"><div class="table-header-controls"><div class="table-filter-wrapper"><i data-feather="search" class="filter-icon"></i><input class="table-filter-input" placeholder="Filter table..."/></div><button class="toggle-filter-btn" title="Toggle Filter"><i data-feather="chevrons-up" class="w-4 h-4"></i></button></div></th></tr>`;
        tableHTML += '<tr>';
        for (let i = 0; i < cols; i++) {
            tableHTML += `<th class="sortable-header" data-sort-dir="none" contenteditable="true">Header ${i + 1}</th>`;
        }
        tableHTML += '</tr></thead><tbody>';
        for (let i = 0; i < rows; i++) {
            tableHTML += '<tr>';
            for (let j = 0; j < cols; j++) {
                tableHTML += '<td contenteditable="true"><br></td>';
            }
            tableHTML += '</tr>';
        }
        tableHTML += '</tbody></table><p><br></p>';

        restoreSelectionAndExec(() => document.execCommand('insertHTML', false, tableHTML));
        feather.replace();
        showToast(`âœ… Table (${rows}x${cols}) created.`);
    }
},{
    name: 'recalculate',
    description: 'Usage: /recalculate [column name] or /recalculate for all.',
    suggest: 'none',
    execute: (args) => {
        const columnName = args ? args.trim() : null;

        const activeNoteId = state.settings.activeNoteId;
        if (!activeNoteId) {
            return showToast('âŒ You must be in a note to use this command.', 'error');
        }

        const editorBody = app.elements.noteEditorBody;
        const table = editorBody.querySelector('table');

        if (!table) {
            return showToast('âŒ No table found in the current note.', 'error');
        }

        // If a column name is provided, recalculate that specific column
        if (columnName) {
            const headers = Array.from(table.querySelectorAll('thead tr:last-child th'));
            let targetHeader = null;
            let targetColIndex = -1;

            for (let i = 0; i < headers.length; i++) {
                if (headers[i].innerText.trim().toLowerCase() === columnName.toLowerCase()) {
                    targetHeader = headers[i];
                    targetColIndex = i;
                    break;
                }
            }

            if (!targetHeader) {
                return showToast(`âŒ Column "${columnName}" not found in the table.`, 'error');
            }

            const formula = targetHeader.dataset.formula;
            if (!formula) {
                return showToast(`âŒ No custom formula is set for the "${columnName}" column.`, 'info');
            }

            performCustomFormula(table, targetColIndex, formula);
            showToast(`âœ… Recalculated column "${columnName}".`, 'success');

        } else {
            // If no column name, recalculate all columns with a formula
            const headersWithFormulas = Array.from(table.querySelectorAll('thead tr:last-child th[data-formula]'));
            
            if (headersWithFormulas.length === 0) {
                return showToast('No columns with formulas found in this table.', 'info');
            }

            const allHeaders = Array.from(table.querySelectorAll('thead tr:last-child th'));

            headersWithFormulas.forEach(header => {
                const formula = header.dataset.formula;
                if (formula) {
                    const colIndex = allHeaders.indexOf(header);
                    if (colIndex > -1) {
                        performCustomFormula(table, colIndex, formula);
                    }
                }
            });

            showToast(`âœ… Recalculated all ${headersWithFormulas.length} formula column(s).`, 'success');
        }
    }
},{
    name: 'recalc',
    description: 'Alias for /recalculate. Updates all table calculations.',
    execute: (args) => {
        // This just finds and runs the main /recalculate command's logic
        commands.find(c => c.name === 'recalculate').execute(args);
    }
},
{
    name: 'rc',
    description: 'Alias for /recalculate. Updates all table calculations.',
    execute: (args) => {
        // This also finds and runs the main /recalculate command's logic
        commands.find(c => c.name === 'recalculate').execute(args);
    }
},
// ... rest of the commands
    { name: 'dn', description: 'Delete a note. Usage: /dn [note name]', suggest: 'notes', execute: (args)=>executeWithSmartFind(args,'notes',async (n)=>{const r=findItem(n.id);const c=await showConfirm({title:`Delete "${n.name}"?`,message:'This cannot be undone.',confirmText:'Delete'});if(c){const pA=Array.isArray(r.parent)?r.parent:r.parent.children;pA.splice(r.index,1);showToast(`ðŸ—‘ï¸ Note deleted.`);if(state.settings.activeNoteId===n.id)state.settings.activeNoteId=null;saveState();buildLunrIndex();render()}})},
    { name: 'df', description: 'Delete folder. Usage: /df [folder name]', suggest: 'folders', execute: (args)=>executeWithSmartFind(args,'folders',async (f)=>{const r=findItem(f.id);const c=await showConfirm({title:`Delete folder "${f.name}"?`,message:'This will delete the folder and <strong>all notes inside</strong>.',confirmText:'Delete'});if(c){const pA=Array.isArray(r.parent)?r.parent:r.parent.children;pA.splice(r.index,1);showToast(`ðŸ—‘ï¸ Folder deleted.`);if(state.settings.activeCollectionId===f.id)state.settings.activeCollectionId=null;saveState();buildLunrIndex();render()}})}
];

const openCommandPrompt = () => { if(isCommandPromptOpen)return;isCommandPromptOpen=true;commandPromptContainer.classList.remove('hidden');commandInput.value='/';renderSuggestions('/');commandInput.focus();setTimeout(()=>commandInput.setSelectionRange(commandInput.value.length,commandInput.value.length),0) };
const closeCommandPrompt = () => { if(!isCommandPromptOpen)return;isCommandPromptOpen=false;commandPromptContainer.classList.add('hidden');commandSuggestionsContainer.classList.add('hidden');suggestionIndex=-1 };

const renderSuggestions = (rawInput) => {
    const input = rawInput.startsWith('/') ? rawInput.slice(1) : rawInput;
    const parts = input.split(' ');
    const commandName = parts[0];
    const argString = parts.slice(1).join(' ');
        const command = commands.find(c => c.name.toLowerCase() === commandName.toLowerCase());


    let suggestionsHTML = '';
    const argQuery = argString.toLowerCase();

    if (command && command.suggest) {
        let finalSuggestions = [];
        const toSeparator = /\s+to\s+/i;
        const fromSeparator = /\s+from\s+/i;
        if ((command.name === 'move' || command.name === 'rename' || command.name === 'link') && toSeparator.test(argString)) {
        const targetQuery = argString.split(toSeparator)[1].toLowerCase() || '';
        let itemsToSuggest = [];

        if (command.name === 'move') {
            // For /move, ONLY suggest folders as the destination
            itemsToSuggest = getAllFolders();
        } else { // for /rename and /link
            itemsToSuggest = (command.suggest === 'notes') ? getAllNotes(state.collections) : [...getAllNotes(state.collections), ...getAllFolders()];
        }
        
        const fuse = new Fuse(itemsToSuggest, { keys: ['name'], threshold: 0.5 });
        finalSuggestions = fuse.search(targetQuery).map(result => result.item);
    } 
    // This block handles the SECOND argument for /unlink
    else if (command.name === 'unlink' && fromSeparator.test(argString)) {
        const sourceQuery = argString.split(fromSeparator)[1].toLowerCase() || '';
        const fuse = new Fuse(getAllNotes(state.collections), { keys: ['name'], threshold: 0.5 });
        finalSuggestions = fuse.search(sourceQuery).map(result => result.item);
    }
    // This block handles the FIRST argument for all other commands
    else if (parts.length > 1) {
        let itemsToSearch = [];
        if (command.suggest.includes('items')) {
            itemsToSearch = [...getAllNotes(state.collections), ...getAllFolders()];
        } else if (command.suggest.includes('notes')) {
            itemsToSearch = getAllNotes(state.collections);
        } else if (command.suggest.includes('folders')) {
            itemsToSearch = getAllFolders();
        } else if (command.name === 'go' && argString.startsWith('#')) {
            // Special handling for tag suggestions
            const tagQuery = argString.substring(1);
            itemsToSearch = getAllTags().map(t => ({ id: t, name: t, type: 'tag' }));
            const fuse = new Fuse(itemsToSearch, { keys: ['name'], threshold: 0.5 });
            finalSuggestions = fuse.search(tagQuery).map(result => result.item);
        }
        
        if (itemsToSearch.length > 0) {
            const fuse = new Fuse(itemsToSearch, { keys: ['name'], threshold: 0.5 });
            finalSuggestions = fuse.search(argQuery).map(result => result.item);
        }
    } // ... inside renderSuggestions function
 else if (parts.length > 1) {
    let itemsToSearch = [];
    if (command.suggest.includes('items')) {
        itemsToSearch = [...getAllNotes(state.collections), ...getAllFolders()];
    } else if (command.suggest.includes('notes')) {
        itemsToSearch = getAllNotes(state.collections);
    } else if (command.suggest.includes('folders')) {
        itemsToSearch = getAllFolders();
    }

    // Use Fuse to get a ranked list of fuzzy-matched items
    const fuse = new Fuse(itemsToSearch, { keys: ['name'], threshold: 0.5 });
    finalSuggestions = fuse.search(argQuery).map(result => result.item);
}

        if (finalSuggestions.length > 0) {
            suggestionsHTML = finalSuggestions.slice(0,5).map((item, index) => {
                const isTag = item.type === 'tag';
                const dataAttribute = isTag ? `data-tag-name="#${item.name}"` : `data-item-name="${item.name.replace(/"/g, '&quot;')}"`;
                const icon = isTag ? 'hash' : (item.matchType === 'content' ? 'search' : (item.type === 'folder' ? 'folder' : 'file-text'));
                return `
                <div class="command-suggestion-item ${index === suggestionIndex ? 'active' : ''}" ${dataAttribute}>
                    <div class="flex items-center gap-2 min-w-0"> <i data-feather="${icon}" class="w-4 h-4 text-text-secondary flex-shrink-0"></i> <span class="cmd-name truncate">${item.name}</span> </div>
                    ${item.matchType === 'content' ? `<span class="cmd-desc text-right truncate">${item.snippet || ''}</span>` : ''}
                </div>`;
            }).join('');
        } else if (argString) {
            suggestionsHTML = `<div class="p-2 text-sm text-text-tertiary">No items match "${argString}"</div>`;
        }

    } 
    else {
    // FIX 2: Filter commands case-insensitively
    const lowerCaseCommandName = commandName.toLowerCase();
    const filteredCommands = commands.filter(cmd => cmd.name.toLowerCase().startsWith(lowerCaseCommandName)).slice(0, 5);
    if (filteredCommands.length > 0) {
        suggestionsHTML = filteredCommands.map((cmd, index) => `
            <div class="command-suggestion-item ${index === suggestionIndex ? 'active' : ''}" data-command-name="${cmd.name}">
                <div class="flex items-center gap-3"><span class="cmd-name">/${cmd.name}</span></div>
                <span class="cmd-desc">${cmd.description}</span>
            </div>`).join('');
    }
}
    
    if (suggestionsHTML) {
        commandSuggestionsContainer.innerHTML = suggestionsHTML;
        commandSuggestionsContainer.classList.remove('hidden');
        feather.replace();
    } else {
        commandSuggestionsContainer.classList.add('hidden');
    }
    suggestionIndex = -1;
};

const executeCommand = (inputValue) => {
    const cleanInput = inputValue.slice(1).trim();
    if (!cleanInput) { closeCommandPrompt(); return; }
    const parts = cleanInput.split(' ');
    const commandName = parts[0];
    const args = parts.slice(1).join(' ');
    // This comparison is now case-insensitive
    const command = commands.find(c => c.name.toLowerCase() === commandName.toLowerCase());
    if (command) command.execute(args);
    else showToast(`âŒ Command not found: ${commandName}`, 'error');
    closeCommandPrompt();
};

document.addEventListener('keydown', (e) => {
    if ((e.metaKey || e.ctrlKey) && e.key === '/') { e.preventDefault(); isCommandPromptOpen ? closeCommandPrompt() : openCommandPrompt(); }
    if (!isCommandPromptOpen) return;
    if (e.key === 'Escape') { e.preventDefault(); closeCommandPrompt(); return; }

    const activeSuggestion = commandSuggestionsContainer.querySelector('.command-suggestion-item.active');
    
    const completeAndExecute = (suggestionEl) => {
        const commandParts = commandInput.value.slice(1).split(' ');
        const commandName = commandParts[0];
        const argString = commandParts.slice(1).join(' ');
        const itemName = suggestionEl.dataset.itemName;
        const tagName = suggestionEl.dataset.tagName;
        const commandSuggestion = suggestionEl.dataset.commandName;

        let finalCommand;
        if (commandSuggestion) {
            finalCommand = `/${commandSuggestion}`;
        } else if (tagName) {
            finalCommand = `/go ${tagName}`;
        } else if (itemName) {
            const toSeparator = /\s+to\s+/i;
            const fromSeparator = /\s+from\s+/i;
            if ((commandName === 'move' || commandName === 'link' || commandName === 'rename') && toSeparator.test(argString)) {
                finalCommand = `/${commandName} ${argString.split(toSeparator)[0]} to ${itemName}`;
            } else if (commandName === 'unlink' && fromSeparator.test(argString)) {
                finalCommand = `/${commandName} ${argString.split(fromSeparator)[0]} from ${itemName}`;
            } else if (commandName === 'go' && argString.startsWith('#')) {
                 const tagPart = argString.split(' ')[0];
                 finalCommand = `/go ${tagPart} ${itemName}`;
            }
            else {
                finalCommand = `/${commandName} ${itemName}`;
            }
        }
        executeCommand(finalCommand);
    };

    if (e.key === 'Enter') {
        e.preventDefault();
        if (activeSuggestion) {
            completeAndExecute(activeSuggestion);
        } else {
            executeCommand(commandInput.value);
        }
        return;
    }

    if (e.key === 'Tab') {
        e.preventDefault();
        const suggestionToUse = activeSuggestion || commandSuggestionsContainer.querySelector('.command-suggestion-item');
        if (suggestionToUse) {
            const commandName = commandInput.value.slice(1).split(' ')[0];
            const argString = commandInput.value.slice(1).substring(commandName.length).trim();
            const itemName = suggestionToUse.dataset.itemName;
            const tagName = suggestionToUse.dataset.tagName;
            const commandSuggestion = suggestionToUse.dataset.commandName;
            
            let completedValue = commandInput.value;
            if (commandSuggestion) {
                completedValue = `/${commandSuggestion} `;
            } else if (tagName) {
                completedValue = `/go ${tagName} `;
            } else if (itemName) {
                const toSeparator = /\s+to\s+/i;
                const fromSeparator = /\s+from\s+/i;
                 if ((commandName === 'move' || commandName === 'link' || commandName === 'rename') && toSeparator.test(argString)) {
                    completedValue = `/${commandName} ${argString.split(toSeparator)[0]} to ${itemName} `;
                } else if (commandName === 'unlink' && fromSeparator.test(argString)) {
                    completedValue = `/${commandName} ${argString.split(fromSeparator)[0]} from ${itemName} `;
                } else if (commandName === 'go' && argString.startsWith('#')) {
                    completedValue = `/go ${argString.split(' ')[0]} ${itemName} `;
                } else if (commandName === 'move' || commandName === 'link' || commandName === 'rename') {
                     completedValue = `/${commandName} ${itemName} to `;
                } else if (commandName === 'unlink') {
                     completedValue = `/${commandName} ${itemName} from `;
                } else {
                    completedValue = `/${commandName} ${itemName} `;
                }
            }
            commandInput.value = completedValue;
            renderSuggestions(completedValue);
            const end = commandInput.value.length;
            commandInput.setSelectionRange(end, end);
        }
        return;
    }

    if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        e.preventDefault();
        const suggestions = Array.from(commandSuggestionsContainer.querySelectorAll('.command-suggestion-item'));
        if (suggestions.length === 0) return;
        if(activeSuggestion) activeSuggestion.classList.remove('active');
        const direction = e.key === 'ArrowDown' ? 1 : -1;
        suggestionIndex = (suggestionIndex + direction + suggestions.length) % suggestions.length;
        suggestions[suggestionIndex].classList.add('active');
    }
});

commandInput.addEventListener('input', () => { if (!commandInput.value.startsWith('/')) commandInput.value = '/'; renderSuggestions(commandInput.value); });
commandSuggestionsContainer.addEventListener('click', (e) => { const item = e.target.closest('.command-suggestion-item'); if(item){ const cmdName=commandInput.value.slice(1).split(' ')[0]; const argStr=commandInput.value.slice(1).substring(cmdName.length).trim(); let finalCmd; if(item.dataset.itemName){ const toSep=/\s+to\s+/i; const fromSep=/\s+from\s+/i; if((cmdName==='move'||cmdName==='link'||cmdName==='rename')&&toSep.test(argStr)){finalCmd=`/${cmdName} ${argStr.split(toSep)[0]} to ${item.dataset.itemName}`}else if(cmdName==='unlink'&&fromSep.test(argStr)){finalCmd=`/${cmdName} ${argStr.split(fromSep)[0]} from ${item.dataset.itemName}`}else if(cmdName==='go'&&argStr.startsWith('#')){finalCmd=`/${cmdName} ${argStr.split(' ')[0]} ${item.dataset.itemName}`}else{finalCmd=`/${cmdName} ${item.dataset.itemName}`}}else if(item.dataset.tagName){finalCmd=`/go ${item.dataset.tagName}`}else{finalCmd=`/${item.dataset.commandName}`}executeCommand(finalCmd)} });
document.addEventListener('click', (e) => { if (isCommandPromptOpen && !commandPromptContainer.contains(e.target)) closeCommandPrompt(); });

document.getElementById('help-close-btn').addEventListener('click', () => closeModal(document.getElementById('help-modal')));
document.getElementById('linked-notes-close-btn').addEventListener('click', () => closeModal(document.getElementById('linked-notes-modal')));
document.getElementById('linked-notes-modal').addEventListener('click', (e) => {
    const link = e.target.closest('.linked-note-jump');
    if (link) {
        e.preventDefault();
        const noteId = link.dataset.noteId;
        const noteName = findItem(noteId)?.item.name;
        if(noteName) {
            closeModal(document.getElementById('linked-notes-modal'));
            executeCommand(`/go ${noteName}`);
        }
    }
});
// --- END: SLASH COMMAND CONSOLE ---

// --- END: SLASH COMMAND CONSOLE ---

// --- END: SLASH COMMAND CONSOLE ---
// --- END: SLASH COMMAND CONSOLE ---

// --- END: SLASH COMMAND CONSOLE ---

// --- END: SLASH COMMAND CONSOLE ---
                // --- Source Snippet Click Listener ---
document.getElementById('global-ai-modal').addEventListener('click', (e) => {
    const link = e.target.closest('.source-snippet-link');
    if (link) {
        e.preventDefault();
        const noteId = link.dataset.noteId;
        if (noteId) {
            // Logic to switch to the note
            state.settings.activeNoteId = noteId;
            const { parent } = findItem(noteId);
            state.settings.activeCollectionId = (Array.isArray(parent)) ? null : parent.id;
            state.settings.activeTag = null;
            saveState();
            render();
            // Close the modal
            closeModal(document.getElementById('global-ai-modal'));
        }
    }
});
                // --- Copy Button Listeners ---
// --- Copy Button Listeners ---
document.getElementById('summary-copy-btn').addEventListener('click', () => {
    const content = document.getElementById('summary-content').innerText;
    navigator.clipboard.writeText(content)
        .then(() => showToast('Summary copied!', 'success'))
        .catch(() => showToast('Failed to copy.', 'error'));
});

// This now uses the correct ID for the button in the "Ask Your Notes" modal footer
document.getElementById('global-ai-copy-btn-footer').addEventListener('click', () => {
    const content = document.getElementById('global-ai-answer').innerText;
    navigator.clipboard.writeText(content)
        .then(() => showToast('Answer copied!', 'success'))
        .catch(() => showToast('Failed to copy.', 'error'));
});
                // --- Global AI Q&A Listeners ---
const openGlobalAIModal = () => {
    // This now ONLY clears the input field, leaving the previous answer and sources visible.
    document.getElementById('global-ai-input').value = '';

    // It also resets the 'Ask' button so you can submit a new question.
    const askBtn = document.getElementById('global-ai-ask-btn');
    if (askBtn) {
        askBtn.disabled = false;
        askBtn.querySelector('span').textContent = 'Ask';
    }

    openModal(document.getElementById('global-ai-modal'));
    feather.replace();
};
document.getElementById('global-ai-btn').addEventListener('click', openGlobalAIModal); // Desktop button
document.getElementById('mobile-global-ai-btn').addEventListener('click', openGlobalAIModal); // Mobile button


document.getElementById('mobile-global-ai-btn').addEventListener('click', () => { // Mobile button
    document.getElementById('global-ai-input').value = '';
    document.getElementById('global-ai-answer-container').classList.add('hidden');
    openModal(document.getElementById('global-ai-modal'));
    feather.replace();
});

document.getElementById('global-ai-close-btn').addEventListener('click', () => {
    closeModal(document.getElementById('global-ai-modal'));
});

document.getElementById('global-ai-ask-btn').addEventListener('click', handleGlobalAIQuery);
                // --- Global AI Q&A Listeners ---
document.getElementById('global-ai-btn').addEventListener('click', () => {
    document.getElementById('global-ai-input').value = '';
    document.getElementById('global-ai-answer-container').classList.add('hidden');
    openModal(document.getElementById('global-ai-modal'));
    feather.replace();
});

document.getElementById('global-ai-close-btn').addEventListener('click', () => {
    closeModal(document.getElementById('global-ai-modal'));
});

document.getElementById('global-ai-ask-btn').addEventListener('click', handleGlobalAIQuery);
                if (hasInitialized) return;
hasInitialized = true;
                
                // Add this inside the init() function
// Located inside the init() function
document.getElementById('chatbot-toggle-btn').addEventListener('click', () => {
    // Invert the boolean value
    state.settings.chatbotVisible = !state.settings.chatbotVisible;
    // Save the new state
    saveState();
    // Re-render the entire UI with the new state
    render();
});
                // --- START: Inline Toolbar Scroll Logic ---
const toolbarButtons = document.getElementById('inline-toolbar-buttons');
const scrollLeftBtn = document.getElementById('toolbar-scroll-left');
const scrollRightBtn = document.getElementById('toolbar-scroll-right');

const handleToolbarScroll = () => {
    scrollLeftBtn.addEventListener('click', () => {
        toolbarButtons.scrollLeft -= 70;
    });
    scrollRightBtn.addEventListener('click', () => {
        toolbarButtons.scrollLeft += 70;
    });
};

if (window.innerWidth < 768) {
    handleToolbarScroll();
}
// --- END: Inline Toolbar Scroll Logic ---
                // Add these listeners for the new table modal
document.getElementById('table-cancel-btn').addEventListener('click', () => {
    closeModal(document.getElementById('table-creator-modal'));
});
// This is the corrected event listener for the create button
// REPLACE THE OLD 'table-create-btn' LISTENER WITH THIS
// REPLACE THE OLD 'table-create-btn' LISTENER
// REPLACE 'table-create-btn' LISTENER
document.getElementById('table-create-btn').addEventListener('click', () => {
    const rows = parseInt(document.getElementById('table-rows').value) || 3;
    const cols = parseInt(document.getElementById('table-cols').value) || 2;

    let tableHTML = '<table style="width:100%"><thead>';
    // Add Filter Row with Icon
    tableHTML += `<tr><th colspan="${cols}" contenteditable="false"><div class="table-filter-wrapper"><i data-feather="search" class="filter-icon"></i><input class="table-filter-input" placeholder="Filter table..."/></div></th></tr>`;
    // Add Header Row
    tableHTML += '<tr>';
    for (let i = 0; i < cols; i++) {
        tableHTML += `<th class="sortable-header" data-sort-dir="none" contenteditable="true">Header ${i + 1}</th>`;
    }
    tableHTML += '</tr></thead><tbody>';
    // Add Data Rows
    for (let i = 0; i < rows; i++) {
        tableHTML += '<tr>';
        for (let j = 0; j < cols; j++) {
            tableHTML += '<td contenteditable="true"></td>';
        }
        tableHTML += '</tr>';
    }
    tableHTML += '</tbody></table><p><br></p>';

    restoreSelectionAndExec(() => document.execCommand('insertHTML', false, tableHTML));
    closeModal(document.getElementById('table-creator-modal'));
    feather.replace(); // This is important to render the new icon
});
                setupInNoteSearchListeners();

                
                // --- Logic for File Attachments ---
const attachFileBtn = document.getElementById('attach-file-btn');
const fileUploadInput = document.getElementById('file-upload-input');
// --- Logic for Toolbar Toggle ---
                const toggleToolbarBtn = document.getElementById('toggle-toolbar-btn');
                const expandableButtons = document.getElementById('expandable-toolbar-buttons');
                const toggleIcon = document.getElementById('toolbar-toggle-icon');

                toggleToolbarBtn.addEventListener('click', () => {
                    // Check if the expandable section is currently hidden
                    const isCollapsed = expandableButtons.classList.contains('hidden');
                    const toggleIcon = document.getElementById('toolbar-toggle-icon'); // Ensure we have the icon element

                    if (isCollapsed) {
                        // If it's collapsed, we expand it
                        expandableButtons.classList.remove('hidden');
                        expandableButtons.classList.add('flex');
                        toggleIcon.setAttribute('data-feather', 'chevron-left');
                    } else {
                        // If it's expanded, we collapse it
                        expandableButtons.classList.add('hidden');
                        expandableButtons.classList.remove('flex');
                        // This is the key fix: set the icon back to chevron-right
                        toggleIcon.setAttribute('data-feather', 'chevron-right');
                    }

                    // Re-render the Feather icons to display the correct chevron
                    feather.replace();
                });
attachFileBtn.addEventListener('click', () => {
    fileUploadInput.click();
});
const titleTextarea = app.elements.noteEditorTitle;
                titleTextarea.addEventListener('input', () => {
                    titleTextarea.style.height = 'auto';
                    titleTextarea.style.height = (titleTextarea.scrollHeight) + 'px';
                });
// Add this new event listener for the Settings panel
                document.getElementById('toggle-settings-btn').addEventListener('click', () => {
                    const settingsContainer = document.getElementById('settings-list-container');
                    const settingsButton = document.getElementById('toggle-settings-btn');
                    settingsContainer.classList.toggle('collapsed');
                    settingsButton.classList.toggle('collapsed');
                    // You might want to save this state, similar to tagsCollapsed
                    // For now, it will reset on page load.
                    feather.replace();
                });
app.elements.toggleTagsBtn.addEventListener('click', () => {
    state.settings.tagsCollapsed = !state.settings.tagsCollapsed;
    saveState();
    renderTagsState();
    feather.replace(); // To ensure the icon animation is smooth
});
fileUploadInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        handleFileUpload(file);
    }
    // Reset the input so you can upload the same file again if needed
    e.target.value = '';
});
                document.getElementById('header-share-btn').addEventListener('click', handleShareNote);
                await loadState();
                buildLunrIndex();
                
                initSpeechRecognition();
                initClipper();
                

                // Logic for the new AI buttons in the main header
const headerSummarizeBtn = document.getElementById('header-summarize-btn');
const headerQuizBtn = document.getElementById('header-quiz-btn');

const handleHeaderAIAction = (action) => {
    const note = findItem(state.settings.activeNoteId)?.item;
    if (note) {
        // The share action does not depend on content, so we handle it first.
        if (action === 'share') {
            handleShareNote(note); // Pass the note object directly
            return; // Exit the function
        }

        // For all other AI actions, we check for content first.
        const plainContent = (note.content || '').replace(/<[^>]*>?/gm, '').trim();
        if (plainContent) {
            if (action === 'summarize') {
                handleSummarize(plainContent);
            } else if (action === 'quiz') {
                handleGenerateQuiz(plainContent, note);
            } else if (action === 'flashcard') {
                handleFlashcardMode(note);
            }
        } else {
            showToast("Note is empty.", "info");
        }
    }
};

headerSummarizeBtn.addEventListener('click', () => handleHeaderAIAction('summarize'));
headerQuizBtn.addEventListener('click', () => handleHeaderAIAction('quiz'));
headerQuizBtn.addEventListener('click', () => handleHeaderAIAction('quiz'));
document.getElementById('header-share-btn').addEventListener('click', handleShareNote);
document.getElementById('header-share-btn').addEventListener('click', () => handleHeaderAIAction('share'));
document.getElementById('header-flashcard-btn').addEventListener('click', () => handleHeaderAIAction('flashcard')); // ADD THIS
                
                const renderer = new marked.Renderer();
                renderer.code = function(code, language) {
                    const validLang = language && hljs.getLanguage(language) ? language : 'plaintext';
                    const highlightedCode = hljs.highlight(code, { language: validLang, ignoreIllegals: true }).value;
                    return `
                        <div class="code-block-wrapper">
                            <div class="code-block-header">
                                <span class="lang-name">${validLang}</span>
                                <div class="flex items-center gap-2">
                                    <!-- THIS IS THE NEW EXIT BUTTON -->
                                    <button class="exit-code-btn" title="Exit Code Block">
                                        <i data-feather="arrow-down-left" class="w-4 h-4"></i>
                                        <span>Exit</span>
                                    </button>
                                    <button class="copy-code-btn" title="Copy Code">
                                        <i data-feather="copy" class="w-4 h-4"></i>
                                        <span>Copy</span>
                                    </button>
                                    <button class="delete-block-btn" title="Delete Block">
                                        <i data-feather="trash-2" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            <pre><code class="hljs language-${validLang}">${highlightedCode}</code></pre>
                        </div>
                    `;
                };

                marked.setOptions({
                    renderer: renderer,
                    gfm: true,
                    breaks: true,
                });

                

                app.elements.sortOrderSelect.value = state.settings.listSortOrder;
                
                app.elements.themeToggle.addEventListener('click', () => {
                    // ADD THIS NEW EVENT LISTENER for the profile dropdown
                const profileButton = document.getElementById('profile-button');
                const profileDropdown = document.getElementById('profile-dropdown');
                const signOutLink = document.getElementById('sign-out-link');

                if (profileButton && profileDropdown) {
                    profileButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevents the document click from firing immediately
                        profileDropdown.classList.toggle('hidden');
                    });
                }
                
                if(signOutLink) {
                    signOutLink.addEventListener('click', async (e) => {
                        e.preventDefault();
                        try {
                            await signOut(window.auth);
                            console.log('User signed out successfully.');
                            // onAuthStateChanged will handle hiding the app and showing the login form.
                        } catch (error) {
                            console.error('Sign out error:', error);
                            showToast('Error signing out.', 'error');
                        }
                    });
                }

                // Hides dropdown if you click anywhere else
                document.addEventListener('click', (e) => {
                    if (profileButton && !profileButton.contains(e.target) && profileDropdown && !profileDropdown.classList.contains('hidden')) {
                        profileDropdown.classList.add('hidden');
                    }
                });
                    const themes = ['reputify', 'light', 'dark'];
                    const currentThemeIndex = themes.indexOf(state.settings.theme);
                    state.settings.theme = themes[(currentThemeIndex + 1) % themes.length];
                    localStorage.setItem('codex-notes-theme', state.settings.theme); 
                    saveState();
                    renderTheme();
                    feather.replace();
                });
                
                app.elements.sidebarToggleBtn.addEventListener('click', () => {
                    state.settings.sidebarCollapsed = !state.settings.sidebarCollapsed;
                    saveState();
                    renderSidebarState();
                });
                
                app.elements.paneResizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    document.body.style.cursor = 'col-resize';
                    const startX = e.clientX;
                    const startWidth = app.elements.notesListPane.offsetWidth;
                    const doDrag = (e) => {
                        let newWidth = startWidth + e.clientX - startX;
                        newWidth = Math.max(240, Math.min(newWidth, 500)); 
                        app.elements.notesListPane.style.width = `${newWidth}px`;
                        app.elements.sidebarToggleBtn.style.left = `${newWidth}px`;
                    };
                    const stopDrag = () => {
                        document.body.style.cursor = 'default';
                        state.settings.paneWidth = app.elements.notesListPane.offsetWidth;
                        saveState();
                        document.removeEventListener('mousemove', doDrag);
                        document.removeEventListener('mouseup', stopDrag);
                    };
                    document.addEventListener('mousemove', doDrag);
                    document.addEventListener('mouseup', stopDrag);
                });

                const toggleMobileSidebar = (open) => {
                    const overlay = app.elements.mobileSidebarOverlay;
                    if (open) {
                        app.elements.notesListPane.classList.add('open');
                        overlay.classList.remove('hidden');
                        overlay.style.pointerEvents = 'auto';
                        setTimeout(() => overlay.style.opacity = '1', 10);
                    } else {
                        app.elements.notesListPane.classList.remove('open');
                        overlay.style.opacity = '0';
                        setTimeout(() => {
                           overlay.classList.add('hidden');
                           overlay.style.pointerEvents = 'none';
                        }, 300);
                    }
                };
                
                app.elements.mobileMenuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleMobileSidebar(true);
                });
                
                app.elements.mobileSidebarOverlay.addEventListener('click', () => toggleMobileSidebar(false));
                app.elements.mobileMoreButton.addEventListener('click', (e) => {
    e.stopPropagation(); // This is crucial to prevent the menu from closing itself
    const dropdown = app.containers.mobileControlsDropdown;
    const isHidden = dropdown.classList.contains('hidden');
    if (isHidden) {
        // Show the dropdown with animation
        dropdown.classList.remove('hidden');
        setTimeout(() => {
             dropdown.classList.remove('scale-95', 'opacity-0');
        }, 10);
    } else {
        // Hide the dropdown with animation
        dropdown.classList.add('scale-95', 'opacity-0');
        setTimeout(() => dropdown.classList.add('hidden'), 100);
    }
});

                app.containers.collectionsList.addEventListener('click', (e) => {
                    const itemLink = e.target.closest('.collection-item');
                    if (!itemLink) return;
                    e.preventDefault();

                    const wrapper = itemLink.closest('.collection-item-wrapper');
                    const id = wrapper.dataset.id;
                    const { item } = findItem(id);
                    
                    state.settings.activeTag = null; // Deactivate tag filter

                   if (item.type === 'folder') {
    // Default to list view on mobile devices
    if (window.innerWidth < 768) {
        state.settings.activeView = 'list';
    }
    
    state.settings.activeCollectionId = id;
    state.settings.activeNoteId = null;
    item.expanded = !item.expanded;
} else if (item.type === 'note') {
                         state.settings.activeNoteId = id;
                         const result = findItem(id);
                         const parent = result.parent;
                         state.settings.activeCollectionId = (Array.isArray(parent)) ? null : parent.id;
                         if (window.innerWidth < 768) {
                             toggleMobileSidebar(false);
                         }
                    }
                    saveState();
                    render();
                });
                
                app.containers.tagList.addEventListener('click', e => {
                    e.preventDefault();
                    const tagItem = e.target.closest('.tag-filter-item');
                    if (!tagItem) return;

                    const tagName = tagItem.dataset.tag;
                    if (state.settings.activeTag === tagName) {
                        state.settings.activeTag = null; // Toggle off
                    } else {
                        state.settings.activeTag = tagName;
                    }

                    state.settings.activeNoteId = null;
                    state.settings.activeCollectionId = null;
                    saveState();
                    render();
                });

                let draggedItemId = null;
                app.containers.collectionsList.addEventListener('dragstart', (e) => {
                    const wrapper = e.target.closest('.collection-item-wrapper');
                    if(wrapper) {
                        draggedItemId = wrapper.dataset.id;
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', draggedItemId);
                        setTimeout(() => wrapper.classList.add('opacity-50'), 0);
                    }
                });

                app.containers.collectionsList.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    document.querySelectorAll('.drop-target-folder').forEach(el => el.classList.remove('drop-target-folder'));
                    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());

                    const targetWrapper = e.target.closest('.collection-item-wrapper');
                    if (!targetWrapper || targetWrapper.dataset.id === draggedItemId) return;
                    
                    const { item: targetItem } = findItem(targetWrapper.dataset.id);
                    const indicator = document.createElement('div');
                    indicator.className = 'drop-indicator';

                    if (targetItem.type === 'folder') {
                        targetWrapper.querySelector('.collection-item').classList.add('drop-target-folder');
                    }
                    
                    const rect = targetWrapper.getBoundingClientRect();
                    const isAfter = e.clientY > rect.top + rect.height / 2;
                    targetWrapper.insertAdjacentElement(isAfter ? 'afterend' : 'beforebegin', indicator);
                });
                
                app.containers.collectionsList.addEventListener('dragend', (e) => {
                    document.querySelectorAll('.collection-item-wrapper.opacity-50').forEach(el => el.classList.remove('opacity-50'));
                     document.querySelectorAll('.drop-indicator, .drop-target-folder').forEach(el => {
                        el.classList.remove('drop-target-folder');
                        if (el.classList.contains('drop-indicator')) el.remove();
                    });
                    draggedItemId = null;
                });

                app.containers.collectionsList.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const droppedOnElement = e.target;
                    if (!draggedItemId) return;

                    document.querySelectorAll('.drop-indicator, .drop-target-folder').forEach(el => {
                        el.classList.remove('drop-target-folder');
                        if (el.classList.contains('drop-indicator')) el.remove();
                    });

                    const dragResult = findItem(draggedItemId);
                    if (!dragResult) return;
                    
                    const sourceArray = Array.isArray(dragResult.parent) ? dragResult.parent : dragResult.parent.children;
                    const [draggedItem] = sourceArray.splice(dragResult.index, 1);
                    
                    const dropWrapper = droppedOnElement.closest('.collection-item-wrapper');
                    
                    if (dropWrapper) { 
                        const dropId = dropWrapper.dataset.id;
                        if (dropId === draggedItem.id) { 
                            sourceArray.splice(dragResult.index, 0, draggedItem);
                            return;
                        }
                        
                        const dropResult = findItem(dropId);
                        if (!dropResult) return; 
                        
                        const dropTargetIsFolder = dropResult.item.type === 'folder' && droppedOnElement.closest('.collection-item').classList.contains('drop-target-folder');

                        if (dropTargetIsFolder) {
                            if (!dropResult.item.children) dropResult.item.children = [];
                            dropResult.item.children.unshift(draggedItem);
                            dropResult.item.expanded = true;
                        } else {
                            const targetArray = Array.isArray(dropResult.parent) ? dropResult.parent : dropResult.parent.children;
                            let targetIndex = dropResult.index;
                            
                            const rect = dropWrapper.getBoundingClientRect();
                            const isAfter = e.clientY > rect.top + rect.height / 2;
                            if (isAfter) targetIndex++;

                            targetArray.splice(targetIndex, 0, draggedItem);
                        }
                    } else { 
                        state.collections.push(draggedItem);
                    }
                    
                    if (draggedItem.type === 'note') {
                         const newParentResult = findItem(draggedItem.id);
                         const newParent = newParentResult ? newParentResult.parent : null;
                         const newParentId = newParent && !Array.isArray(newParent) ? newParent.id : null;
                         const newProjectColumns = newParentId ? state.kanbanColumns[newParentId] : null;
                         if (newProjectColumns && newProjectColumns.length > 0) {
                             draggedItem.status = newProjectColumns[0].id;
                         } else {
                             draggedItem.status = null;
                         }
                    }

                    saveState();
                    render();
                });

                app.containers.kanbanBoard.addEventListener('click', async e => {
                    const addBtn = e.target.closest('#add-column-btn');
                    const renameBtn = e.target.closest('.rename-column-btn');
                    const deleteBtn = e.target.closest('.delete-column-btn');

                    const collectionId = state.settings.activeCollectionId;
                    if (!collectionId) return;

                    if (addBtn) {
                        const newName = await showPrompt({ title: 'New Column', message: 'Enter a name for the new column:', placeholder: 'e.g. Done' });
                        if (newName) {
                            if(!state.kanbanColumns[collectionId]) state.kanbanColumns[collectionId] = [];
                            state.kanbanColumns[collectionId].push({ id: generateId('col'), title: newName });
                            saveState();
                            render();
                        }
                    } else if (renameBtn) {
                        const columnEl = renameBtn.closest('.kanban-column');
                        const columnId = columnEl.dataset.columnId;
                        const column = state.kanbanColumns[collectionId].find(c => c.id === columnId);
                        const newName = await showPrompt({ title: 'Rename Column', message: `Enter a new name for "${column.title}":`, initialValue: column.title });
                        if(newName) {
                            column.title = newName;
                            saveState();
                            render();
                        }
                    } else if (deleteBtn) {
                        const columnEl = deleteBtn.closest('.kanban-column');
                        const columnId = columnEl.dataset.columnId;
                        const confirmed = await showConfirm({ title: 'Delete Column', message: 'Are you sure you want to delete this column? Notes inside will be moved to the first column.', confirmText: 'Delete' });
                        if (confirmed) {
                            const columns = state.kanbanColumns[collectionId];
                            const columnIndex = columns.findIndex(c => c.id === columnId);
                            const notesToMove = findItem(collectionId).item.children.filter(n => n.status === columnId);
                            
                            columns.splice(columnIndex, 1);

                            if(columns.length > 0) {
                                notesToMove.forEach(n => n.status = columns[0].id);
                            } else {
                                notesToMove.forEach(n => n.status = null);
                            }

                            saveState();
                            render();
                        }
                    }
                });
                
                let draggedKanbanNoteId = null;
                app.containers.kanbanBoard.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('kanban-card')) {
                        draggedKanbanNoteId = e.target.dataset.noteId;
                        e.dataTransfer.setData('text/plain', draggedKanbanNoteId);
                        setTimeout(() => e.target.classList.add('dragging'), 0);
                    }
                });

                app.containers.kanbanBoard.addEventListener('dragend', (e) => {
                    if (e.target.classList.contains('kanban-card')) {
                        e.target.classList.remove('dragging');
                    }
                    document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
                    draggedKanbanNoteId = null;
                });

                app.containers.kanbanBoard.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const column = e.target.closest('.kanban-column');
                    if (column) {
                        document.querySelectorAll('.drop-indicator').forEach(el => el.remove());

                        const cardsContainer = column.querySelector('.cards-container');
                        const afterElement = [...cardsContainer.querySelectorAll('.kanban-card:not(.dragging)')].reduce((closest, child) => {
                            const box = child.getBoundingClientRect();
                            const offset = e.clientY - box.top - box.height / 2;
                            if (offset < 0 && offset > closest.offset) {
                                return { offset: offset, element: child };
                            } else {
                                return closest;
                            }
                        }, { offset: Number.NEGATIVE_INFINITY }).element;
                        
                        const indicator = document.createElement('div');
                        indicator.className = 'drop-indicator';

                        if (afterElement == null) {
                            cardsContainer.appendChild(indicator);
                        } else {
                            cardsContainer.insertBefore(indicator, afterElement);
                        }
                    }
                });
                
                app.containers.kanbanBoard.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const columnEl = e.target.closest('.kanban-column');
                    if (columnEl && draggedKanbanNoteId) {
                        const newColumnId = columnEl.dataset.columnId;
                        const collectionId = state.settings.activeCollectionId;
                        const collectionResult = findItem(collectionId);
                        const collectionNotes = collectionResult.item.children;

                        const dragResult = findItem(draggedKanbanNoteId);
                        const [draggedNote] = collectionNotes.splice(collectionNotes.indexOf(dragResult.item), 1);
                        draggedNote.status = newColumnId;
                        
                        const dropIndicator = columnEl.querySelector('.drop-indicator');
                        if (dropIndicator) {
                            const nextCard = dropIndicator.nextElementSibling;
                            if (nextCard) {
                                const nextNoteId = nextCard.dataset.noteId;
                                const nextNote = findItem(nextNoteId).item;
                                const targetIndex = collectionNotes.indexOf(nextNote);
                                collectionNotes.splice(targetIndex, 0, draggedNote);
                            } else {
                                collectionNotes.push(draggedNote);
                            }
                            dropIndicator.remove();
                        } else {
                            collectionNotes.push(draggedNote);
                        }
                        
                        saveState();
                        renderKanbanView();
                        feather.replace();
                    }
                });
                
                app.elements.viewSwitcher.addEventListener('click', (e) => {
                    const button = e.target.closest('.view-btn');
                    if(button && !button.classList.contains('active')) {
                        state.settings.activeView = button.dataset.view;
                        saveState();
                        renderMainView();
                        feather.replace();
                    }
                });

                app.containers.mobileControlsDropdown.addEventListener('click', async (e) => {
                    
    const button = e.target.closest('button');
    if (!button) return;

    const closeDropdown = () => {
        const dropdown = app.containers.mobileControlsDropdown;
        dropdown.classList.add('scale-95', 'opacity-0');
        setTimeout(() => dropdown.classList.add('hidden'), 100);
    };

    const action = button.dataset.action;
    const noteId = state.settings.activeNoteId;
    if (action === 'mobile-delete-folder') {
        closeDropdown();
        const collectionId = state.settings.activeCollectionId;
        if (!collectionId) return;

        const { item: folder, parent, index } = findItem(collectionId);
        if (!folder) return;

        const parentArray = Array.isArray(parent) ? parent : parent.children;

        const confirmed = await showConfirm({
            title: `Delete Folder "${folder.name}"`,
            message: 'This will delete the folder and <strong>all notes inside it</strong>. This action cannot be undone.',
            confirmText: 'Delete'
        });

        if (confirmed) {
            parentArray.splice(index, 1);
            showToast(`Folder "${folder.name}" deleted.`, 'success');
            state.settings.activeCollectionId = null;
            state.settings.activeNoteId = null;
            saveState();
            buildLunrIndex();
            render();
        }
        return; // Stop after handling this action
    }
    if (action === 'mobile-rename-folder') {
    closeDropdown();
    const collectionId = state.settings.activeCollectionId;
    if (!collectionId) return;

    const { item: folder } = findItem(collectionId);
    if (!folder) return;

    const newName = await showPrompt({
        title: 'Rename Folder',
        message: `Enter a new name for "${folder.name}":`,
        initialValue: folder.name
    });

    if (newName && newName !== folder.name) {
        folder.name = newName;
        saveState();
        buildLunrIndex();
        render();
        showToast(`Folder renamed to "${newName}"`, 'success');
    }
    return;
}

    // Handle all actions that require an active note
    if (action === 'mobile-new-note') {
    closeDropdown();
    createNewNote();
    return;
}
    if (action && noteId) {
        closeDropdown(); // Close menu immediately after an action is clicked
        const { item: note, parent, index } = findItem(noteId);
        if (!note) return;

        const parentArray = Array.isArray(parent) ? parent : parent.children;
        const plainContent = (note.content || '').replace(/<[^>]*>?/gm, '').trim();

        switch (action) {
            case 'mobile-summarize':
                handleSummarize(plainContent);
                break;
            case 'mobile-quiz':
                handleGenerateQuiz(plainContent, note);
                break;
                case 'mobile-flashcard':
    handleFlashcardMode(note);
    break;
            case 'mobile-rename':
                const newName = await showPrompt({ title: 'Rename', message: `Enter a new name for "${note.name}":`, initialValue: note.name });
                if (newName) {
                    note.name = newName;
                    saveState();
                    buildLunrIndex();
                    render();
                }
                break;
            case 'mobile-duplicate':
                const newItem = duplicateItem(note);
                parentArray.splice(index + 1, 0, newItem);
                showToast(`Duplicated "${note.name}"`);
                saveState();
                buildLunrIndex();
                render();
                break;
            case 'mobile-pin':
                note.pinned = !note.pinned;
                showToast(note.pinned ? `Pinned "${note.name}"` : `Unpinned "${note.name}"`);
                saveState();
                render();
                break;
            case 'mobile-delete':
                const confirmed = await showConfirm({ title: `Delete "${note.name}"`, message: 'This action cannot be undone.', confirmText: 'Delete' });
                if (confirmed) {
                    parentArray.splice(index, 1);
                    showToast(`"${note.name}" deleted.`);
                    state.settings.activeNoteId = null;
                    saveState();
                    buildLunrIndex();
                    render();
                }
                break;
                case 'mobile-share':
    handleShareNote();
    break;
    case 'mobile-upload':
    document.getElementById('file-upload-input').click();
    break;
    case 'mobile-add-checklist':
    restoreSelectionAndExec(() => {
        const newDefaultChecklistHTML = `
<div class="checklist-container" contenteditable="false">
    <div class="checklist-header">
        <h4 class="checklist-title font-semibold text-text-primary flex-grow">Untitled Checklist</h4>
        <button class="checklist-header-btn" data-action="edit" title="Edit Checklist"><i data-feather="edit" class="w-4 h-4"></i></button>
        <button class="checklist-header-btn delete" data-action="delete" title="Delete Checklist"><i data-feather="trash-2" class="w-4 h-4"></i></button>
    </div>
    <div class="checklist-progress-container">
        <div class="checklist-progress-bar">
            <div class="checklist-progress-fill" style="width: 0%;"></div>
        </div>
        <span class="checklist-progress-text">0% Complete</span>
    </div>
    <ul class="checklist-body">
        <li class="checklist-item" data-checked="false"><input type="checkbox" class="checklist-item-checkbox" onclick="return false;"><span class="checklist-item-text" contenteditable="false">New item</span></li>
    </ul>
</div>
<p><br></p>
`;
        // THE FIX: Use the 'newDefaultChecklistHTML' variable.
        document.execCommand('insertHTML', false, newDefaultChecklistHTML);
        feather.replace();
    });
    break;
        }
    } 
    // Handle view switching, which doesn't need an active note
    else if (button.classList.contains('view-btn-mobile')) {
        state.settings.activeView = button.dataset.view;
        saveState();
        renderMainView();
        renderMobileControls();
    }
});
                
                app.elements.sortOrderSelect.addEventListener('change', (e) => {
                    state.settings.listSortOrder = e.target.value;
                    saveState();
                    renderListView();
                    feather.replace();
                });
                
                app.containers.mainContentArea.addEventListener('click', (e) => {
                    const exitBtn = e.target.closest('.exit-code-btn');
                    if (exitBtn) {
                        const wrapper = exitBtn.closest('.code-block-wrapper');
                        if (wrapper) {
                            // Create a new empty paragraph after the code block
                            const newP = document.createElement('p');
                            newP.innerHTML = '<br>';
                            wrapper.after(newP);
                            
                            // Place the user's cursor in the new paragraph
                            const selection = window.getSelection();
                            const range = document.createRange();
                            range.setStart(newP, 0);
                            range.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(range);
                            
                            // Save the change
                            saveNoteContent();
                        }
                        return; // Stop further execution
                    }
                    // Add this block to handle backlink clicks
const backlink = e.target.closest('.backlink-item');
if (backlink) {
    e.preventDefault();
    state.settings.activeNoteId = backlink.dataset.noteId;
    saveState();
    render(); // Re-render the editor with the new note
    if (window.innerWidth < 768) { // ADD THIS LINE
            toggleMobileSidebar(false);   // ADD THIS LINE
        }                                 // ADD THIS LINE
        return;
    
}

                    const deleteBlockBtn = e.target.closest('.delete-block-btn');
                    if (deleteBlockBtn) {
                        const wrapper = deleteBlockBtn.closest('.code-block-wrapper');
                        if (wrapper) {
                            const parentEditor = wrapper.parentNode;
                            const wasLastElement = (wrapper.nextElementSibling === null);

                            // If there's an empty <p> tag right after, remove it too for cleanup
                            const nextEl = wrapper.nextElementSibling;
                            if (nextEl && nextEl.tagName === 'P' && (nextEl.innerHTML === '<br>' || nextEl.innerHTML === '')) {
                                nextEl.remove();
                            }
                            
                            wrapper.remove();

                            // ** THE FIX **: If the deleted block was the last element, add a new paragraph.
                            if (wasLastElement) {
                                const newP = document.createElement('p');
                                newP.innerHTML = '<br>';
                                parentEditor.appendChild(newP);
                                // Place the cursor in the new paragraph
                                const selection = window.getSelection();
                                const range = document.createRange();
                                range.setStart(newP, 0);
                                range.collapse(true);
                                selection.removeAllRanges();
                                selection.addRange(range);
                            }

                            saveNoteContent();
                            showToast('Code block deleted', 'info');
                        }
                        return;
                    }
                    
                    const summarizeBtn = e.target.closest('.summarize-btn');
if (summarizeBtn) {
    e.preventDefault();
    e.stopPropagation();
    const noteId = summarizeBtn.dataset.noteId;
    const { item: note } = findItem(noteId);
    const plainContent = (note.content || '').replace(/<[^>]*>?/gm, '').trim();
    if (!plainContent) {
        showToast("Note is empty, nothing to summarize.", "info");
        return;
    }
    // No longer needs the second argument
    handleSummarize(plainContent);
    return;
}
                    const quizBtn = e.target.closest('.quiz-btn');
if (quizBtn) {
    e.preventDefault();
    e.stopPropagation();
    const noteId = quizBtn.dataset.noteId;
    const { item: note } = findItem(noteId);
    const plainContent = (note.content || '').replace(/<[^>]*>?/gm, '').trim();
    if (!plainContent) {
        showToast("Note is empty, cannot generate a quiz.", "info");
        return;
    }
    handleGenerateQuiz(plainContent, note);
    return;
}
                    const copyBtn = e.target.closest('.copy-code-btn');
                    if (copyBtn) {
                         const codeBlock = copyBtn.closest('.code-block-wrapper, .hljs').querySelector('pre, code');
                         if(codeBlock) {
                            const code = codeBlock.innerText;
                            navigator.clipboard.writeText(code)
                                .then(() => showToast('Code copied!', 'success'))
                                .catch(err => showToast('Failed to copy code', 'error'));
                         }
                        return;
                    }

                    const card = e.target.closest('.kanban-card, .list-note-item, .search-result-item');
                    if (card) {
    // If clicking a search result, store the query for highlighting
    if (isSearchActive && card.classList.contains('search-result-item')) {
        state.settings.searchHighlightQuery = app.search.input.value;
        closeSearch(true); // Don't re-render immediately
    }
    state.settings.activeNoteId = card.dataset.noteId;
    const { parent } = findItem(state.settings.activeNoteId);
    state.settings.activeCollectionId = (Array.isArray(parent)) ? null : parent.id;
    state.settings.activeTag = null;
    saveState();
    render();
    return;
}
                    
                    const internalLink = e.target.closest('a.internal-link');
                    if (internalLink) {
                        e.preventDefault();
                        const noteId = internalLink.dataset.noteId;
                        if(noteId) {
                            state.settings.activeNoteId = noteId;
                            const { parent } = findItem(noteId);
                            state.settings.activeCollectionId = (Array.isArray(parent)) ? null : parent.id;
                            state.settings.activeTag = null;
                            saveState();
                            render();
                            showToast(`Mapsd to "${internalLink.textContent}"`);
                            if (window.innerWidth < 768) { // ADD THIS LINE
            toggleMobileSidebar(false);   // ADD THIS LINE
        }
                        }
                        return;
                    }
                    
                    const link = e.target.closest('a');
                    if (link && link.href && (app.elements.noteEditorBody.contains(link) || app.elements.markdownPreview.contains(link))) {
                        e.preventDefault();
                        window.open(link.href, '_blank');
                    }
                });

                // This is the core save logic
                // This listener handles checklist state changes reliably
app.elements.noteEditorBody.addEventListener('change', (e) => {
    if (e.target.matches('.task-list-item input[type="checkbox"]')) {
        const item = e.target.closest('.task-list-item');
        if (item) {
            item.classList.toggle('checked', e.target.checked);
            if (e.target.checked) {
                e.target.setAttribute('checked', 'true');
            } else {
                e.target.removeAttribute('checked');
            }
            saveNoteContent();
        }
    }
});
performImmediateSave = () => {
    if (!state.settings.activeNoteId) return;
    const {item: note} = findItem(state.settings.activeNoteId);
    if(note) {
        const newName = app.elements.noteEditorTitle.value;
        const newContent = app.elements.noteEditorBody.innerHTML;

        if(note.name !== newName || note.content !== newContent) {
            note.name = newName;
            note.content = newContent;
            note.modifiedAt = new Date().toISOString();
            updateNoteLinks(note);
            updateNoteTags(note);

            // --- UPGRADED: SMART VERSION HISTORY LOGIC ---
            const versions = state.versions?.[note.id] || [];
            const lastVersionTime = versions.length > 0 ? new Date(versions[0].savedAt).getTime() : 0;
            const now = new Date().getTime();
            const FIVE_MINUTES = 5 * 60 * 1000;

            if (now - lastVersionTime > FIVE_MINUTES) {
                const lastVersionContent = versions[0]?.content || '';
                const dmp = new diff_match_patch();
                const diff = dmp.diff_main(lastVersionContent.replace(/<[^>]*>?/gm, ''), newContent.replace(/<[^>]*>?/gm, ''));
                const delta = diff.reduce((sum, [op, txt]) => sum + (op !== 0 ? txt.length : 0), 0);
                
                const CHANGE_THRESHOLD = 10; // Only save if more than 10 characters have changed
                if (versions.length === 0 || delta > CHANGE_THRESHOLD) {
                    saveNoteVersion(note.id, newContent);
                    console.log(`Meaningful change detected (delta: ${delta}). New version saved for: ${note.name}`);
                }
            }
            // --- END: UPGRADED LOGIC ---

            saveState();
            buildLunrIndex();
            renderCollectionsList();
            renderTagList();
        }
    }
};

// The debounced version is now just a wrapper around the immediate one
saveNoteContent = debounce(performImmediateSave, 500);

                const updateStatsDebounced = debounce(updateEditorStats, 250);

                app.elements.noteEditorTitle.addEventListener('input', saveNoteContent);
                app.elements.noteEditorBody.addEventListener('input', () => {
                    saveNoteContent();
                    updateStatsDebounced();
                });

                // REPLACE your entire existing 'noteEditorBody' keydown listener with this one
app.elements.noteEditorBody.addEventListener('keydown', (e) => {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    const range = selection.getRangeAt(0);
    let container = range.startContainer;
    const node = container.nodeType === 3 ? container.parentNode : container;

    // --- START: Generalized Ctrl+Enter Escape Logic ---
    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        let elementToEscape = node.closest('.code-block-wrapper, blockquote, table, .task-list-item');
        if (!elementToEscape) {
            const inlineCode = node.closest('code:not(pre code)');
            if (inlineCode) {
                elementToEscape = inlineCode.closest('p, div, li');
            }
        }
        if (elementToEscape) {
            e.preventDefault();
            const newP = document.createElement('p');
            newP.innerHTML = '<br>';
            elementToEscape.after(newP);
            const newRange = document.createRange();
            newRange.setStart(newP, 0);
            selection.removeAllRanges();
            selection.addRange(newRange);
            saveNoteContent();
            return;
        }
    }
    // --- END: Generalized Ctrl+Enter Escape Logic ---

    // --- START: NEW, ROBUST Checklist 'Enter' and 'Backspace' Logic ---
    
    // --- END: NEW, ROBUST Checklist 'Enter' and 'Backspace' Logic ---

    // ... (the rest of the keydown logic for blockquotes, code blocks, etc. remains the same)
    if (e.key === 'Enter' && !e.shiftKey) {
        const currentBlock = node.closest('p, div');
        if (currentBlock) {
            const blockquote = currentBlock.closest('blockquote');
            if (blockquote && currentBlock.textContent.trim() === '' && (currentBlock.innerHTML === '' || currentBlock.innerHTML === '<br>')) {
                e.preventDefault();
                const newP = document.createElement('p');
                newP.innerHTML = '<br>';
                blockquote.after(newP);
                currentBlock.remove();
                if (blockquote.textContent.trim() === '') blockquote.remove();
                const newRange = document.createRange();
                newRange.setStart(newP, 0);
                selection.removeAllRanges();
                selection.addRange(newRange);
                saveNoteContent();
                return;
            }
        }
    }
    if (e.key === 'Backspace' && selection.isCollapsed && range.startOffset === 0) {
        const pre = node.closest('pre');
        if (pre && pre.textContent.length === 0) {
            const wrapper = pre.closest('.code-block-wrapper');
            if (wrapper) {
                e.preventDefault();
                wrapper.remove();
                saveNoteContent();
                return;
            }
        }
    }
    if (e.key === 'ArrowDown') {
        const pre = node.closest('pre');
        if (pre) {
            const codeEl = pre.querySelector('code');
            if (codeEl && selection.isCollapsed) {
                const range = selection.getRangeAt(0);
                const textContent = codeEl.textContent || '';
                if (range.startOffset === textContent.length) {
                    const wrapper = pre.closest('.code-block-wrapper');
                    if (wrapper && !wrapper.nextElementSibling) {
                        e.preventDefault();
                        const newP = document.createElement('p');
                        newP.innerHTML = '<br>';
                        wrapper.after(newP);
                        const newRange = document.createRange();
                        newRange.setStart(newP, 0);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    }
                }
            }
        }
    }
});

                // NEW: Enhanced paste event listener
// REPLACE THE OLD 'paste' LISTENER WITH THIS UPGRADED VERSION
app.elements.noteEditorBody.addEventListener('paste', (e) => {
    // Check for image files first (existing logic)
    const files = e.clipboardData.files;
    let handledFile = false;
    for (const file of files) {
        if (file.type.startsWith('image/')) {
            handleFileUpload(file);
            e.preventDefault();
            handledFile = true;
        }
    }
    if (handledFile) return;

    e.preventDefault();
    let pastedHtml = e.clipboardData.getData('text/html');
    const plainText = e.clipboardData.getData('text/plain');

    // --- START: NEW SPREADSHEET PASTE LOGIC ---
    // Check if the plain text is tab-separated and has multiple lines, which is typical for spreadsheets.
    if (plainText.includes('\t') && plainText.includes('\n')) {
        const lines = plainText.trim().split('\n').map(line => line.split('\t'));
        const cols = lines[0].length;

        // Ensure it's a consistent table structure
        if (lines.every(line => line.length === cols)) {
            let tableHTML = '<table style="width:100%"><thead>';
            tableHTML += `<tr><th colspan="${cols}" contenteditable="false"><div class="table-header-controls"><div class="table-filter-wrapper"><i data-feather="search" class="filter-icon"></i><input class="table-filter-input" placeholder="Filter table..."/></div><button class="toggle-filter-btn" title="Toggle Filter"><i data-feather="chevrons-up" class="w-4 h-4"></i></button></div></th></tr>`;
            
            const [headers, ...rows] = lines;
            tableHTML += '<tr>';
            headers.forEach(header => tableHTML += `<th class="sortable-header" data-sort-dir="none" contenteditable="true">${header}</th>`);
            tableHTML += '</tr></thead><tbody>';

            rows.forEach(row => {
                tableHTML += '<tr>';
                row.forEach(cell => tableHTML += `<td contenteditable="true">${cell}</td>`);
                tableHTML += '</tr>';
            });
            tableHTML += '</tbody></table><p><br></p>';
            
            document.execCommand('insertHTML', false, tableHTML);
            feather.replace();
            saveNoteContent();
            return; // Exit after handling the spreadsheet paste
        }
    }
    // --- END: NEW SPREADSHEET PASTE LOGIC ---

    // Fallback to existing logic for other HTML or plain text pastes
    if (!pastedHtml) {
        pastedHtml = `<p>${plainText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, '</p><p>')}</p>`;
    }

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = pastedHtml;
    tempDiv.querySelectorAll('*').forEach(el => {
        el.removeAttribute('style');
        el.removeAttribute('class');
        if (el.tagName.toLowerCase() === 'font') {
            const parent = el.parentNode;
            while (el.firstChild) parent.insertBefore(el.firstChild, el);
            parent.removeChild(el);
        }
    });
    const sanitizedHtml = tempDiv.innerHTML;
    const finalHtml = upgradePastedTables(sanitizedHtml);

    document.execCommand('insertHTML', false, finalHtml);
    feather.replace();
    saveNoteContent();
});

                app.elements.noteEditorBody.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const files = e.dataTransfer.files;
                    for (const file of files) {
                        handleImageFile(file);
                    }
                });
                
                app.elements.noteEditorBody.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });
                
                app.toolbar.ocrBtn.addEventListener('click', () => app.toolbar.ocrFileInput.click());
                app.toolbar.ocrFileInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    if (!state.settings.activeNoteId) {
                        createNewNote();
                    }
                    
                    const toastId = showToast('Recognizing text...', 'loading');
                    try {
                        const { data: { text } } = await Tesseract.recognize(file, 'eng');
                        const formattedText = `<p>${text.replace(/\n/g, '</p><p>')}</p>`;
                        app.elements.noteEditorBody.focus();
                        document.execCommand('insertHTML', false, formattedText);
                        saveNoteContent();
                        showToast('Text inserted!', 'success');
                    } catch (err) {
                        console.error(err);
                        showToast('Could not recognize text.', 'error');
                    } finally {
                        dismissToast(toastId);
                        app.toolbar.ocrFileInput.value = '';
                    }
                });
                
                app.toolbar.dictateBtn.addEventListener('click', () => {
                    if (!speechRecognizer) return;
                    if (isDictating) {
                        speechRecognizer.stop();
                        isDictating = false;
                        app.toolbar.dictateBtn.classList.remove('recording');
                        showToast('Dictation stopped.', 'info');
                    } else {
                        speechRecognizer.start();
                        isDictating = true;
                        app.toolbar.dictateBtn.classList.add('recording');
                        showToast('Listening...', 'info');
                    }
                });

                app.toolbar.graphBtn.addEventListener('click', () => {
                    const noteId = state.settings.activeNoteId;
                    if (!noteId) return;
                        document.getElementById('sidebar-toggle-btn').style.display = 'none'; // ADD THIS LINE


                    try {
                        const allNotes = getAllNotes(state.collections);
                        const { item: currentNote } = findItem(noteId);

                        const nodes = new vis.DataSet([{ id: currentNote.id, label: currentNote.name, color: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary') }]);
                        const edges = new vis.DataSet();

                        // Links from current note
                        (currentNote.links || []).forEach(linkName => {
                            const targetNote = allNotes.find(n => n.name.toLowerCase() === linkName.toLowerCase());
                            if (targetNote && targetNote.id !== currentNote.id) {
                                if (!nodes.get(targetNote.id)) {
                                    nodes.add({ id: targetNote.id, label: targetNote.name });
                                }
                                edges.add({ from: currentNote.id, to: targetNote.id, arrows: 'to' });
                            }
                        });

                        // Links to current note (backlinks)
                        allNotes.forEach(note => {
                            if (note.id !== currentNote.id && (note.links || []).some(link => link.toLowerCase() === currentNote.name.toLowerCase())) {
                                 if (!nodes.get(note.id)) {
                                    nodes.add({ id: note.id, label: note.name });
                                }
                                edges.add({ from: note.id, to: currentNote.id, arrows: 'to' });
                            }
                        });
                        
                        const computedStyles = getComputedStyle(document.documentElement);

                        const options = {
                            nodes: {
                                shape: 'box',
                                color: computedStyles.getPropertyValue('--bg-pane-dark').trim(),
                                font: { color: computedStyles.getPropertyValue('--text-primary').trim() },
                                borderWidth: 1,
                            },
                            edges: {
                                color: {
                                    color: computedStyles.getPropertyValue('--text-tertiary').trim(),
                                    highlight: computedStyles.getPropertyValue('--accent-primary').trim(),
                                }
                            },
                            physics: {
                                enabled: true,
                                solver: 'barnesHut',
                                barnesHut: {
                                    gravitationalConstant: -4000,
                                    centralGravity: 0.1,
                                    springLength: 150,
                                }
                            },
                            interaction: {
                                dragNodes: true,
                                dragView: true,
                                zoomView: true
                            }
                        };
                        new vis.Network(app.modals.graphContainer, { nodes, edges }, options);
                        const network = new vis.Network(app.modals.graphContainer, { nodes, edges }, options);

                        // --- START: NEW & IMPROVED INTERACTIVITY CODE ---
                        network.on('click', function(params) {
                            if (params.nodes.length > 0) {
                                const noteId = params.nodes[0];
                                const noteToOpen = findItem(noteId)?.item;
                                if (noteToOpen) {
                                    state.settings.activeNoteId = noteId;
                                    const { parent } = findItem(noteId);
                                    state.settings.activeCollectionId = (Array.isArray(parent)) ? null : parent.id;
                                    state.settings.activeTag = null;
                                    saveState();
                                    render();
                                    closeModal(app.modals.graph);
                                }
                            }
                        });

                        const createTooltip = () => {
                            let tooltip = document.getElementById('note-graph-tooltip');
                            if (!tooltip) {
                                tooltip = document.createElement('div');
                                tooltip.id = 'note-graph-tooltip';
                                tooltip.style.position = 'absolute';
                                tooltip.style.visibility = 'hidden';
                                tooltip.style.backgroundColor = 'var(--bg-pane-dark)';
                                tooltip.style.border = '1px solid var(--border-color)';
                                tooltip.style.borderRadius = '8px';
                                tooltip.style.padding = '12px';
                                tooltip.style.maxWidth = '300px';
                                tooltip.style.color = 'var(--text-primary)';
                                tooltip.style.boxShadow = '0 4px 12px var(--shadow-color)';
                                tooltip.style.pointerEvents = 'none';
                                tooltip.style.zIndex = '10000';
                                tooltip.style.opacity = '0';
                                tooltip.style.transition = 'opacity 0.2s ease-in-out';
                                document.body.appendChild(tooltip);
                            }
                            return tooltip;
                        };
                        
                        network.on('hoverNode', function(params) {
                            const noteId = params.node;
                            const note = findItem(noteId)?.item;
                            const tooltip = createTooltip();

                            if (note) {
                                const plainContent = note.content.replace(/<[^>]*>?/gm, '').trim();
                                const excerpt = plainContent.substring(0, 150) + (plainContent.length > 150 ? '...' : '');

                                tooltip.innerHTML = `
                                    <h4 style="font-weight: 600; margin: 0 0 5px 0;">${note.name}</h4>
                                    <p style="font-size: 0.875rem; margin: 0; color: var(--text-secondary);">${excerpt || 'This note is empty.'}</p>
                                `;

                                tooltip.style.left = `${params.event.pointer.DOM.x + 15}px`;
                                tooltip.style.top = `${params.event.pointer.DOM.y + 15}px`;
                                tooltip.style.visibility = 'visible';
                                tooltip.style.opacity = '1';
                            }
                        });

                        network.on('blurNode', function(params) {
                            const tooltip = document.getElementById('note-graph-tooltip');
                            if (tooltip) {
                                tooltip.style.opacity = '0';
                                tooltip.style.visibility = 'hidden';
                            }
                        });
                        // --- END: NEW & IMPROVED INTERACTIVITY CODE ---

                        network.on('blurNode', function(params) {
                            let tooltip = document.getElementById('note-graph-tooltip');
                            if (tooltip) {
                                tooltip.style.opacity = '0';
                            }
                        });
                        // --- END: ADD THIS NEW CODE ---
                        openModal(app.modals.graph);

                    } catch(err) {
                        console.error("Error creating note graph:", err);
                        // showToast('Could not create note graph.', 'error');
                    }
                });
                app.modals.graphCloseBtn.addEventListener('click', () => closeModal(app.modals.graph));
                
                app.modals.aiCancelBtn.addEventListener('click', () => closeModal(app.modals.aiPrompt));
                app.modals.aiGenerateBtn.addEventListener('click', async () => {
                    const prompt = app.modals.aiPromptInput.value.trim();
                    if (!prompt) {
                        app.modals.aiPromptError.textContent = 'Please enter a prompt.';
                        return;
                    }
                    
                    if (!state.settings.activeNoteId) {
                        createNewNote();
                    }
                    
                    app.modals.aiGenerateBtn.disabled = true;
                    app.modals.aiGenerateBtnText.textContent = 'Generating...';

                    const payload = { contents: [{ parts: [{ text: prompt }] }] };
                    const generatedText = await callGeminiAPI(payload, app.modals.aiPromptError);

                    if (generatedText) {
                        app.elements.noteEditorBody.focus();
                        if (editorSelectionRange) {
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(editorSelectionRange);
                        }
                        const formattedHtml = marked.parse(generatedText).trim();
                        document.execCommand('insertHTML', false, formattedHtml);
                        saveNoteContent();
                        closeModal(app.modals.aiPrompt);
                        showToast('AI content inserted!', 'success');
                    }
                    
                    app.modals.aiGenerateBtn.disabled = false;
                    app.modals.aiGenerateBtnText.textContent = 'Generate';
                });
                // --- START: Version History Listeners ---
document.getElementById('history-btn').addEventListener('click', openVersionHistoryModal);
document.getElementById('version-history-close-btn').addEventListener('click', closeVersionHistoryModal);

document.getElementById('version-list-container').addEventListener('click', async (e) => {
    const restoreBtn = e.target.closest('.restore-version-btn');
    if (!restoreBtn) return;

    // Get the preview content directly from the item you clicked on
    const versionItem = restoreBtn.closest('.version-item');
    const previewHTML = versionItem.querySelector('.version-preview').innerHTML;

    const noteId = state.settings.activeNoteId;
    const timestamp = restoreBtn.dataset.versionTimestamp;
    const versionToRestore = state.versions?.[noteId]?.find(v => v.savedAt === timestamp);

    if (!versionToRestore) {
        showToast('Could not find that version.', 'error');
        return;
    }

    const confirmed = await showConfirm({
        title: 'Restore Note Version',
        // This new message includes the content preview for clarity
        message: `This will replace the note's content with the version from <strong>${formatRelativeTime(timestamp)}</strong>.<br><br><p class="text-xs text-text-tertiary">Preview:</p><blockquote class="text-sm p-2 bg-bg-pane-dark rounded-md border-l-4 border-border-color max-h-24 overflow-y-auto">${previewHTML}</blockquote>`,
        confirmText: 'Restore',
        // This makes the button use the brand color instead of red
        confirmClass: 'brand-button'
    });

    if (confirmed) {
        const { item: note } = findItem(noteId);
        if (note) {
            note.content = versionToRestore.content;
            app.elements.noteEditorBody.innerHTML = note.content;
            performImmediateSave();
            closeModal(document.getElementById('version-history-modal'));
            showToast('Note restored successfully!', 'success');
        }
    }
});
// --- END: Version History Listeners ---
                

                const handleSummarize = async (noteContent) => {
    const toastId = showToast('Summarizing...', 'loading');
    const prompt = `Summarize the following text into one or more concise paragraphs:\n\n---\n\n${noteContent}`;
    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    const summaryText = await callGeminiAPI(payload);

    dismissToast(toastId);

    if (summaryText) {
        // New logic: Show the summary in the dedicated modal.
        app.modals.summaryContent.innerHTML = marked.parse(summaryText).trim();
        openModal(app.modals.summary);
        feather.replace();
    } else {
         showToast('Could not generate summary.', 'error');
    }
};
                app.modals.summaryCloseBtn.addEventListener('click', () => closeModal(app.modals.summary));
                app.modals.quizCloseBtn.addEventListener('click', () => closeModal(app.modals.quiz));
app.modals.quizDoneBtn.addEventListener('click', () => closeModal(app.modals.quiz));

app.modals.quizContent.addEventListener('change', e => {
    if (e.target.type === 'radio') { // Logic for single-choice questions
        const questionContainer = e.target.closest('.quiz-question-container');
        const selectedAnswer = e.target.value;
        const correctAnswer = JSON.parse(questionContainer.dataset.correctAnswer);
        const feedbackEl = questionContainer.querySelector('.quiz-feedback');

        questionContainer.querySelectorAll('input[type="radio"]').forEach(radio => {
            radio.disabled = true;
            radio.parentElement.classList.add('cursor-not-allowed', 'opacity-60');
        });

        if (selectedAnswer === correctAnswer) {
            feedbackEl.textContent = 'Correct!';
            feedbackEl.className = 'quiz-feedback text-sm mt-2 h-5 font-medium text-green-500';
            e.target.parentElement.classList.add('bg-green-500/20', 'border-green-500');
        } else {
            feedbackEl.textContent = `Incorrect. The correct answer is ${correctAnswer}.`;
            feedbackEl.className = 'quiz-feedback text-sm mt-2 h-5 font-medium text-red-500';
            e.target.parentElement.classList.add('bg-red-500/20', 'border-red-500');
            const correctLabel = questionContainer.querySelector(`input[value="${correctAnswer}"]`).parentElement;
            correctLabel.classList.remove('opacity-60');
            correctLabel.classList.add('bg-green-500/20', 'border-green-500');
        }
    }
});

// Add this new click listener right after the 'change' listener above
app.modals.quizContent.addEventListener('click', e => {
    if (e.target.classList.contains('submit-msq-btn')) { // Logic for multi-select questions
        const questionContainer = e.target.closest('.quiz-question-container');
        const correctAnswers = new Set(JSON.parse(questionContainer.dataset.correctAnswer));
        const selectedAnswers = new Set(Array.from(questionContainer.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value));
        const feedbackEl = questionContainer.querySelector('.quiz-feedback');

        // Check for perfect match
        const isCorrect = correctAnswers.size === selectedAnswers.size && [...correctAnswers].every(answer => selectedAnswers.has(answer));

        questionContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.disabled = true;
            const label = cb.parentElement;
            label.classList.add('cursor-not-allowed', 'opacity-60');
            if (correctAnswers.has(cb.value)) {
                label.classList.add('bg-green-500/20', 'border-green-500');
            } else if (selectedAnswers.has(cb.value)) {
                label.classList.add('bg-red-500/20', 'border-red-500');
            }
        });

        if (isCorrect) {
            feedbackEl.textContent = 'Correct!';
            feedbackEl.className = 'quiz-feedback text-sm mt-2 h-5 font-medium text-green-500';
        } else {
            feedbackEl.textContent = `Incorrect. The correct answer(s): ${Array.from(correctAnswers).join(', ')}.`;
            feedbackEl.className = 'quiz-feedback text-sm mt-2 h-5 font-medium text-red-500';
        }
        e.target.style.display = 'none'; // Hide submit button after answering
    }
});

                app.elements.chatbotFab.addEventListener('click', () => {
                    renderChatHistory();
                    openModal(app.modals.chatbot);
                    app.modals.chatbotInput.focus();
                    feather.replace();
                });
                app.modals.chatbotCloseBtn.addEventListener('click', () => closeModal(app.modals.chatbot));
                app.modals.chatbotClearBtn.addEventListener('click', async () => {
                    const confirmed = await showConfirm({
                        title: 'Clear Chat History',
                        message: 'Are you sure you want to delete the entire conversation?',
                        confirmText: 'Clear',
                        confirmClass: 'bg-red-500'
                    });
                    if (confirmed) {
                        state.chatHistory = [];
                        saveState();
                        renderChatHistory();
                        showToast('Chat history cleared', 'success');
                    }
                });

                const handleChatSubmit = async () => {
                    const userInput = app.modals.chatbotInput.value.trim();
                    if (!userInput) return;
                    
                    app.modals.chatbotError.textContent = '';
                    app.modals.chatbotInput.value = '';
                    app.modals.chatbotSendBtn.disabled = true;

                    state.chatHistory.push({ role: 'user', text: userInput });
                    renderChatHistory();
                    
                    const thinkingBubble = document.createElement('div');
                    thinkingBubble.className = 'chat-bubble thinking w-fit rounded-lg px-3 py-2 self-start model';
                    thinkingBubble.innerHTML = 'â— â— â—';
                    app.modals.chatbotHistory.appendChild(thinkingBubble);
                    app.modals.chatbotHistory.scrollTop = app.modals.chatbotHistory.scrollHeight;

                    const payload = {
                        contents: state.chatHistory.map(msg => ({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.text }]
                        }))
                    };

                    const modelResponse = await callGeminiAPI(payload, app.modals.chatbotError);
                    
                    thinkingBubble.remove();

                    if (modelResponse) {
                        state.chatHistory.push({ role: 'model', text: modelResponse });
                        renderChatHistory();
                    }
                    saveState();
                    app.modals.chatbotSendBtn.disabled = false;
                    app.modals.chatbotInput.focus();
                };

                app.modals.chatbotSendBtn.addEventListener('click', handleChatSubmit);
                app.modals.chatbotInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        handleChatSubmit();
                    }
                });

                app.elements.newCollectionBtn.addEventListener('click', async () => {
    const name = await showPrompt({ title: 'New Collection', message: 'Enter a name for your new collection:', placeholder: 'e.g. Project Phoenix' });
    if (name) {
        const newCollection = {
            id: generateId('c'), name, type: 'folder', children: [], expanded: true
        };
        
        // --- START: Auto-create note logic ---
        const firstColumnId = generateId('col');
        state.kanbanColumns[newCollection.id] = [{ id: firstColumnId, title: 'To Do' }];

        const now = new Date().toISOString();
        const newNote = {
            id: generateId('n'), name: 'Untitled Note', type: 'note', content: '',
            status: firstColumnId,
            createdAt: now, modifiedAt: now,
            pinned: false, links: [], tags: []
        };
        newCollection.children.push(newNote);
        // --- END: Auto-create note logic ---
        
        state.collections.push(newCollection);
        state.settings.activeCollectionId = newCollection.id;
        state.settings.activeNoteId = newNote.id; // Make the new note active
        saveState();
        buildLunrIndex(); // Rebuild search index
        render();
    }
});

                app.elements.desktopNewNoteBtn.addEventListener('click', () => createNewNote());

                const openSearch = () => {
                    const highlightControls = document.getElementById('highlight-controls');
                    if (!highlightControls.classList.contains('hidden')) {
                        const clearSearchBtn = document.getElementById('clear-search-btn');
                        if (clearSearchBtn) clearSearchBtn.click();
                    }
                    
                    if (window.innerWidth < 768) {
                        // On mobile, show the search bar as an absolute overlay within the header
                        app.search.container.classList.remove('hidden');
                        app.search.container.classList.add('absolute', 'top-0', 'left-0', 'w-full', 'h-full', 'bg-bg-main');
                        app.elements.headerMainContent.classList.add('opacity-0', 'pointer-events-none');
                    } else {
                        // Desktop behavior
                        app.elements.headerMainContent.classList.add('opacity-0', 'pointer-events-none');
                        app.search.container.classList.remove('hidden');
                    }

                    isSearchActive = true;
                    app.search.input.focus();
                    renderMainView();
                };

                const closeSearch = (skipRender = false) => {
                     if (window.innerWidth < 768) {
                        // Properly hide the absolute overlay and restore the main header content
                        app.search.container.classList.add('hidden');
                        app.search.container.classList.remove('absolute', 'top-0', 'left-0', 'w-full', 'h-full', 'bg-bg-main');
                        app.elements.headerMainContent.classList.remove('opacity-0', 'pointer-events-none');
                    } else {
                        // Desktop behavior
                        app.elements.headerMainContent.classList.remove('opacity-0', 'pointer-events-none');
                        app.search.container.classList.add('hidden');
                    }

                    app.search.input.value = '';
                    isSearchActive = false;
                    if (!skipRender) render();
                };

                app.search.icon.addEventListener('click', openSearch);
                app.search.mobileIcon.addEventListener('click', openSearch);
                app.search.closeBtn.addEventListener('click', () => closeSearch());
                app.search.input.addEventListener('input', () => {
                    renderSearchResults(app.search.input.value);
                });

                app.toolbar.editorModeToggle.addEventListener('click', () => {
                    if (!state.settings.activeNoteId) return;
                    state.settings.editorMode = state.settings.editorMode === 'editor' ? 'preview' : 'editor';
                    saveState();
                    renderNoteEditor();
                });

                document.addEventListener('selectionchange', () => {
                    if (document.activeElement !== app.elements.noteEditorBody) {
                        app.toolbar.inline.style.opacity = '0';
                        app.toolbar.inline.style.pointerEvents = 'none';
                        return;
                    }
                    const selection = window.getSelection();

                    if (selection.isCollapsed) {
                        app.toolbar.inline.style.opacity = '0';
                        app.toolbar.inline.style.pointerEvents = 'none';
                        return;
                    }

                    if (selection.rangeCount > 0) {
                        editorSelectionRange = selection.getRangeAt(0).cloneRange();
                    }

                    const range = selection.getRangeAt(0);
                    const rect = range.getBoundingClientRect();
                    const toolbarRect = app.toolbar.inline.getBoundingClientRect();
                    app.toolbar.inline.style.top = `${window.scrollY + rect.top - toolbarRect.height - 8}px`;
                    app.toolbar.inline.style.left = `${window.scrollX + rect.left + (rect.width / 2) - (toolbarRect.width / 2)}px`;
                    app.toolbar.inline.style.opacity = '1';
                    app.toolbar.inline.style.transform = 'scale(1)';
                    app.toolbar.inline.style.pointerEvents = 'auto';
                });
                
                app.toolbar.inline.addEventListener('mousedown', async (e) => {
    const button = e.target.closest('button');
    if (!button) return;

    if (button.id === 'toolbar-scroll-left' || button.id === 'toolbar-scroll-right') {
        return;
    }
    
    e.preventDefault();

    const command = button.dataset.command;
    const value = button.dataset.value;

    if (command === 'monospace') {
        restoreSelectionAndExec(() => {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            let parent = selection.getRangeAt(0).commonAncestorContainer;
            parent = parent.nodeType === 3 ? parent.parentNode : parent;
            const codeTag = parent.closest('code:not(pre code)');
            if (codeTag) {
                const content = document.createDocumentFragment();
                while(codeTag.firstChild) { content.appendChild(codeTag.firstChild); }
                codeTag.parentNode.replaceChild(content, codeTag);
            } else {
                const selectedText = selection.toString();
                if (selectedText) document.execCommand('insertHTML', false, `<code>${selectedText}</code>`);
            }
        });
        return;
    }
    if (command === 'toggleCheckboxes') {
        restoreSelectionAndExec(() => {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const allChecklistItems = app.elements.noteEditorBody.querySelectorAll('.task-list-item');
            allChecklistItems.forEach(item => {
                if (selection.containsNode(item, true)) {
                    item.classList.toggle('checkbox-hidden');
                }
            });
        });
        return;
    }
    if (command === 'formatBlock' && value === 'code') {
         restoreSelectionAndExec(() => {
            const selection = window.getSelection();
            const selectedText = selection.toString();
            let lang = 'plaintext';
            if (/<[a-z][\s\S]*>/i.test(selectedText)) lang = 'html';
            else if (/\b(function|const|let|var|import|export)\b/.test(selectedText)) lang = 'javascript';
            else if (/\b(def|import|class|for|while)\b/.test(selectedText)) lang = 'python';
            const escapedCode = selectedText.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            const codeBlockHTML = `<div class="code-block-wrapper" contenteditable="false"><div class="code-block-header"><span>${lang}</span><div class="flex items-center gap-1"><button class="copy-code-btn" title="Copy Code"><i data-feather="copy" class="w-4 h-4"></i><span>Copy</span></button><button class="delete-block-btn" title="Delete Block"><i data-feather="trash-2" class="w-4 h-4"></i></button></div></div><pre contenteditable="true"><code>${escapedCode}</code></pre></div><p><br></p>`;
            document.execCommand('insertHTML', false, codeBlockHTML);
            feather.replace();
        });
        return;
    }
    if (command === 'insertChecklist') {
    restoreSelectionAndExec(() => {
        const newDefaultChecklistHTML = `
<div class="checklist-container" contenteditable="false">
    <div class="checklist-header">
        <h4 class="checklist-title font-semibold text-text-primary flex-grow">Untitled Checklist</h4>
        <button class="checklist-header-btn" data-action="edit" title="Edit Checklist"><i data-feather="edit" class="w-4 h-4"></i></button>
        <button class="checklist-header-btn delete" data-action="delete" title="Delete Checklist"><i data-feather="trash-2" class="w-4 h-4"></i></button>
    </div>
    <div class="checklist-progress-container">
        <div class="checklist-progress-bar">
            <div class="checklist-progress-fill" style="width: 0%;"></div>
        </div>
        <span class="checklist-progress-text">0% Complete</span>
    </div>
    <ul class="checklist-body">
        <li class="checklist-item" data-checked="false"><input type="checkbox" class="checklist-item-checkbox" onclick="return false;"><span class="checklist-item-text" contenteditable="false">New item</span></li>
    </ul>
</div>
<p><br></p>
`;
        // THE FIX: Use the 'newDefaultChecklistHTML' variable.
        document.execCommand('insertHTML', false, newDefaultChecklistHTML);
        feather.replace();
    });
    return;
}
    if (command === 'insertTable') {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) editorSelectionRange = selection.getRangeAt(0).cloneRange();
        openModal(document.getElementById('table-creator-modal'));
        return;
    }
    if (command === 'createLink') {
        app.elements.noteEditorBody.focus();
        if (editorSelectionRange) {
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(editorSelectionRange);
        }
        const selection = window.getSelection();
        const parentEl = selection.anchorNode?.parentNode.closest('a');
        if(parentEl) {
            restoreSelectionAndExec(() => { document.execCommand('unlink'); });
        } else {
            const selectedText = selection.toString().trim();
            const url = await showPrompt({ title: 'Insert Link', message: 'Enter the URL:', placeholder: 'https://example.com' });
            if (url) {
                restoreSelectionAndExec(() => {
                    let finalUrl = url;
                    if (!/^(https?:\/\/|mailto:|ftp:\/\/)/i.test(finalUrl)) finalUrl = 'https://' + finalUrl;
                    const linkHTML = `<a href="${finalUrl}" target="_blank" rel="noopener noreferrer">${selectedText || finalUrl}</a>`;
                    document.execCommand('insertHTML', false, linkHTML);
                });
            }
        }
    } else if (command === 'insertImage') {
        const url = await showPrompt({ title: 'Insert Image', message: 'Enter the image URL:', placeholder: 'https://example.com/image.png' });
        if (url) restoreSelectionAndExec(() => document.execCommand('insertHTML', false, `<img src="${url}" alt="Image">`));
    } else if (command === 'formatBlock') {
         restoreSelectionAndExec(() => {
            const selection = window.getSelection();
            let parentEl = selection.getRangeAt(0).commonAncestorContainer;
            parentEl = parentEl.nodeType === 3 ? parentEl.parentNode : parentEl;
            const isAlreadyBlock = parentEl.closest(value) || (value === 'blockquote' && parentEl.closest('blockquote'));
            if (isAlreadyBlock) {
                document.execCommand('formatBlock', false, 'p');
            } else {
                document.execCommand(command, false, value);
            }
        });
    } else {
        restoreSelectionAndExec(() => document.execCommand(command, false, null));
    }
});

                app.containers.collectionsList.addEventListener('contextmenu', e => {
                    const itemWrapper = e.target.closest('.collection-item-wrapper');
                    
                    app.contextMenu.togglePinBtn.style.display = 'none';
                    app.contextMenu.renameBtn.style.display = 'none';
                    app.contextMenu.deleteBtn.style.display = 'none';
                    app.contextMenu.duplicateBtn.style.display = 'none';

                    if (!itemWrapper && e.target.closest('#collections-list-container')) {
                        app.contextMenu.targetId = null;
                        app.contextMenu.targetIsContainer = true;
                    } else if (itemWrapper) {
                        e.preventDefault();
                        app.contextMenu.targetId = itemWrapper.dataset.id;
                        app.contextMenu.targetIsContainer = false;
                        const { item } = findItem(app.contextMenu.targetId);
                        
                        app.contextMenu.renameBtn.style.display = 'flex';
                        app.contextMenu.deleteBtn.style.display = 'flex';
                        app.contextMenu.duplicateBtn.style.display = 'flex';

                        if (item && item.type === 'note') {
                            app.contextMenu.togglePinBtn.style.display = 'flex';
                            app.contextMenu.pinActionText.textContent = item.pinned ? 'Unpin' : 'Pin';
                        }
                    } else {
                        return;
                    }

                    app.contextMenu.menu.style.top = `${e.clientY}px`;
                    app.contextMenu.menu.style.left = `${e.clientX}px`;
                    app.contextMenu.menu.classList.remove('hidden');
                    setTimeout(() => app.contextMenu.menu.classList.remove('scale-95', 'opacity-0'), 10);
                    feather.replace();
                });

                const duplicateItem = (sourceItem) => {
                    const newItem = JSON.parse(JSON.stringify(sourceItem));
                    newItem.id = generateId(sourceItem.type[0]);
                    newItem.name = `${sourceItem.name} (copy)`;
                    
                    const now = new Date().toISOString();
                    if (newItem.type === 'note') {
                        newItem.createdAt = now;
                        newItem.modifiedAt = now;
                    }

                    if (newItem.type === 'folder' && newItem.children) {
                        newItem.children = newItem.children.map(child => duplicateItem(child));
                        if (state.kanbanColumns[sourceItem.id]) {
                            state.kanbanColumns[newItem.id] = JSON.parse(JSON.stringify(state.kanbanColumns[sourceItem.id]));
                        }
                    }
                    return newItem;
                };

                app.contextMenu.menu.addEventListener('click', async e => {
    const button = e.target.closest('button');
    if (!button) return;

    // MOVED THIS LINE UP: This now closes the menu immediately, BEFORE the switch statement runs.
    closeContextMenu(); 

    const action = button.dataset.action;
    const id = app.contextMenu.targetId;
    
    let findResult, targetItem, parent, parentArray;

    if (id) {
        findResult = findItem(id);
        targetItem = findResult.item;
        parent = findResult.parent;
        parentArray = Array.isArray(parent) ? parent : parent.children;
    }

    const createNewItem = (type) => {
        const name = type === 'note' ? 'Untitled Note' : 'New Folder';
        const now = new Date().toISOString();
        const newItem = {
            id: generateId(type[0]), name, type,
            ...(type === 'note' && { content: '', status: null, createdAt: now, modifiedAt: now, pinned: false, links: [], tags: [] }),
            ...(type === 'folder' && { children: [], expanded: true })
        };

        let destinationArray = state.collections;
        let parentFolder = null;
        
        if (targetItem) {
            if (targetItem.type === 'folder') {
                destinationArray = targetItem.children;
                targetItem.expanded = true;
                parentFolder = targetItem;
            } else {
                destinationArray = parentArray;
                parentFolder = Array.isArray(parent) ? null : parent;
            }
        }
        if (type === 'folder') {
            const name = 'New Folder';
            const newItem = {
                id: generateId('folder'), name, type, children: [], expanded: true
            };

            const firstColumnId = generateId('col');
            state.kanbanColumns[newItem.id] = [{ id: firstColumnId, title: 'To Do' }];

            const now = new Date().toISOString();
            const newNote = {
                id: generateId('n'), name: 'Untitled Note', type: 'note', content: '',
                status: firstColumnId,
                createdAt: now, modifiedAt: now,
                pinned: false, links: [], tags: []
            };
            newItem.children.push(newNote);

            let destinationArray = state.collections;
            if (targetItem) {
                if (targetItem.type === 'folder') {
                    destinationArray = targetItem.children;
                    targetItem.expanded = true;
                } else {
                    destinationArray = parentArray;
                }
            }
            destinationArray.unshift(newItem);
            
            state.settings.activeNoteId = newNote.id;
        }
        if (newItem.type === 'note' && parentFolder?.id) {
            newItem.status = state.kanbanColumns[parentFolder.id]?.[0]?.id || null;
        }
        
        destinationArray.unshift(newItem);
        
        if (type === 'note') {
            state.settings.activeNoteId = newItem.id;
        } else {
           state.kanbanColumns[newItem.id] = [{ id: generateId('col'), title: 'To Do' }];
        }
        
        saveState();
        render();
    };

    switch(action) {
        case 'new-note': createNewItem('note'); break;
        case 'new-folder': createNewItem('folder'); break;
        case 'delete':
            const confirmed = await showConfirm({ title: `Delete "${targetItem.name}"`, message: 'This action cannot be undone.', confirmText: 'Delete', confirmClass: 'bg-red-600' });
            if (confirmed) {
               const index = parentArray.findIndex(i => i.id === id);
               parentArray.splice(index, 1);
               showToast(`"${targetItem.name}" deleted.`);
               if (state.settings.activeNoteId === id) state.settings.activeNoteId = null;
               if (state.settings.activeCollectionId === id) state.settings.activeCollectionId = null;
               saveState();
               buildLunrIndex();
               render();
            }
            break;
        case 'rename':
            const newName = await showPrompt({ title: 'Rename', 
                message: `Enter a new name for "${targetItem.name}":`, initialValue: targetItem.name });
            if (newName) {
                targetItem.name = newName;
                saveState();
                buildLunrIndex();
                render();
            }
            break;
        case 'toggle-pin':
            if(targetItem && targetItem.type === 'note') {
                targetItem.pinned = !targetItem.pinned;
                showToast(targetItem.pinned ? `Pinned "${targetItem.name}"` : `Unpinned "${targetItem.name}"`);
                saveState();
                render();
            }
            break;
        case 'duplicate':
            if (!targetItem) return;
            const newItem = duplicateItem(targetItem);
            parentArray.splice(findResult.index + 1, 0, newItem);
            showToast(`Note Copied: "${targetItem.name}"`);
            saveState();
            buildLunrIndex();
            render();
            break;
    }
});
                
                const closeContextMenu = () => {
                    app.contextMenu.menu.classList.add('scale-95', 'opacity-0');
                    setTimeout(() => app.contextMenu.menu.classList.add('hidden'), 100);
                };
                
                document.getElementById('bookmarklet-info-btn').addEventListener('click', () => {
                    const code = `javascript:(()=>{const data=JSON.stringify({url:location.href,title:document.title,clip:window.getSelection().toString()});window.open('${window.location.origin + window.location.pathname}#clip='+encodeURIComponent(data),'_blank');})();`;
                    app.modals.bookmarkletLink.href = code;
                    openModal(app.modals.bookmarklet);
                    feather.replace();
                });
                app.modals.bookmarkletCloseBtn.addEventListener('click', () => closeModal(app.modals.bookmarklet));

                app.elements.notesListPane.addEventListener('click', async e => {
                    const button = e.target.closest('button[data-action]');
                    if (!button) return;
                    const action = button.dataset.action;

                    if (action === 'export') {
                        const dataStr = JSON.stringify(state, null, 2);
                        const dataBlob = new Blob([dataStr], {type: "application/json"});
                        const url = URL.createObjectURL(dataBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `codex-notes-backup-${new Date().toISOString().split('T')[0]}.json`;
                        a.click();
                        URL.revokeObjectURL(url);
                        showToast('Data exported successfully!', 'success');
                    } else if (action === 'import') {
                        app.elements.importFileInput.click();
                    }
                });

                app.elements.importFileInput.addEventListener('change', async e => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const confirmed = await showConfirm({
                        title: 'Import Data',
                        message: 'This will <strong>overwrite all current data</strong> in the app. Are you sure you want to continue?',
                        confirmText: 'Overwrite and Import',
                        confirmClass: 'bg-orange-500'
                    });
                    if (!confirmed) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const importedState = JSON.parse(event.target.result);
                            state = migrateState(importedState);
                            saveState();
                            showToast('Data imported successfully!', 'success');
                            location.reload();
                        } catch (err) {
                            console.error("Import error:", err);
                            showToast('Invalid or corrupted data file.', 'error');
                        }
                    };
                    reader.readAsText(file);
                    app.elements.importFileInput.value = '';
                });
                
                document.addEventListener('keydown', (e) => {
                    // Add this inside the existing keydown listener

                    if ((e.metaKey || e.ctrlKey) && e.key === 'u') {
    e.preventDefault();
    document.getElementById('file-upload-input').click();
    if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'n') {
        e.preventDefault();
        // This re-uses the same logic as the header button
        app.elements.newCollectionBtn.click();
    }
}

                    if (e.key === 'Escape') {
                        if (isSearchActive) {
                            closeSearch();
                        }
                        closeContextMenu();
                        if (app.elements.notesListPane.classList.contains('open')) {
                            toggleMobileSidebar(false);
                        }
                    }
                    // This is the NEW, correct code to add
if ((e.metaKey || e.ctrlKey) && e.key === 'f') {
    const editorView = document.getElementById('note-editor-view');

    // Check if the note editor is visible and you're typing in it
    if (!editorView.classList.contains('hidden') && editorView.contains(document.activeElement)) {
        e.preventDefault();
        // Show the IN-NOTE search bar and focus the input
        document.getElementById('highlight-controls').classList.remove('hidden');
        const input = document.getElementById('in-note-search-input');
        input.focus();
        input.select();
    } else if (!isSearchActive) {
        // Otherwise, if global search isn't already active, open it
        e.preventDefault();
        openSearch();
    }
}
                });
                
                document.addEventListener('click', (e) => {
                    if(!app.contextMenu.menu.contains(e.target)) closeContextMenu();
                    if(!app.containers.mobileControlsDropdown.contains(e.target) && !app.elements.mobileMoreButton.contains(e.target)) {
                        const dropdown = app.containers.mobileControlsDropdown;
                        dropdown.classList.add('scale-95', 'opacity-0');
                        setTimeout(() => dropdown.classList.add('hidden'), 100);
                    }
                });
                // --- START: New Checklist Widget Logic ---

let activeChecklistElement = null; // A reference to the .checklist-container div being edited

// Function to open the checklist editing modal
// REPLACE THE ENTIRE openChecklistModal FUNCTION
// ...WITH THIS ENTIRE FUNCTION
const openChecklistModal = (checklistContainer) => {
    activeChecklistElement = checklistContainer;
    const modal = document.getElementById('checklist-edit-modal');
    const itemsContainer = document.getElementById('checklist-modal-items');
    const titleInput = document.getElementById('checklist-modal-title-input');
    itemsContainer.innerHTML = '';

    const currentTitle = checklistContainer.querySelector('.checklist-title')?.textContent || 'Untitled Checklist';
    titleInput.value = currentTitle;

    const items = checklistContainer.querySelectorAll('.checklist-item');
    items.forEach(item => {
        const text = item.querySelector('.checklist-item-text').textContent;
        const checked = item.classList.contains('checked');
        addChecklistItemToModal(text, checked);
    });

    openModal(modal);
    feather.replace();

    // --- NEW DRAG-AND-DROP LOGIC (NO SortableJS) ---
    let draggedItem = null;

    itemsContainer.addEventListener('dragstart', (e) => {
        draggedItem = e.target.closest('.checklist-modal-item');
        if (!draggedItem) return;
        // Add a class for visual feedback while dragging
        setTimeout(() => draggedItem.classList.add('dragging'), 0);
    });

    itemsContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        const targetItem = e.target.closest('.checklist-modal-item');
        if (!targetItem || targetItem === draggedItem) return;

        const rect = targetItem.getBoundingClientRect();
        // Determine if dragging over the top or bottom half of the item
        const isAfter = e.clientY > rect.top + rect.height / 2;

        if (isAfter) {
            targetItem.after(draggedItem);
        } else {
            targetItem.before(draggedItem);
        }
    });

    itemsContainer.addEventListener('dragend', (e) => {
        if (draggedItem) {
            // Clean up the visual class
            draggedItem.classList.remove('dragging');
            draggedItem = null;
        }
    });
};
// Helper to add a new item row inside the modal
// REPLACE THE ENTIRE addChecklistItemToModal FUNCTION
// REPLACE THIS ENTIRE FUNCTION...
const addChecklistItemToModal = (text = '', checked = false) => {
    const itemsContainer = document.getElementById('checklist-modal-items');
    const newItemRow = document.createElement('div');
    // Make the entire row draggable
    newItemRow.className = 'checklist-modal-item';
    newItemRow.setAttribute('draggable', 'true');

    newItemRow.innerHTML = `
        <i data-feather="grip-vertical" class="handle text-text-tertiary"></i>
        <input type="checkbox" class="checklist-modal-item-checkbox w-5 h-5" ${checked ? 'checked' : ''}>
        <input type="text" class="flex-grow" value="${text.replace(/"/g, '&quot;')}">
        <button class="checklist-modal-item-btn" data-action="delete-item" title="Delete Item">
            <i data-feather="x" class="w-4 h-4"></i>
        </button>
    `;
    itemsContainer.appendChild(newItemRow);
    feather.replace();
};


// Function to save changes from the modal back to the editor
// REPLACE THE ENTIRE saveChecklistFromModal FUNCTION
const saveChecklistFromModal = () => {
    if (!activeChecklistElement) return;

    const modalItems = document.querySelectorAll('#checklist-modal-items .checklist-modal-item');
    const newTitle = document.getElementById('checklist-modal-title-input').value.trim() || 'Untitled Checklist';

    const newItemsHTML = Array.from(modalItems).map(itemRow => {
        const text = itemRow.querySelector('input[type="text"]').value;
        const isChecked = itemRow.querySelector('input[type="checkbox"]').checked;
        return `
            <li class="checklist-item ${isChecked ? 'checked' : ''}" data-checked="${isChecked}">
                <input type="checkbox" class="checklist-item-checkbox" ${isChecked ? 'checked' : ''} onclick="return false;">
                <span class="checklist-item-text" contenteditable="false">${text.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</span>
            </li>
        `;
    }).join('');

    const body = activeChecklistElement.querySelector('.checklist-body');
    const titleEl = activeChecklistElement.querySelector('.checklist-title');

    if (body) {
        body.innerHTML = newItemsHTML;
    }
    if (titleEl) {
        titleEl.textContent = newTitle;
    }
    updateChecklistProgress(activeChecklistElement);

    saveNoteContent();
    closeModal(document.getElementById('checklist-edit-modal'));
    activeChecklistElement = null;
    showToast('Checklist updated!', 'success');
};

// Event listeners for the modal buttons
document.getElementById('checklist-modal-add-item-btn').addEventListener('click', () => {
    addChecklistItemToModal();
    // Focus the new input
    const allInputs = document.querySelectorAll('#checklist-modal-items input[type="text"]');
    allInputs[allInputs.length - 1].focus();
});

document.getElementById('checklist-modal-items').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('[data-action="delete-item"]');
    if (deleteBtn) {
        deleteBtn.closest('.checklist-modal-item').remove();
    }
});
document.getElementById('checklist-modal-save-btn').addEventListener('click', saveChecklistFromModal);
document.getElementById('checklist-modal-cancel-btn').addEventListener('click', () => closeModal(document.getElementById('checklist-edit-modal')));
document.getElementById('checklist-modal-close-btn').addEventListener('click', () => closeModal(document.getElementById('checklist-edit-modal')));

// Main event listener for interacting with the widget in the editor
app.elements.noteEditorBody.addEventListener('click', (e) => {
    const checklistContainer = e.target.closest('.checklist-container');
    if (!checklistContainer) return;

    const editBtn = e.target.closest('.checklist-header-btn[data-action="edit"]');
    const deleteBtn = e.target.closest('.checklist-header-btn[data-action="delete"]');
    const item = e.target.closest('.checklist-item');

    if (editBtn) {
        e.preventDefault();
        openChecklistModal(checklistContainer);
    } else if (deleteBtn) {
        e.preventDefault();
        checklistContainer.remove();
        performImmediateSave();
        showToast('Checklist deleted.', 'info');
    } else if (item) {
    e.preventDefault();
    const checkbox = item.querySelector('.checklist-item-checkbox');
    const checklistContainer = item.closest('.checklist-container');
    const isChecked = !item.classList.contains('checked');

    // Update classes and data attributes
    item.classList.toggle('checked', isChecked);
    item.dataset.checked = isChecked;

    // --- THIS IS THE FIX ---
    // Explicitly set the 'checked' attribute for reliable serialization
    if (isChecked) {
        checkbox.setAttribute('checked', 'checked');
    } else {
        checkbox.removeAttribute('checked');
    }
    // Also set the property for immediate visual feedback
    checkbox.checked = isChecked;
    // --- END OF FIX ---

    // Update progress and save
    updateChecklistProgress(checklistContainer);
    performImmediateSave();
}
});

// --- END: New Checklist Widget Logic ---
                // START: New Table Interaction Logic (Context Menu & Sorting)

// START: Final Table Interaction Logic (ALL FEATURES)

let tableContextMenu = document.getElementById('table-context-menu');
let activeTableRow = null;
let activeTableColIndex = -1;
let activeTableForAction = null;

const hideTableContextMenu = () => {
    if (tableContextMenu && !tableContextMenu.classList.contains('hidden')) {
        tableContextMenu.classList.add('scale-95', 'opacity-0');
        setTimeout(() => tableContextMenu.classList.add('hidden'), 100);
    }
};

app.elements.noteEditorBody.addEventListener('contextmenu', (e) => {
    closeContextMenu();
    const row = e.target.closest('tbody tr');
    const col = e.target.closest('thead tr:last-child th'); // Target the actual header row

    if (row || col) {
        e.preventDefault();
        activeTableForAction = e.target.closest('table');
        document.querySelectorAll('.table-menu-item.with-submenu').forEach(item => item.classList.remove('hover'));

        if (row) {
            activeTableRow = row;
            document.getElementById('table-row-actions').style.display = 'block';
            document.getElementById('table-col-actions').style.display = 'none';
        } else {
            activeTableColIndex = Array.from(col.parentElement.children).indexOf(col);
            document.getElementById('table-row-actions').style.display = 'none';
            document.getElementById('table-col-actions').style.display = 'block';
        }
        
        tableContextMenu.style.top = `${e.clientY}px`;
        tableContextMenu.style.left = `${e.clientX}px`;
        tableContextMenu.classList.remove('hidden');
        setTimeout(() => {
            tableContextMenu.classList.remove('scale-95', 'opacity-0');
            feather.replace();
        }, 10);
    }
});

tableContextMenu.addEventListener('click', (e) => {
    const button = e.target.closest('[data-action]');
    if (!button || !activeTableForAction) return;

    const action = button.dataset.action;
    const colCount = activeTableForAction.querySelector('thead tr:last-child').children.length;

    const actions = {
        'add-row-above': () => activeTableRow.before(actions.createRow()),
        'add-row-below': () => activeTableRow.after(actions.createRow()),
        'duplicate-row': () => activeTableRow.after(activeTableRow.cloneNode(true)),
        'delete-row': () => activeTableRow.remove(),
        'highlight': () => {
            const color = button.dataset.color;
            activeTableRow.className = ''; // Clear other colors
            if (color !== 'none') activeTableRow.classList.add(`bg-highlight-${color}`);
        },
        'add-col-left': () => actions.addColumn(activeTableColIndex),
        'add-col-right': () => actions.addColumn(activeTableColIndex + 1),
        'duplicate-col': () => {
            activeTableForAction.querySelectorAll('tr').forEach(row => {
                const cellToClone = row.children[activeTableColIndex];
                if (cellToClone) cellToClone.after(cellToClone.cloneNode(true));
            });
        },
        'delete-col': () => {
            if (colCount <= 1) return showToast("Cannot delete the last column.", "error");
            activeTableForAction.querySelectorAll('tr').forEach(row => row.children[activeTableColIndex]?.remove());
        },
        'calculate': () => {
            const type = button.dataset.calc;
            let tfoot = activeTableForAction.querySelector('tfoot');
            if (!tfoot) {
                tfoot = activeTableForAction.createTFoot();
                const newRow = tfoot.insertRow(0);
                for (let i = 0; i < colCount; i++) {
                    const newCell = newRow.insertCell();
                    // FIX #1: Make the calculation cell non-editable
                    newCell.contentEditable = false;
                }
            }
            const footerCell = tfoot.rows[0].cells[activeTableColIndex];

            if (type === 'clear') {
    footerCell.innerHTML = '';
    footerCell.removeAttribute('data-calc-type');

    // Check if any other calculations exist in the footer
    const allFooterCells = Array.from(footerCell.parentElement.children);
    const hasOtherCalcs = allFooterCells.some(cell => cell.hasAttribute('data-calc-type'));

    if (!hasOtherCalcs) {
        tfoot.remove(); // Remove the entire footer if it's now empty
    }
} else {
                footerCell.dataset.calcType = type;
                performStandardCalculation(activeTableForAction, activeTableColIndex, type);
            }
        },
        'custom-calc': async () => {
            // FIX #2: Get the existing formula before showing the prompt
            const targetHeader = activeTableForAction.querySelector(`thead tr:last-child th:nth-child(${activeTableColIndex + 1})`);
            const existingFormula = targetHeader?.dataset.formula || '';

            const formula = await showPrompt({
                title: 'Custom Column Formula',
                message: 'Enter formula using column names (e.g., Cost * Quantity) or letters (A-Z).',
                placeholder: 'e.g., Cost * 0.07',
                initialValue: existingFormula // And use it as the initial value
            });

            // If user cancels, formula will be null. If they clear the input and confirm, it will be an empty string.
            if (formula === null) return;
            
            if (targetHeader) {
                targetHeader.dataset.formula = formula;
                performCustomFormula(activeTableForAction, activeTableColIndex, formula);
                if (formula) {
                   showToast(`Live formula updated.`, 'success');
                } else {
                   showToast(`Formula cleared for column.`, 'info');
                }
            }
        },
        'createRow': () => {
            const currentHeaderCount = activeTableForAction.querySelector('thead tr:last-child').children.length;
            const newRow = document.createElement('tr');
            newRow.innerHTML = Array(currentHeaderCount).fill('<td contenteditable="true"><br></td>').join('');
            return newRow;
        },
        'addColumn': (index) => {
            activeTableForAction.querySelectorAll('thead tr:last-child, tbody tr').forEach(row => {
                const isHeaderRow = row.parentElement.tagName === 'THEAD';
                const cellType = isHeaderRow ? 'th' : 'td';
                const newCell = document.createElement(cellType);
                newCell.setAttribute('contenteditable', 'true');
                if (isHeaderRow) {
                    newCell.classList.add('sortable-header');
                    newCell.dataset.sortDir = 'none';
                    newCell.textContent = 'Header';
                }
                row.insertBefore(newCell, row.children[index]);
            });
            const newColCount = activeTableForAction.querySelector('thead tr:last-child').children.length;
            const filterHeader = activeTableForAction.querySelector('thead tr:first-child th');
            if (filterHeader) {
                filterHeader.setAttribute('colspan', newColCount);
            }
        },
    };

    if (actions[action]) {
        actions[action]();
        saveNoteContent();
        hideTableContextMenu();
    }
});

app.elements.noteEditorBody.addEventListener('click', (e) => {
// Add this block inside the noteEditorBody 'click' event listener

    const toggleBtn = e.target.closest('.toggle-filter-btn');
    if (toggleBtn) {
        e.preventDefault();
        const table = toggleBtn.closest('table');
        if (table) {
            table.classList.toggle('filter-collapsed');
            saveNoteContent(); // Save the new state of the table
        }
        return; // Stop further actions
    }
    const sortableHeader = e.target.closest('th.sortable-header');
    if (sortableHeader) {
        const table = sortableHeader.closest('table');
        const tbody = table.querySelector('tbody');
        if (!tbody) return;

        const headerRow = sortableHeader.parentElement;
        const headers = Array.from(headerRow.children);
        const colIndex = headers.indexOf(sortableHeader);
        
        const currentDir = sortableHeader.dataset.sortDir;
        const newDir = currentDir === 'asc' ? 'desc' : (currentDir === 'desc' ? 'none' : 'asc');

        // Store original order if it's the first time sorting this table
        if (!table._originalRows) {
            table._originalRows = Array.from(tbody.querySelectorAll('tr'));
        }

        if (newDir === 'none') {
            tbody.append(...table._originalRows); // Revert to original order
        } else {
            let rows = Array.from(tbody.querySelectorAll('tr'));
            // Validation logic
            const firstCellText = rows.length > 0 ? rows[0].children[colIndex]?.innerText.trim() : '';
            const isNumericColumn = firstCellText && isFinite(firstCellText.replace(/[^0-9.-]+/g, ""));
            
            let canSort = true;
            if (isNumericColumn) {
                for (let row of rows) {
                    const cellText = row.children[colIndex]?.innerText.trim();
                    if (cellText && !isFinite(cellText.replace(/[^0-9.-]+/g, ""))) {
                        canSort = false;
                        break;
                    }
                }
            }
            if(!canSort) return showToast("Cannot sort: column contains mixed data types.", "error");

            // Perform sort
            rows.sort((rowA, rowB) => {
                const cellA = rowA.children[colIndex]?.innerText.trim() || '';
                const cellB = rowB.children[colIndex]?.innerText.trim() || '';
                if (isNumericColumn) {
                    const numA = parseFloat(cellA.replace(/[^0-9.-]+/g, "")) || 0;
                    const numB = parseFloat(cellB.replace(/[^0-9.-]+/g, "")) || 0;
                    return newDir === 'asc' ? numA - numB : numB - numA;
                }
                return newDir === 'asc' ? cellA.localeCompare(cellB) : cellB.localeCompare(cellA);
            });
            tbody.append(...rows);
        }

        headers.forEach(th => {
            th.dataset.sortDir = 'none';
            th.querySelector('.sort-indicator')?.remove();
        });
        if(newDir !== 'none') {
            sortableHeader.dataset.sortDir = newDir;
            sortableHeader.insertAdjacentHTML('beforeend', `<span class="sort-indicator">${newDir === 'asc' ? 'â–²' : 'â–¼'}</span>`);
        }
        saveNoteContent();
    }
});

// Column Resizing Logic
app.elements.noteEditorBody.addEventListener('mousedown', (e) => {
    const header = e.target.closest('th');
    if (header) {
        const rect = header.getBoundingClientRect();
        // Check if the click is on the right border of the header
        if (rect.width - e.offsetX < 10) { 
            const table = header.closest('table');
            const startX = e.clientX;
            const startWidth = rect.width;

            const handleMouseMove = (moveEvent) => {
                const newWidth = startWidth + (moveEvent.clientX - startX);
                if (newWidth > 40) { // Minimum width
                    header.style.width = `${newWidth}px`;
                }
            };
            const handleMouseUp = () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                saveNoteContent();
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
    }
});
// --- NEW: Live Calculation Trigger ---
app.elements.noteEditorBody.addEventListener('input', (e) => {
    // Check if the edit happened inside a table cell
    const cell = e.target.closest('td');
    if (cell) {
        const table = cell.closest('table');
        if (table) {
            // Use the debounced function to update calculations
            debouncedLiveCalculate(table);
        }
    }
});
// Table Filtering Logic
// Fuzzy Table Filtering Logic
app.elements.noteEditorBody.addEventListener('input', (e) => {
    const filterInput = e.target.closest('.table-filter-input');
    if(filterInput) {
        const table = filterInput.closest('table');
        const tbody = table.querySelector('tbody');
        const filterText = filterInput.value; // No need for toLowerCase() with Fuse.js

        const rows = Array.from(tbody.querySelectorAll('tr'));

        // If the filter is empty, show all rows and exit
        if (!filterText.trim()) {
            rows.forEach(row => row.style.display = '');
            return;
        }

        // Get all rows to create the search data
        const searchData = rows.map((row, index) => ({
            id: index, // Use index as a reference
            text: row.innerText
        }));

        // Configure Fuse.js for fuzzy searching
        const fuseOptions = {
            keys: ['text'],
            includeScore: true,
            threshold: 0.4 // Adjust threshold for desired fuzziness (0.0 = perfect match, 1.0 = match anything)
        };
        const fuse = new Fuse(searchData, fuseOptions);

        // Perform the search
        const results = fuse.search(filterText);
        const visibleRowIds = new Set(results.map(result => result.item.id));

        // Show/hide rows based on search results
        rows.forEach((row, index) => {
            row.style.display = visibleRowIds.has(index) ? '' : 'none';
        });
    }
});

// Global listener to hide menus
document.addEventListener('click', (e) => {
    if (!e.target.closest('#table-context-menu')) hideTableContextMenu();
    if (!e.target.closest('#context-menu')) closeContextMenu();
});
// --- START: NEW Live Calculation Logic ---

/**
 * A debounced function to trigger live updates for a table.
 * This prevents calculations from running on every single keystroke.
 */
const debouncedLiveCalculate = debounce((table) => {
    updateTableCalculations(table);
}, 400); // 400ms delay

/**
 * Main function to update all calculations for a given table.
 * It checks for both footer calculations (sum, avg) and custom column formulas.
 */
function updateTableCalculations(table) {
    if (!table) return;

    // 1. Update footer calculations (Sum, Average, Count)
    const tfoot = table.querySelector('tfoot');
    if (tfoot) {
        tfoot.querySelectorAll('td[data-calc-type]').forEach((cell, index) => {
            performStandardCalculation(table, index, cell.dataset.calcType);
        });
    }

    // 2. Update custom formula columns
    table.querySelectorAll('thead th[data-formula]').forEach((header, index) => {
        performCustomFormula(table, index, header.dataset.formula);
    });
    
    // This ensures the note is saved after calculations are updated
    saveNoteContent();
}

/**
 * Performs a standard calculation (sum, avg, count) for a specific column.
 */
function performStandardCalculation(table, colIndex, calcType) {
    const tfoot = table.querySelector('tfoot');
    if (!tfoot || !calcType) return;
    
    const footerCell = tfoot.rows[0].cells[colIndex];
    if (!footerCell) return;

    const values = Array.from(table.querySelectorAll('tbody tr'))
        .map(row => parseFloat(row.children[colIndex]?.innerText.replace(/[^0-9.-]+/g, "")))
        .filter(n => !isNaN(n));

    if (values.length === 0) {
        footerCell.innerHTML = ''; // Clear if no numbers
        return;
    }

    let result = '';
    if (calcType === 'sum') result = `Sum: ${values.reduce((a, b) => a + b, 0).toLocaleString()}`;
    if (calcType === 'avg') result = `Avg: ${(values.reduce((a, b) => a + b, 0) / values.length).toLocaleString(undefined, {maximumFractionDigits: 2})}`;
    if (calcType === 'count') result = `Count: ${values.length}`;
    footerCell.textContent = result;
}

/**
 * Applies a custom formula to every row in a target column.
 */
function performCustomFormula(table, targetColIndex, formula) {
    const headers = Array.from(table.querySelectorAll('thead tr:last-child th'))
        .map(th => th.innerText.trim());

    const formulaRegex = /(.+?)\s*([+\-*/])\s*(.+)/;
    const match = formula.match(formulaRegex);
    if (!match) return; // Invalid formula stored

    const [, col1Raw, operator, col2Raw] = match.map(s => s.trim());

    const getIndex = (operand) => {
        let op = operand.replace(/[()]/g, '').trim();
        // 1. Check by Header Name (case-insensitive)
        const lowerOp = op.toLowerCase();
        const headerIndex = headers.findIndex(h => h.toLowerCase() === lowerOp);
        if (headerIndex !== -1) return headerIndex;

        // 2. Fallback to Letter (A, B, C...)
        if (/^[A-Z]$/i.test(op)) return op.toUpperCase().charCodeAt(0) - 65;

        return -1; // Not found
    };

    const col1Index = getIndex(col1Raw);
    const col2Index = getIndex(col2Raw);
    const col2Value = (col2Index === -1) ? parseFloat(col2Raw.replace(/[$,]/g, '')) : null;

    if (col1Index === -1 || (col2Index === -1 && isNaN(col2Value))) return; // Invalid columns in formula

    table.querySelectorAll('tbody tr').forEach(row => {
        const getNumericValue = (index) => parseFloat(row.children[index]?.innerText.replace(/[$,]/g, ''));
        const val1 = getNumericValue(col1Index);
        const val2 = col2Index !== -1 ? getNumericValue(col2Index) : col2Value;
        const targetCell = row.children[targetColIndex];

        if (isNaN(val1) || isNaN(val2) || !targetCell) {
            if(targetCell) targetCell.innerText = '';
            return;
        }

        let result;
        switch (operator) {
            case '+': result = val1 + val2; break;
            case '-': result = val1 - val2; break;
            case '*': result = val1 * val2; break;
            case '/': result = val2 !== 0 ? val1 / val2 : 'Error'; break;
            default: return;
        }
        targetCell.innerText = typeof result === 'number' ? result.toLocaleString(undefined, { maximumFractionDigits: 2 }) : result;
    });
}
// --- END: NEW Live Calculation Logic ---

// END: Final Table Interaction Logic

// END: New Table Interaction Logic

                render();
            }

            
        });
        // START: Interactive Table Logic
app.elements.noteEditorBody.addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('.delete-row-btn');
    const duplicateBtn = e.target.closest('.duplicate-row-btn');
    const sortableHeader = e.target.closest('th.sortable-header');

    // Row Deletion
    if (deleteBtn) {
        e.preventDefault();
        const row = deleteBtn.closest('tr');
        if (row) {
            const confirmed = await showConfirm({
                title: 'Delete Row',
                message: 'Are you sure you want to delete this table row?',
                confirmText: 'Delete'
            });
            if (confirmed) {
                row.remove();
                saveNoteContent();
            }
        }
    }

    // Row Duplication
    if (duplicateBtn) {
        e.preventDefault();
        const row = duplicateBtn.closest('tr');
        if (row) {
            const newRow = row.cloneNode(true);
            row.after(newRow);
            feather.replace(); // Re-render icons on new row
            saveNoteContent();
        }
    }

    // Column Sorting
    if (sortableHeader) {
        e.preventDefault();
        const table = sortableHeader.closest('table');
        const tbody = table.querySelector('tbody');
        const headerRow = sortableHeader.closest('tr');
        const headers = Array.from(headerRow.querySelectorAll('th'));
        const colIndex = headers.indexOf(sortableHeader);

        // Do not sort the 'Actions' column
        if (colIndex === -1 || !headers[colIndex].classList.contains('sortable-header')) return;

        const rows = Array.from(tbody.querySelectorAll('tr'));
        const currentDir = sortableHeader.dataset.sortDir;
        const newDir = currentDir === 'asc' ? 'desc' : 'asc';

        rows.sort((rowA, rowB) => {
            const cellA = rowA.children[colIndex].innerText.trim();
            const cellB = rowB.children[colIndex].innerText.trim();
            const numA = parseFloat(cellA);
            const numB = parseFloat(cellB);

            let valA, valB;
            // Check if both values are valid, finite numbers
            if (!isNaN(numA) && !isNaN(numB) && isFinite(cellA) && isFinite(cellB)) {
                valA = numA;
                valB = numB;
            } else {
                valA = cellA.toLowerCase();
                valB = cellB.toLowerCase();
            }
            
            if (valA < valB) return newDir === 'asc' ? -1 : 1;
            if (valA > valB) return newDir === 'asc' ? 1 : -1;
            return 0;
        });

        // Reset other headers and update the current one
        headers.forEach(th => {
            th.dataset.sortDir = 'none';
            const indicator = th.querySelector('.sort-indicator');
            if (indicator) indicator.remove();
        });
        sortableHeader.dataset.sortDir = newDir;
        sortableHeader.insertAdjacentHTML('beforeend', `<span class="sort-indicator">${newDir === 'asc' ? 'â–²' : 'â–¼'}</span>`);

        // Re-append sorted rows
        tbody.innerHTML = '';
        rows.forEach(row => tbody.appendChild(row));
        saveNoteContent();
    }
});

app.elements.noteEditorBody.addEventListener('keydown', (e) => {
    const target = e.target;
    if (!target.closest('table')) return;

    const cell = target.closest('td, th');
    // Ensure we are in an editable cell
    if (!cell || cell.contentEditable !== 'true') return;

    // Enter: Save and move down
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        const currentRow = cell.parentElement;
        const nextRow = currentRow.nextElementSibling;
        if (nextRow) {
            const cellInNextRow = nextRow.children[cell.cellIndex];
            if (cellInNextRow && cellInNextRow.contentEditable === 'true') {
                cellInNextRow.focus();
            }
        }
        saveNoteContent(); // Save content on Enter
    }

    // Tab: Move to the next editable cell
    if (e.key === 'Tab' && !e.shiftKey) {
        e.preventDefault();
        const currentRow = cell.parentElement;
        let nextCell = cell.nextElementSibling;

        while (nextCell && nextCell.contentEditable !== 'true') {
            nextCell = nextCell.nextElementSibling;
        }

        if (nextCell) {
            nextCell.focus();
        } else {
            let nextRow = currentRow.nextElementSibling;
            // If we are in the header (THEAD), jump to the body (TBODY)
            if (!nextRow && currentRow.parentElement.tagName === 'THEAD') {
                nextRow = currentRow.parentElement.nextElementSibling?.firstElementChild;
            }
            
            if (nextRow) {
                let firstCellOfNextRow = nextRow.querySelector('td[contenteditable="true"], th[contenteditable="true"]');
                if (firstCellOfNextRow) {
                     firstCellOfNextRow.focus();
                }
            }
        }
    }
});
// END: Interactive Table Logic
    </script>
    <script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js').then(registration => {
        console.log('ServiceWorker registration successful with scope: ', registration.scope);
      }, err => {
        console.log('ServiceWorker registration failed: ', err);
      });
    });
  }
</script>
</body>
<div id="command-prompt-container" class="hidden fixed bottom-5 left-1/2 -translate-x-1/2 w-[90%] max-w-lg z-50">
    <div class="relative">
        <div id="command-suggestions" class="hidden absolute bottom-full left-0 w-full mb-1 bg-bg-pane-dark rounded-md shadow-lg p-1 border border-border-color max-h-60 overflow-y-auto custom-scrollbar">
            </div>
        <div class="flex items-center gap-2 bg-bg-pane-dark p-2 rounded-lg shadow-2xl border border-border-color">
            <i data-feather="slash" class="w-5 h-5 text-text-tertiary"></i>
            <input type="text" id="command-input" class="w-full bg-transparent focus:outline-none text-text-primary" placeholder="Type a command..." autocomplete="off">
        </div>
    </div>
</div>
<div id="linked-notes-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-lg z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 id="linked-notes-title" class="text-lg font-semibold flex items-center gap-2"><i data-feather="link" class="w-5 h-5 text-accent-primary"></i>Note Connections</h3>
        <button id="linked-notes-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div id="linked-notes-content" class="flex-grow space-y-4 overflow-y-auto">
        </div>
</div>

<div id="help-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-2xl z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2"><i data-feather="terminal" class="w-5 h-5 text-accent-primary"></i>Command List</h3>
        <button id="help-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>
    <div id="help-content" class="flex-grow space-y-2 overflow-y-auto max-h-[60vh] custom-scrollbar">


        </div>
</div>
<!-- START: New Table Context Menu -->
<div id="table-context-menu" class="context-menu fixed z-50 bg-bg-pane-light shadow-2xl rounded-md p-1 border border-border-color hidden origin-top-left scale-95 opacity-0 text-sm">
    <div id="table-row-actions">
    <div class="table-menu-item" data-action="add-row-above"><i data-feather="arrow-up"></i>Insert Row Above</div>
    <div class="table-menu-item" data-action="add-row-below"><i data-feather="arrow-down"></i>Insert Row Below</div>
    <div class="table-menu-item" data-action="duplicate-row"><i data-feather="copy"></i>Duplicate Row</div>
    <div class="table-menu-item with-submenu">
        <i data-feather="edit-3"></i><span>Highlight Row</span><i data-feather="chevron-right" class="submenu-arrow"></i>
        <div class="submenu">
            <div class="table-menu-item" data-action="highlight" data-color="yellow"><span class="color-swatch bg-highlight-yellow"></span>Yellow</div>
            <div class="table-menu-item" data-action="highlight" data-color="green"><span class="color-swatch bg-highlight-green"></span>Green</div>
            <div class="table-menu-item" data-action="highlight" data-color="blue"><span class="color-swatch bg-highlight-blue"></span>Blue</div>
            <div class="table-menu-item" data-action="highlight" data-color="red"><span class="color-swatch bg-highlight-red"></span>Red</div>
            <hr class="my-1 border-border-color">
            <div class="table-menu-item" data-action="highlight" data-color="none">Clear Highlight</div>
        </div>
    </div>
    <hr class="my-1 border-border-color">
    <div class="table-menu-item text-red-500" data-action="delete-row"><i data-feather="trash-2"></i>Delete Row</div>
</div>
    <div id="table-col-actions" class="hidden">
        <div class="table-menu-item" data-action="add-col-left"><i data-feather="arrow-left"></i>Insert Column Left</div>
        <div class="table-menu-item" data-action="add-col-right"><i data-feather="arrow-right"></i>Insert Column Right</div>
        <div class="table-menu-item" data-action="duplicate-col"><i data-feather="copy"></i>Duplicate Column</div>
        <div class="table-menu-item with-submenu">
             <i data-feather="plus-circle"></i><span>Calculate</span><i data-feather="chevron-right" class="submenu-arrow"></i>
             <div class="submenu">
                <div class="table-menu-item" data-action="calculate" data-calc="sum">Sum</div>
                <div class="table-menu-item" data-action="calculate" data-calc="avg">Average</div>
                <div class="table-menu-item" data-action="calculate" data-calc="count">Count</div>
                <div class="table-menu-item" data-action="custom-calc">Custom Calculation</div>
                <hr class="my-1 border-border-color">
                <div class="table-menu-item" data-action="calculate" data-calc="clear">Clear Calculation</div>
             </div>
        </div>
        <hr class="my-1 border-border-color">
        <div class="table-menu-item text-red-500" data-action="delete-col"><i data-feather="trash-2"></i>Delete Column</div>
    </div>
</div>
<div id="checklist-edit-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light p-6 rounded-lg shadow-2xl w-[90vw] max-w-lg z-50 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center mb-4 flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2">
            <i data-feather="check-square" class="w-5 h-5 text-accent-primary"></i>
            <span>Edit Checklist</span>
        </h3>
        <button id="checklist-modal-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
    </header>

    <div class="mb-4 flex-shrink-0">
        <label for="checklist-modal-title-input" class="text-sm font-medium text-text-secondary">Checklist Title</label>
        <input type="text" id="checklist-modal-title-input" class="w-full mt-1 bg-bg-pane-dark border border-border-color rounded-md p-2 focus:ring-2 focus:ring-accent-primary focus:outline-none">
    </div>

    <div id="checklist-modal-items" class="flex-grow space-y-2 overflow-y-auto custom-scrollbar pr-2">
        </div>

    <div class="mt-4 flex-shrink-0">
        <button id="checklist-modal-add-item-btn" class="w-full flex items-center justify-center gap-2 p-2 rounded-md text-sm text-text-secondary hover:bg-bg-pane-dark transition-colors">
            <i data-feather="plus" class="w-4 h-4"></i>
            <span>Add Item</span>
        </button>
    </div>

    <footer class="flex justify-end gap-3 mt-6 flex-shrink-0">
        <button id="checklist-modal-cancel-btn" class="px-4 py-2 rounded-md bg-bg-pane-dark hover:opacity-80">Cancel</button>
        <button id="checklist-modal-save-btn" class="px-4 py-2 rounded-md brand-button hover:opacity-90">Save Changes</button>
    </footer>
</div>
<!-- END: New Table Context Menu -->
 <div id="version-history-modal" class="modal hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-bg-pane-light rounded-lg shadow-2xl w-[90vw] max-w-6xl h-[80vh] z-60 transition-all duration-300 transform scale-95 opacity-0 flex flex-col">
    <header class="flex justify-between items-center p-4 border-b border-border-color flex-shrink-0">
        <h3 class="text-lg font-semibold flex items-center gap-2">
            <i data-feather="history" class="w-5 h-5 text-accent-primary"></i>
            <span id="version-history-title">Version History</span>
        </h3>
        <div class="flex items-center gap-3">
            <button id="version-restore-btn" class="brand-button text-sm">Restore this version</button>
            <button id="version-history-close-btn" class="p-2 rounded-full hover:bg-bg-pane-dark"><i data-feather="x" class="w-5 h-5"></i></button>
        </div>
    </header>

    <div class="flex flex-grow min-h-0">
        <div id="version-sidebar" class="w-64 bg-bg-pane-dark p-2 flex flex-col flex-shrink-0 border-r border-border-color">
    <div class="p-1 flex-shrink-0">
        <button id="compare-versions-btn" class="w-full text-sm brand-button opacity-50" disabled>
            <i data-feather="git-pull-request" class="w-4 h-4 mr-2"></i>Compare Selected
        </button>
    </div>
    <div class="p-1 pt-2 flex-shrink-0">
        <div class="relative">
            <i data-feather="search" class="absolute left-2 top-1/2 -translate-y-1/2 w-4 h-4 text-text-tertiary"></i>
            <input type="text" id="version-search-input" placeholder="Search versions..." class="w-full bg-bg-main border border-border-color rounded-md py-1 pl-8 pr-2 text-sm focus:outline-none focus:ring-1 focus:ring-accent-primary">
        </div>
    </div>
    <div id="version-list-container" class="space-y-1 overflow-y-auto custom-scrollbar flex-grow">
        </div>
</div>

        <div id="version-content-viewer" class="flex-grow p-6 overflow-y-auto custom-scrollbar prose max-w-none">
            </div>
    </div>
</div>
</body>
</html>
