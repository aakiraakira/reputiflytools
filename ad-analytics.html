<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reputifly ROAS Scenario Lab</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>

  <style>
    /* --- 1. Design System & Variables (New Theme) --- */
    :root {
      --bg: #2B2338;
      --card-glass: rgba(255, 255, 255, 0.05); /* Glass BG */
      --border-glass: rgba(255, 255, 255, 0.1); /* Glass Border */
      --table-cell-bg: rgba(255, 255, 255, 0.03);
      --sticky-bg: rgba(43, 35, 56, 0.7); /* Opaque version of --bg */

      --text: #D1D5DB;
      --text-strong: #FFFFFF;
      --text-muted: #9CA3AF;
      --accent: #a78bfa; /* Lighter Purple accent */
      --success: #10B981;
      --warning: #F59E0B;
      --danger: #EF4444;

      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --rounded-lg: 0.5rem;
      --rounded-xl: 0.75rem;
    }

    /* --- 2. Base & Reset --- */
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body {
      font-family: var(--font-sans);
      background-color: var(--bg);
      color: var(--text);
      line-height: 1.6;
      font-size: 14px;
    }

    h1, h2, h3 {
      color: var(--text-strong);
      font-weight: 600;
      line-height: 1.3;
    }

    h1 { font-size: 1.5rem; }
    h2 { font-size: 1.125rem; }
    h3 { font-size: 1rem; }
    
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    /* --- 3. Utility & Glassmorphism --- */
    
    /* Glass Card Style */
    .card {
      background: var(--card-glass);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: var(--rounded-xl);
      border: 1px solid var(--border-glass);
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }
    
    /* Glass KPI Badge */
    .kpi-badge {
      background: var(--card-glass);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid var(--border-glass);
      flex: 1;
      min-width: 200px;
      padding: 1rem 1.25rem;
      border-radius: var(--rounded-lg);
      border-left: 4px solid; /* This is set by JS */
    }

    /* Text Button Style */
    .text-btn {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.5rem 0.75rem;
      font-size: 0.875rem;
      font-weight: 500;
      border-radius: var(--rounded-lg);
      transition: all 150ms ease-in-out;
    }
    .text-btn:hover {
      color: var(--text-strong);
      background-color: var(--card-glass);
    }
    .text-btn:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
      color: var(--text-strong);
    }
    
    .btn-danger-outline {
      color: var(--danger);
      background-color: transparent;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      opacity: 0.6;
      border: 1px solid var(--danger);
      border-radius: var(--rounded-lg);
    }
    .btn-danger-outline:hover { background-color: rgba(239, 68, 68, 0.1); opacity: 1; }

    .input-base, .select-base {
      background-color: rgba(0,0,0,0.2); /* Darker input bg */
      border: 1px solid var(--border-glass);
      color: var(--text);
      font-family: var(--font-sans);
      font-size: 0.875rem;
      border-radius: var(--rounded-lg);
      padding: 0.5rem 0.75rem;
      width: 100%;
    }
    .input-base:focus, .select-base:focus {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
      border-color: var(--accent);
    }
    
    .table-input {
      background: transparent;
      border: none;
      color: var(--text);
      font-family: var(--font-sans);
      font-size: 0.875rem;
      padding: 0.5rem 0.75rem;
      width: 100%;
      height: 100%;
      border-radius: 4px;
    }
    .table-input:focus {
      outline: 2px solid var(--accent);
      background-color: rgba(0,0,0,0.3);
      color: var(--text-strong);
    }
    
    .chip {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 0.5rem;
      vertical-align: middle;
    }
    
    .kpi-badge .label {
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--text-muted);
      margin-bottom: 0.25rem;
    }
    .kpi-badge .value {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-strong);
    }
    .kpi-badge .sub-value {
      font-size: 0.875rem;
      color: var(--text);
    }
    
    .text-success { color: var(--success); }
    .text-danger { color: var(--danger); }
    .text-warning { color: var(--warning); }
    .text-muted { color: var(--text-muted); }
    .text-strong { color: var(--text-strong); }
    
    .validation-error {
      font-size: 0.75rem;
      color: var(--danger);
      padding-left: 0.75rem;
      display: none; /* Shown by JS */
    }

    /* --- 4. Page Layout --- */
    .page-header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      padding: 1.5rem 2rem;
      min-height: 70px; /* Reserve space for removed header */
      border-bottom: 1px solid var(--border-glass);
    }

    .main-container {
      display: grid;
      grid-template-columns: 1fr; /* Single column layout */
      gap: 2rem;
      padding: 2rem 2rem;
    }
    
    #kpi-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
    }
    
    #visualization-container {
      display: grid;
      grid-template-columns: 60fr 40fr;
      gap: 1.5rem;
    }
    
    /* Updated Actions Container */
    #bottom-actions {
      display: flex;
      justify-content: center; /* Centered */
      align-items: center;
      gap: 1.5rem; /* Spaced out */
      padding: 1rem 0;
      border-top: 1px solid var(--border-glass);
      margin-top: 1rem;
    }

    .page-footer {
      text-align: center;
      padding: 1rem 2rem;
      font-size: 0.75rem;
      color: var(--text-muted);
      border-top: 1px solid var(--border-glass);
      margin-top: 1.5rem;
    }

    /* --- 5. Components --- */
    
    /* Scenario Table */
    #scenario-table-wrapper {
      flex-grow: 1;
      overflow: auto;
      border: 1px solid var(--border-glass);
      border-radius: var(--rounded-xl);
    }
    
    #scenario-table {
      width: 100%;
      min-width: 900px;
      border-collapse: collapse;
      font-size: 0.875rem;
    }
    
    #scenario-table th,
    #scenario-table td {
      padding: 0;
      border: 1px solid var(--border-glass);
      vertical-align: middle;
      height: 44px;
    }
    
    #scenario-table th {
      background-color: var(--table-cell-bg);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      padding: 0.75rem;
      text-align: left;
      font-weight: 600;
      color: var(--text-strong);
    }
    
    #scenario-table td {
      background-color: var(--table-cell-bg);
      padding: 0;
      text-align: right;
    }
    
    /* Sticky Header & Column */
    #scenario-table thead th {
      position: sticky;
      top: 0;
      z-index: 2;
      background-color: var(--sticky-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #scenario-table tbody tr td:first-child {
      position: sticky;
      left: 0;
      z-index: 1;
      background-color: var(--sticky-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #scenario-table thead th:first-child {
      z-index: 3;
    }

    #scenario-table .metric-name {
      text-align: left;
      font-weight: 500;
      padding: 0.5rem 0.75rem;
      white-space: nowrap;
      cursor: help;
    }
    #scenario-table .metric-name span {
      border-bottom: 1px dashed var(--text-muted);
    }
    
    #scenario-table .notes {
      text-align: left;
      padding: 0.5rem 0.75rem;
      color: var(--text-muted);
      font-size: 0.8125rem;
      min-width: 200px;
    }
    
    #scenario-table .output-cell {
      padding: 0.5rem 0.75rem;
      font-weight: 500;
    }
    
    #scenario-table tr.section-header td {
      background-color: rgba(0,0,0,0.2);
      color: var(--text-muted);
      font-size: 0.7rem;
      font-weight: 600;
      padding: 0.5rem 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      position: sticky;
      left: 0;
    }
    
    /* Scenario Header Inputs */
    .scenario-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0;
    }
    .scenario-header input {
      flex-grow: 1;
      background: transparent;
      border: none;
      color: var(--text-strong);
      font-weight: 600;
      font-size: 0.875rem;
      padding: 0.75rem;
      border-radius: 4px;
    }
    .scenario-header input:focus {
      outline: 2px solid var(--accent);
      background-color: rgba(0,0,0,0.3);
    }
    .scenario-header .actions {
      padding-right: 0.5rem;
    }
    .scenario-header .actions button {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 2px;
      border-radius: 4px;
    }
    .scenario-header .actions button:hover {
      background-color: var(--border-glass);
      color: var(--text-strong);
    }
    
    #add-scenario-btn {
      width: 100%;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-weight: 500;
      cursor: pointer;
      padding: 0.75rem;
    }
    #add-scenario-btn:hover {
      background-color: var(--border-glass);
      color: var(--text-strong);
    }
    #add-scenario-btn:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }

    /* Visualization Panel */
    .viz-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }
    .viz-controls .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .control-group label {
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-muted);
    }
    .scenario-visibility {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      padding-top: 0.5rem;
    }
    .scenario-visibility label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      cursor: pointer;
    }
    .scenario-visibility input[type="checkbox"] {
      accent-color: var(--accent);
    }
    
    .chart-wrapper {
      padding: 0 1rem 1rem;
      height: 350px;
      position: relative;
    }

    /* Custom Tooltip */
    #custom-tooltip {
      display: none;
      position: fixed;
      z-index: 1000;
      background: #111827; /* Dark, solid bg */
      color: var(--text);
      border: 1px solid var(--accent);
      border-radius: var(--rounded-lg);
      padding: 0.75rem 1rem;
      font-size: 0.875rem;
      max-width: 300px;
      box-shadow: var(--shadow-lg);
      pointer-events: none; /* Don't let it block other hovers */
      transition: opacity 100ms ease-in-out;
      opacity: 0.95;
    }

    /* Info Modal */
    #info-modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(5px);
    }
    .modal-content {
      background: var(--sticky-bg); /* Glass modal */
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      margin: 10vh auto;
      padding: 2rem;
      border: 1px solid var(--border-glass);
      border-radius: var(--rounded-xl);
      width: 90%;
      max-width: 700px;
      box-shadow: var(--shadow-lg);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border-glass);
      padding-bottom: 1rem;
      margin-bottom: 1.5rem;
    }
    .modal-close {
      color: var(--text-muted);
      font-size: 1.5rem;
      font-weight: bold;
      cursor: pointer;
      line-height: 1;
    }
    .modal-close:hover,
    .modal-close:focus {
      color: var(--text-strong);
    }
    #info-modal h2 { margin-bottom: 1rem; }
    #info-modal h3 { 
      margin-top: 1.5rem; 
      margin-bottom: 0.5rem;
      border-bottom: 1px solid var(--border-glass);
      padding-bottom: 0.25rem;
      color: var(--accent);
    }
    #info-modal ul { list-style: none; padding-left: 0; }
    #info-modal li { 
      margin-bottom: 0.75rem;
      padding: 0.5rem;
      background: rgba(0,0,0,0.2); /* Darker li */
      border-radius: var(--rounded-lg);
    }
    #info-modal code {
      font-family: monospace;
      background: var(--border-glass);
      padding: 0.1em 0.4em;
      border-radius: 4px;
      color: var(--text-strong);
    }

    /* Self-Test Banner */
    #self-test-banner {
      display: none;
      background-color: var(--danger);
      color: white;
      text-align: center;
      font-weight: 600;
      padding: 0.75rem;
    }

    /* --- 6. Responsive Design --- */
    @media (max-width: 920px) {
      .main-container {
        padding: 1rem;
      }
      .page-header {
        padding: 1rem;
        min-height: 0;
      }
      .kpi-badge {
        min-width: 100%; /* Stack KPIs */
      }
      #visualization-container {
        grid-template-columns: 1fr; /* Stack charts */
      }
      .viz-controls {
        grid-template-columns: 1fr; /* Stack chart controls */
      }
      #bottom-actions {
        flex-wrap: wrap;
      }
    }
    
    @media (max-width: 640px) {
      .chart-wrapper {
        height: 300px;
      }
    }

  </style>
</head>

<body>

  <div id="self-test-banner"></div>

  <header class="page-header">
    <div class="header-title">
      </div>
  </header>

  <main class="main-container">

    <div id="kpi-badges">
      </div>
    
    <div id="scenario-table-wrapper" class="card">
      <table id="scenario-table">
        <thead>
          <tr id="scenario-header-row">
            </tr>
        </thead>
        <tbody id="scenario-body">
          </tbody>
      </table>
    </div>

    <div id="visualization-container">
      
      <div id="line-chart-panel" class="card">
        <div style="padding: 1.5rem 1.5rem 1rem;">
          <h2>Metric vs. Variable</h2>
          <div class="viz-controls" style="margin-top: 1rem;">
            <div class="control-group">
              <label for="x-axis-select">X-Axis Variable</label>
              <select id="x-axis-select" class="select-base">
                <option value="spend">Daily Ad Spend (SGD)</option>
                <option value="cpc">Est. Cost Per Click (CPC, SGD)</option>
                <option value="cvr">Click→Lead CVR (%)</option>
                <option value="close">Lead→Sale Closing Rate (%)</option>
                <option value="aov">Average Order Value (AOV, SGD)</option>
              </select>
            </div>
            <div class="control-group">
              <label for="y-axis-select">Y-Axis Metric</label>
              <select id="y-axis-select" class="select-base">
                <option value="profit">Profit (Daily)</option>
                <option value="roas">ROAS (×)</option>
                <option value="cac">CAC / CPA</option>
                <option value="cpl">CPL (Cost per Lead)</option>
              </select>
            </div>
          </div>
          <div id="scenario-visibility-wrapper" class="scenario-visibility" style="margin-top: 1rem; padding: 0 1.5rem;">
            </div>
        </div>
        <div class="chart-wrapper">
          <canvas id="line-chart"></canvas>
        </div>
      </div>
      
      <div id="sensitivity-panel" class="card">
        <div style="padding: 1.5rem 1.5rem 1rem;">
          <h2>Sensitivity Analysis (±10%)</h2>
          <div class="control-group" style="margin-top: 1rem;">
            <label for="sensitivity-select">Sensitivity Analysis For:</label>
            <select id="sensitivity-select" class="select-base">
              </select>
          </div>
          <p class="text-muted" style="font-size: 0.8125rem; margin-top: 0.5rem;">
            Impact on <strong>Daily Profit</strong> from a ±10% change in each input.
          </p>
        </div>
        <div class="chart-wrapper">
          <canvas id="bar-chart"></canvas>
        </div>
      </div>
    </div>
    
    <div id="bottom-actions">
      <button id="reset-btn" class="text-btn">Reset</button>
      <button id="csv-btn" class="text-btn">Export CSV</button>
      <button id="png-btn" class="text-btn">Export PNG</button>
      <button id="info-btn" class="text-btn">Info</button>
    </div>

  </main>

  <footer class="page-footer">
    </footer>
  
  <div id="info-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Glossary & Formulas</h2>
        <span class="modal-close" id="modal-close-btn">&times;</span>
      </div>
      <div class="modal-body">
        <h3>Color Legend</h3>
        <ul>
          <li><span style="color:var(--success)">■ Green:</span> Indicates positive daily profit or ROAS ≥ 1.</li>
          <li><span style="color:var(--danger)">■ Red:</span> Indicates negative daily profit or ROAS < 1.</li>
        </ul>
        
        <h3>Metric Definitions</h3>
        <ul>
          <li><strong>Daily Ad Spend (SGD):</strong> Total budget per day.</li>
          <li><strong>Est. Cost Per Click (CPC, SGD):</strong> Average cost per ad click.</li>
          <li><strong>Click→Lead CVR (%):</strong> Percentage of clicks that convert to a lead (e.g., form submit).</li>
          <li><strong>Lead→Sale Closing Rate (%):</strong> Percentage of leads that become paying customers.</li>
          <li><strong>Average Order Value (AOV, SGD):</strong> Average revenue per customer transaction.</li>
          <li><strong>LTV Multiplier (×):</strong> Customer lifetime value multiplier. (1.00 = transactional, 1.50 = 50% more value over lifetime).</li>
          <li><strong>Variable Cost %:</strong> Cost of goods sold (COGS) + payment processing fees, as a % of revenue.</li>
        </ul>
        
        <h3>Calculations</h3>
        <ul>
          <li><code>Clicks</code> = Spend / CPC</li>
          <li><code>Leads</code> = Clicks × CVR</li>
          <li><code>CPL</code> = Spend / Leads</li>
          <li><code>Sales</code> = Leads × Closing Rate</li>
          <li><code>CAC / CPA</code> = Spend / Sales</li>
          <li><code>Revenue (initial)</code> = Sales × AOV</li>
          <li><code>Revenue (LTV-adj)</code> = Revenue (initial) × LTV Multiplier</li>
          <li><code>Gross Profit</code> = Revenue (LTV-adj) × (1 - Variable Cost %)</li>
          <li><code>Profit per Customer</code> = (AOV × LTV × (1 - Var%)) - CAC</li>
          <li><code>Profit (Daily)</code> = Gross Profit - Spend</li>
          <li><code>ROAS (×)</code> = Revenue (LTV-adj) / Spend</li>
          <li><code>Monthly Spend</code> = Spend × 30</li>
          <li><code>Monthly Revenue</code> = Revenue (LTV-adj) × 30</li>
          <li><code>Monthly Profit</code> = Profit (Daily) × 30</li>
        </ul>
        
        <h3>Break-Even Thresholds</h3>
        <ul>
          <li><strong>Break-Even CPC:</strong> Max CPC to break even (ROAS=1).<br><code>AOV × LTV × CVR × Closing Rate</code></li>
          <li><strong>Break-Even CVR:</strong> Min CVR to break even.<br><code>CPC / (AOV × LTV × Closing Rate)</code></li>
          <li><strong>Break-Even Closing Rate:</strong> Min Closing Rate to break even.<br><code>CPC / (AOV × LTV × CVR)</code></li>
        </ul>
      </div>
    </div>
  </div>
  
  <div id="custom-tooltip"></div>
  

  <script>
    document.addEventListener('DOMContentLoaded', () => {

      // --- 1. STATE MANAGEMENT ---

      const STORAGE_KEY = 'reputifly_roas_state_v1';
      const MAX_SCENARIOS = 3; // Updated as per request

      const DEFAULT_INPUTS = {
        worst:  { spend: 150, cpc: 6.00, cvr: 0.08, close: 0.10, aov: 700, ltv: 1.00, varPct: 0.00 },
        real:   { spend: 150, cpc: 4.50, cvr: 0.15, close: 0.20, aov: 700, ltv: 1.00, varPct: 0.00 },
        best:   { spend: 150, cpc: 3.50, cvr: 0.20, close: 0.40, aov: 700, ltv: 1.00, varPct: 0.00 },
      };
      
      // Use colors from screenshot/request
      const SCENARIO_COLORS = ['#EF4444', '#3B82F6', '#10B981']; 
      
      const DEFAULT_STATE = {
        scenarios: [
          { id: 'worst', name: 'Worst Scenario', color: SCENARIO_COLORS[0], inputs: DEFAULT_INPUTS.worst },
          { id: 'real', name: 'Realistic Scenario', color: SCENARIO_COLORS[1], inputs: DEFAULT_INPUTS.real },
          { id: 'best', name: 'Best Scenario', color: SCENARIO_COLORS[2], inputs: DEFAULT_INPUTS.best },
        ],
        viz: {
          xAxis: 'spend',
          yAxis: 'profit',
          sensitivityScenarioId: 'real',
          visibleScenarioIds: ['worst', 'real', 'best']
        }
      };

      let state = loadState();
      
      let computedMetricsCache = new Map();
      let lineChart, barChart;
      let TOOLTIP_DEFINITIONS = {}; // For custom tooltips
      
      const dom = {
        headerRow: document.getElementById('scenario-header-row'),
        tableBody: document.getElementById('scenario-body'),
        kpiWrapper: document.getElementById('kpi-badges'),
        
        xAxisSelect: document.getElementById('x-axis-select'),
        yAxisSelect: document.getElementById('y-axis-select'),
        sensitivitySelect: document.getElementById('sensitivity-select'),
        visibilityWrapper: document.getElementById('scenario-visibility-wrapper'),
        lineChartCanvas: document.getElementById('line-chart'),
        barChartCanvas: document.getElementById('bar-chart'),
        
        resetBtn: document.getElementById('reset-btn'),
        csvBtn: document.getElementById('csv-btn'),
        pngBtn: document.getElementById('png-btn'),
        infoBtn: document.getElementById('info-btn'),
        modal: document.getElementById('info-modal'),
        modalCloseBtn: document.getElementById('modal-close-btn'),
        selfTestBanner: document.getElementById('self-test-banner'),
        tooltip: document.getElementById('custom-tooltip'),
      };

      
      // --- 2. CORE COMPUTATION LOGIC ---

      function computeMetrics({ spend, cpc, cvr, close, aov, ltv, varPct }) {
        const safeSpend = Math.max(spend, 0);
        const safeCpc = Math.max(cpc, 1e-9);
        const safeAov = Math.max(aov, 0);
        
        const clicks = safeSpend / safeCpc;
        const leads = clicks * cvr;
        const safeLeads = Math.max(leads, 1e-9);
        const cpl = safeSpend / safeLeads;
        const sales = leads * close;
        const safeSales = Math.max(sales, 1e-9);
        const cac = safeSpend / safeSales;
        
        const rev0 = sales * safeAov;
        const rev = rev0 * ltv;
        const gross = rev * (1 - varPct);
        const profit = gross - safeSpend;
        const roas = rev / Math.max(safeSpend, 1e-9);

        const cpcBE = safeAov * ltv * cvr * close;
        const cvrBE = safeCpc / Math.max(safeAov * ltv * close, 1e-9);
        const closeBE = safeCpc / Math.max(safeAov * ltv * cvr, 1e-9);
        
        const profitPerCustomer = (safeAov * ltv * (1 - varPct)) - cac;

        return {
          clicks, leads, cpl, sales, cac, rev0, rev, gross, profit, roas, 
          profitPerCustomer, cpcBE, cvrBE, closeBE,
          monthlySpend: safeSpend * 30,
          monthlyRevenue: rev * 30,
          monthlyProfit: profit * 30,
          monthlyRoas: roas
        };
      }
      
      function updateAllMetrics() {
        computedMetricsCache.clear();
        for (const scenario of state.scenarios) {
          computedMetricsCache.set(scenario.id, computeMetrics(scenario.inputs));
        }
      }

      
      // --- 3. HELPER FUNCTIONS (Formatters, Utils) ---

      function fmtCurrency(n) {
        if (isNaN(n) || !isFinite(n)) return '$0.00';
        const val = Number(n);
        const sign = val < 0 ? '-' : '';
        return sign + '$' + Math.abs(val).toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      }

      function fmtPercent(p, decimals = 2) {
        if (isNaN(p) || !isFinite(p)) return '0.00%';
        return (Number(p) * 100).toFixed(decimals) + '%';
      }

      function fmtMult(x) {
        if (isNaN(x) || !isFinite(x)) return '×1.00';
        return '×' + Number(x).toFixed(2);
      }
      
      function fmtNumber(n, decimals = 2) {
        if (isNaN(n) || !isFinite(n)) return '0.00';
        return Number(n).toFixed(decimals).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      }
      
      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }
      
      function parseAsNumber(value) {
        return parseFloat(String(value).replace(/[^0-9.-]+/g,"")) || 0;
      }
      
      function parseAsPercent(value) {
        return parseAsNumber(value) / 100;
      }
      
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      
      // --- 4. STATE PERSISTENCE ---

      function loadState(forceDefaults = false) {
        if (forceDefaults) {
          return JSON.parse(JSON.stringify(DEFAULT_STATE));
        }
        try {
          const serializedState = localStorage.getItem(STORAGE_KEY);
          if (serializedState === null) {
            return JSON.parse(JSON.stringify(DEFAULT_STATE));
          }
          const loadedState = JSON.parse(serializedState);
          // Ensure colors are correct on load
          loadedState.scenarios.forEach((s, i) => {
            s.color = SCENARIO_COLORS[i % SCENARIO_COLORS.length];
          });
          // Enforce max 3 scenarios
          if (loadedState.scenarios.length > MAX_SCENARIOS) {
            loadedState.scenarios = loadedState.scenarios.slice(0, MAX_SCENARIOS);
          }
          return loadedState;
        } catch (e) {
          console.error("Could not load state from localStorage", e);
          return JSON.parse(JSON.stringify(DEFAULT_STATE));
        }
      }

      const debouncedSave = debounce(() => {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch (e) {
          console.error("Could not save state to localStorage", e);
        }
      }, 400);

      
      // --- 5. RENDER FUNCTIONS ---
      
      function render() {
        updateAllMetrics();
        renderTable();
        renderKpiBadges();
        renderChartControls();
        updateCharts();
      }
      
      function renderKpiBadges() {
        dom.kpiWrapper.innerHTML = '';
        state.scenarios.forEach((scenario, i) => {
          const metrics = computedMetricsCache.get(scenario.id);
          if (!metrics) return;
          
          const profitClass = metrics.profit >= 0 ? 'text-success' : 'text-danger';
          const color = scenario.color || SCENARIO_COLORS[i];
          
          const badge = document.createElement('div');
          badge.className = 'kpi-badge';
          badge.style.borderColor = color;
          badge.innerHTML = `
            <div class="label" style="color: ${color}">${scenario.name}</div>
            <div class="value ${profitClass}">${fmtCurrency(metrics.profit)}/day</div>
            <div class="sub-value">
              <strong>ROAS:</strong> ${fmtMult(metrics.roas)} |
              <strong>CAC:</strong> ${fmtCurrency(metrics.cac)} |
              <strong>CPL:</strong> ${fmtCurrency(metrics.cpl)}
            </div>
          `;
          dom.kpiWrapper.appendChild(badge);
        });
      }

      function renderTable() {
        renderTableHeader();
        renderTableBody();
      }

      function renderTableHeader() {
        dom.headerRow.innerHTML = '';
        
        // 1. Metric Column
        dom.headerRow.appendChild(document.createElement('th')).textContent = 'Metric';
        
        // 2. Scenario Columns
        state.scenarios.forEach((scenario, index) => {
          const th = document.createElement('th');
          th.style.minWidth = '220px';
          
          const headerDiv = document.createElement('div');
          headerDiv.className = 'scenario-header';
          
          const chip = document.createElement('span');
          chip.className = 'chip';
          chip.style.backgroundColor = scenario.color;
          headerDiv.appendChild(chip);
          
          const input = document.createElement('input');
          input.type = 'text';
          input.value = scenario.name;
          input.setAttribute('aria-label', `Scenario name: ${scenario.name}`);
          input.onchange = (e) => {
            scenario.name = e.target.value;
            render();
            debouncedSave();
          };
          headerDiv.appendChild(input);
          
          const actions = document.createElement('div');
          actions.className = 'actions';
          
          const delBtn = document.createElement('button');
          delBtn.innerHTML = '&times;';
          delBtn.title = 'Delete scenario';
          delBtn.className = 'btn-danger-outline';
          if (state.scenarios.length <= 1) delBtn.disabled = true; // Min 1 scenario
          delBtn.onclick = () => handleDeleteScenario(scenario.id);
          actions.appendChild(delBtn);
          
          headerDiv.appendChild(actions);
          th.appendChild(headerDiv);
          dom.headerRow.appendChild(th);
        });
        
        // 3. Add Scenario Button Column
        const addTh = document.createElement('th');
        if (state.scenarios.length < MAX_SCENARIOS) { // Only show button if < 3
          const addBtn = document.createElement('button');
          addBtn.id = 'add-scenario-btn';
          addBtn.textContent = '+ Add Scenario';
          addBtn.onclick = handleAddScenario;
          addTh.appendChild(addBtn);
        }
        dom.headerRow.appendChild(addTh);

        // 4. Notes Column
        const notesTh = document.createElement('th');
        notesTh.textContent = 'Notes / Formula';
        notesTh.style.minWidth = '250px';
        dom.headerRow.appendChild(notesTh);
      }
      
      const METRIC_ROWS_CONFIG = [
        { type: 'section', label: 'Campaign Inputs' },
        { label: 'Daily Ad Spend (SGD)', key: 'spend', type: 'input-currency', note: 'Total budget per day', min: 0 },
        { label: 'Est. Cost Per Click (CPC, SGD)', key: 'cpc', type: 'input-currency', note: 'Average cost per ad click', min: 0.01 },
        { label: 'Click→Lead CVR (%)', key: 'cvr', type: 'input-percent', note: '% of clicks that convert to a lead (form submit)', min: 0.002, max: 0.50, decimals: 2, title: 'Percentage of clicks that convert to a lead (e.g., form submit).' },
        { label: 'Lead→Sale Closing Rate (%)', key: 'close', type: 'input-percent', note: '% of leads that become paying customers', min: 0.01, max: 0.90, decimals: 2, title: 'Percentage of leads that become paying customers.' },
        { label: 'Average Order Value (AOV, SGD)', key: 'aov', type: 'input-currency', note: 'Average revenue per customer', min: 0, title: 'Average revenue per customer transaction.' },
        { label: 'LTV Multiplier (×)', key: 'ltv', type: 'input-number', note: 'Customer lifetime value multiplier', min: 1.00, max: 3.00, decimals: 2, title: 'Customer lifetime value multiplier. (1.00 = transactional, 1.50 = 50% more value over lifetime).' },
        { label: 'Variable Cost %', key: 'varPct', type: 'input-percent', note: 'Cost of goods sold plus payment processing fees', min: 0.00, max: 0.80, decimals: 2, title: 'Cost of goods sold (COGS) + payment processing fees, as a % of revenue.' },

        { type: 'section', label: 'Daily Calculations' },
        { label: 'Clicks', key: 'clicks', type: 'output-number', note: 'Spend / CPC', decimals: 2, title: 'Calculated as: Daily Ad Spend / Est. Cost Per Click' },
        { label: 'Leads', key: 'leads', type: 'output-number', note: 'Clicks × CVR', decimals: 2, title: 'Calculated as: Clicks × Click→Lead CVR' },
        { label: 'CPL (Cost per Lead)', key: 'cpl', type: 'output-currency', note: 'Spend / Leads', title: 'Calculated as: Daily Ad Spend / Leads. This is the cost to acquire one lead.' },
        { label: 'Sales (Customers)', key: 'sales', type: 'output-number', note: 'Leads × Closing Rate', decimals: 2, title: 'Calculated as: Leads × Lead→Sale Closing Rate. This is the number of new customers.' },
        { label: 'CAC / CPA', key: 'cac', type: 'output-currency', note: 'Spend / Sales', title: 'Customer Acquisition Cost (or Cost Per Acquisition). Calculated as: Daily Ad Spend / Sales.' },

        { type: 'section', label: 'Daily Performance' },
        { label: 'Revenue (initial)', key: 'rev0', type: 'output-currency', note: 'Sales × AOV', title: 'Initial transactional revenue. Calculated as: Sales × Average Order Value.' },
        { label: 'Revenue (LTV-adj)', key: 'rev', type: 'output-currency', note: 'Revenue (initial) × LTV Multiplier', title: 'Lifetime Value (LTV) adjusted revenue. Calculated as: Revenue (initial) × LTV Multiplier.' },
        { label: 'Gross Profit', key: 'gross', type: 'output-currency', note: 'Revenue (LTV-adj) × (1 - Variable Cost %)', title: 'Revenue after variable costs (COGS). Calculated as: Revenue (LTV-adj) × (1 - Variable Cost %).' },
        { label: 'Profit per Customer', key: 'profitPerCustomer', type: 'output-currency', note: '(AOV × LTV × (1 - Var%)) - CAC', colorClass: true, title: 'Profitability of a single customer. Calculated as: (AOV × LTV × (1 - Var%)) - CAC.' },
        { label: 'Profit (Daily)', key: 'profit', type: 'output-currency', note: 'Gross Profit - Spend', colorClass: true, isProfit: true, title: 'Net profit per day. Calculated as: Gross Profit - Daily Ad Spend.' },
        { label: 'ROAS (×)', key: 'roas', type: 'output-mult', note: 'Revenue (LTV-adj) / Spend', colorClass: true, isRoas: true, title: 'Return On Ad Spend (LTV-adjusted). Calculated as: Revenue (LTV-adj) / Daily Ad Spend.' },

        { type: 'section', label: 'Monthly Rollover (30 days)' },
        { label: 'Monthly Spend', key: 'monthlySpend', type: 'output-currency', note: 'Spend × 30', title: 'Projected ad spend over 30 days.' },
        { label: 'Monthly Revenue (LTV-adj)', key: 'monthlyRevenue', type: 'output-currency', note: 'Revenue (LTV-adj) × 30', title: 'Projected LTV-adjusted revenue over 30 days.' },
        { label: 'Monthly Profit', key: 'monthlyProfit', type: 'output-currency', note: 'Profit (Daily) × 30', colorClass: true, isProfit: true, title: 'Projected net profit over 30 days.' },
        { label: 'ROAS (Monthly)', key: 'monthlyRoas', type: 'output-mult', note: 'Same as daily ROAS', colorClass: true, isRoas: true, title: 'ROAS is a ratio, so it remains the same for daily and monthly projections.' },

        { type: 'section', label: 'Break-Even Thresholds' },
        { label: 'Break-Even CPC', key: 'cpcBE', type: 'output-currency', note: 'AOV × LTV × CVR × Closing', title: 'Max CPC you can afford at current CVR/Closing/AOV/LTV to break even (ROAS = 1).' },
        { label: 'Break-Even CVR (%)', key: 'cvrBE', type: 'output-percent', note: 'CPC / (AOV × LTV × Closing)', title: 'Min CVR you need at current CPC/Closing/AOV/LTV to break even (ROAS = 1).', decimals: 3 },
        { label: 'Break-Even Closing Rate (%)', key: 'closeBE', type: 'output-percent', note: 'CPC / (AOV × LTV × CVR)', title: 'Min Closing Rate you need at current CPC/CVR/AOV/LTV to break even (ROAS = 1).', decimals: 3 },
      ];
      
      function buildTooltipDefinitions() {
        TOOLTIP_DEFINITIONS = {};
        for (const config of METRIC_ROWS_CONFIG) {
            if (config.key) {
                TOOLTIP_DEFINITIONS[config.key] = config.title || config.note;
            }
        }
      }

      function renderTableBody() {
        dom.tableBody.innerHTML = '';
        
        for (const config of METRIC_ROWS_CONFIG) {
          const tr = document.createElement('tr');
          
          if (config.type === 'section') {
            tr.className = 'section-header';
            const td = document.createElement('td');
            td.colSpan = state.scenarios.length + 3;
            td.textContent = config.label;
            tr.appendChild(td);
            dom.tableBody.appendChild(tr);
            continue;
          }

          // 1. Metric Name Cell
          const metricTd = document.createElement('td');
          metricTd.className = 'metric-name';
          metricTd.dataset.tooltipKey = config.key; // For custom tooltip
          const metricSpan = document.createElement('span');
          metricSpan.textContent = config.label;
          metricTd.appendChild(metricSpan);
          tr.appendChild(metricTd);
          
          // 2. Scenario Value Cells
          for (const scenario of state.scenarios) {
            const metrics = computedMetricsCache.get(scenario.id);
            if (!metrics) continue;

            const td = document.createElement('td');
            
            if (config.type.startsWith('input-')) {
              createInputCell(td, scenario, config);
            } else {
              createOutputCell(td, metrics, config);
            }
            tr.appendChild(td);
          }
          
          // 3. Add Scenario "cell" (empty)
          tr.appendChild(document.createElement('td'));

          // 4. Notes Cell
          const notesTd = document.createElement('td');
          notesTd.className = 'notes';
          notesTd.textContent = config.note;
          tr.appendChild(notesTd);
          
          dom.tableBody.appendChild(tr);
        }
      }

      function createInputCell(td, scenario, config) {
        const wrapper = document.createElement('div');
        const input = document.createElement('input');
        input.className = 'table-input';
        
        let displayValue;
        const rawValue = scenario.inputs[config.key];
        
        if (config.type === 'input-percent') {
          displayValue = (rawValue * 100).toFixed(config.decimals || 2);
          input.type = 'number';
          input.step = '0.01';
        } else if (config.type === 'input-currency') {
          displayValue = rawValue.toFixed(2);
          input.type = 'number';
          input.step = '0.01';
        } else { // input-number
          displayValue = rawValue.toFixed(config.decimals || 2);
          input.type = 'number';
          input.step = '0.01';
        }
        input.value = displayValue;
        
        const errorSpan = document.createElement('span');
        errorSpan.className = 'validation-error';
        
        const validateAndSave = (e) => {
          let value = parseAsNumber(e.target.value);
          
          if (config.type === 'input-percent') {
            value = value / 100; // Convert from 15(%) to 0.15
          }

          if (config.min !== undefined) value = Math.max(config.min, value);
          if (config.max !== undefined) value = Math.min(config.max, value);
          
          scenario.inputs[config.key] = value;
          
          if (config.type === 'input-percent') {
            e.target.value = (value * 100).toFixed(config.decimals || 2);
          } else {
            e.target.value = value.toFixed(config.decimals || 2);
          }
          
          errorSpan.style.display = 'none';
          
          render();
          debouncedSave();
        };
        
        input.onblur = validateAndSave;
        input.onkeydown = (e) => {
          if (e.key === 'Enter') e.target.blur();
          if (e.key === 'Escape') {
            if (config.type === 'input-percent') {
              e.target.value = (scenario.inputs[config.key] * 100).toFixed(config.decimals || 2);
            } else {
              e.target.value = scenario.inputs[config.key].toFixed(config.decimals || 2);
            }
            e.target.blur();
          }
        };

        wrapper.appendChild(input);
        wrapper.appendChild(errorSpan);
        td.appendChild(wrapper);
      }
      
      function createOutputCell(td, metrics, config) {
        td.className = 'output-cell';
        const value = metrics[config.key];
        
        let formattedValue;
        if (config.type === 'output-currency') {
          formattedValue = fmtCurrency(value);
        } else if (config.type === 'output-percent') {
          formattedValue = fmtPercent(value, config.decimals);
        } else if (config.type === 'output-mult') {
          formattedValue = fmtMult(value);
        } else { // output-number
          formattedValue = fmtNumber(value, config.decimals);
        }
        td.textContent = formattedValue;
        
        if (config.colorClass) {
          let isPositive;
          if (config.isProfit) {
            isPositive = metrics.profit >= 0;
          } else if (config.isRoas) {
            isPositive = metrics.roas >= 1;
          } else {
            isPositive = value >= 0;
          }
          td.classList.toggle('text-success', isPositive);
          td.classList.toggle('text-danger', !isPositive);
        }
      }
      
      function renderChartControls() {
        // 1. Sensitivity Select
        dom.sensitivitySelect.innerHTML = '';
        state.scenarios.forEach(s => {
          const option = document.createElement('option');
          option.value = s.id;
          option.textContent = s.name;
          if (s.id === state.viz.sensitivityScenarioId) {
            option.selected = true;
          }
          dom.sensitivitySelect.appendChild(option);
        });
        
        // 2. Visibility Checkboxes
        dom.visibilityWrapper.innerHTML = '<label class="control-group-label">Visible Scenarios</label>';
        state.scenarios.forEach((s, i) => {
          const label = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = s.id;
          checkbox.checked = state.viz.visibleScenarioIds.includes(s.id);
          checkbox.onchange = handleVisibilityToggle;
          
          const chip = document.createElement('span');
          chip.className = 'chip';
          chip.style.backgroundColor = s.color || SCENARIO_COLORS[i];
          
          label.appendChild(checkbox);
          label.appendChild(chip);
          label.appendChild(document.createTextNode(s.name));
          dom.visibilityWrapper.appendChild(label);
        });
      }


      // --- 6. EVENT HANDLERS ---

      function handleAddScenario() {
        if (state.scenarios.length >= MAX_SCENARIOS) return;
        
        const lastScenario = state.scenarios[state.scenarios.length - 1];
        const newId = `scenario_${Date.now()}`;
        const newScenario = {
          id: newId,
          name: `Scenario ${state.scenarios.length + 1}`,
          color: SCENARIO_COLORS[state.scenarios.length % SCENARIO_COLORS.length],
          inputs: JSON.parse(JSON.stringify(lastScenario.inputs))
        };
        
        state.scenarios.push(newScenario);
        state.viz.visibleScenarioIds.push(newId);
        
        // Re-assign colors
        state.scenarios.forEach((s, i) => {
            s.color = SCENARIO_COLORS[i % SCENARIO_COLORS.length];
        });
        
        render();
        debouncedSave();
      }

      function handleDeleteScenario(id) {
        if (state.scenarios.length <= 1) return; // Don't delete the last one
        
        state.scenarios = state.scenarios.filter(s => s.id !== id);
        state.viz.visibleScenarioIds = state.viz.visibleScenarioIds.filter(vid => vid !== id);
        
        if (state.viz.sensitivityScenarioId === id) {
          state.viz.sensitivityScenarioId = state.scenarios[0].id;
        }
        
        // Re-assign colors
        state.scenarios.forEach((s, i) => {
            s.color = SCENARIO_COLORS[i % SCENARIO_COLORS.length];
        });
        
        render();
        debouncedSave();
      }
      
      function handleReset() {
        if (confirm('Are you sure you want to reset all scenarios to the default? This cannot be undone.')) {
          state = loadState(true);
          render();
          debouncedSave();
        }
      }
      
      function handleVisibilityToggle(e) {
        const id = e.target.value;
        if (e.target.checked) {
          if (!state.viz.visibleScenarioIds.includes(id)) {
            state.viz.visibleScenarioIds.push(id);
          }
        } else {
          state.viz.visibleScenarioIds = state.viz.visibleScenarioIds.filter(vid => vid !== id);
        }
        updateCharts();
        debouncedSave();
      }

      function handleChartControlsChange() {
        state.viz.xAxis = dom.xAxisSelect.value;
        state.viz.yAxis = dom.yAxisSelect.value;
        state.viz.sensitivityScenarioId = dom.sensitivitySelect.value;
        updateCharts();
        debouncedSave();
      }

      function handleExportCSV() {
        let csv = '';
        csv += 'Metric,';
        csv += state.scenarios.map(s => `"${s.name}"`).join(',') + ',Notes\n';
        
        for (const config of METRIC_ROWS_CONFIG) {
          if (config.type === 'section') {
            csv += `"${config.label}",` + ','.repeat(state.scenarios.length + 1) + '\n';
            continue;
          }
          csv += `"${config.label}",`;
          let values = [];
          for (const scenario of state.scenarios) {
            if (config.type.startsWith('input-')) {
              values.push(scenario.inputs[config.key]);
            } else {
              values.push(computedMetricsCache.get(scenario.id)[config.key]);
            }
          }
          csv += values.join(',') + `, "${config.note}"\n`;
        }
        csv += '\n\nChart Data\n';
        const chartData = getLineChartData();
        if (chartData) {
          csv += `"${dom.xAxisSelect.options[dom.xAxisSelect.selectedIndex].text}",`;
          csv += chartData.datasets.map(d => `"${d.label} (${dom.yAxisSelect.options[dom.yAxisSelect.selectedIndex].text})"`).join(',') + '\n';
          chartData.labels.forEach((label, i) => {
            let rawLabel = String(label).replace(/[$,%×]/g, '');
            csv += `${rawLabel},`;
            csv += chartData.datasets.map(d => d.data[i] || '').join(',') + '\n';
          });
        }
        
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'roas_scenario_lab_export.csv';
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      
      function handleExportPNG() {
        if (!lineChart) return;
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = lineChart.width;
        tempCanvas.height = lineChart.height;
        tempCtx.fillStyle = '#2B2338'; // Use new BG color
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        tempCtx.drawImage(lineChart.canvas, 0, 0);
        
        const dataUrl = tempCanvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = 'roas_scenario_chart.png';
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      
      function toggleModal(show) {
        dom.modal.style.display = show ? 'block' : 'none';
      }

      // --- Custom Tooltip Handlers ---
      
      function handleTooltipShow(e) {
        const target = e.target.closest('.metric-name');
        if (!target) return;
        
        const key = target.dataset.tooltipKey;
        const text = TOOLTIP_DEFINITIONS[key];
        
        if (!text) return;
        
        dom.tooltip.innerHTML = text; // Use innerHTML to render line breaks if any
        
        let x = e.clientX + 15;
        let y = e.clientY + 15;
        
        dom.tooltip.style.display = 'block'; // Show first to get dimensions
        
        // Prevent overflow
        if (x + dom.tooltip.offsetWidth > window.innerWidth - 10) {
          x = e.clientX - dom.tooltip.offsetWidth - 15;
        }
        if (y + dom.tooltip.offsetHeight > window.innerHeight - 10) {
          y = e.clientY - dom.tooltip.offsetHeight - 15;
        }
        
        dom.tooltip.style.left = x + 'px';
        dom.tooltip.style.top = y + 'px';
      }

      function handleTooltipHide(e) {
        dom.tooltip.style.display = 'none';
      }
      
      // --- 7. CHARTING LOGIC ---
      
      const CHART_COLORS = {
        grid: 'rgba(255, 255, 255, 0.1)',
        ticks: '#9CA3AF',
        text: '#D1D5DB',
        zeroLine: '#F59E0B',
        roasLine: '#F59E0B',
      };

      const debouncedChartUpdate = debounce(() => {
        const lineData = getLineChartData();
        const barData = getTornadoChartData();
        
        const yAxisLabel = dom.yAxisSelect.options[dom.yAxisSelect.selectedIndex].text;
        const xAxisLabel = dom.xAxisSelect.options[dom.xAxisSelect.selectedIndex].text;
        
        if (!lineChart) {
          const ctx = dom.lineChartCanvas.getContext('2d');
          lineChart = new Chart(ctx, {
            type: 'line',
            data: lineData,
            options: getLineChartOptions(yAxisLabel, xAxisLabel)
          });
        } else {
          lineChart.data = lineData;
          lineChart.options = getLineChartOptions(yAxisLabel, xAxisLabel);
          lineChart.update();
        }
        
        if (!barChart) {
          const ctx = dom.barChartCanvas.getContext('2d');
          barChart = new Chart(ctx, {
            type: 'bar',
            data: barData,
            options: getBarChartOptions()
          });
        } else {
          barChart.data = barData;
          barChart.options = getBarChartOptions();
          barChart.update();
        }
      }, 150);

      function updateCharts() {
        debouncedChartUpdate();
      }
      
      function getLineChartOptions(yAxisLabel, xAxisLabel) {
        const annotations = {};
        
        if (state.viz.yAxis === 'profit') {
          annotations.zeroLine = {
            type: 'line', yMin: 0, yMax: 0,
            borderColor: CHART_COLORS.zeroLine, borderWidth: 2, borderDash: [6, 6],
            label: { content: 'Profit = $0', display: true, position: 'start', backgroundColor: 'rgba(0,0,0,0.6)', font: { size: 10 }, color: CHART_COLORS.zeroLine }
          };
        } else if (state.viz.yAxis === 'roas') {
          annotations.roasLine = {
            type: 'line', yMin: 1, yMax: 1,
            borderColor: CHART_COLORS.roasLine, borderWidth: 2, borderDash: [6, 6],
            label: { content: 'ROAS = ×1.00', display: true, position: 'start', backgroundColor: 'rgba(0,0,0,0.6)', font: { size: 10 }, color: CHART_COLORS.roasLine }
          };
        }

        return {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              mode: 'index', intersect: false,
              callbacks: {
                label: (context) => {
                  let label = context.dataset.label || '';
                  if (label) label += ': ';
                  let value = context.parsed.y;
                  if (state.viz.yAxis === 'profit' || state.viz.yAxis === 'cac' || state.viz.yAxis === 'cpl') {
                    label += fmtCurrency(value);
                  } else if (state.viz.yAxis === 'roas') {
                    label += fmtMult(value);
                  } else {
                    label += fmtNumber(value);
                  }
                  return label;
                }
              }
            },
            annotation: { annotations: annotations }
          },
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: {
              title: { display: true, text: xAxisLabel, color: CHART_COLORS.text },
              grid: { color: CHART_COLORS.grid },
              ticks: { color: CHART_COLORS.ticks }
            },
            y: {
              title: { display: true, text: yAxisLabel, color: CHART_COLORS.text },
              grid: { color: CHART_COLORS.grid },
              ticks: { 
                color: CHART_COLORS.ticks,
                callback: (value) => {
                  if (state.viz.yAxis === 'profit' || state.viz.yAxis === 'cac' || state.viz.yAxis === 'cpl') return fmtCurrency(value);
                  if (state.viz.yAxis === 'roas') return fmtMult(value);
                  return value;
                }
              }
            }
          }
        };
      }
      
      function getBarChartOptions() {
        return {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: (context) => `Impact: ${fmtCurrency(context.raw)}`
              }
            }
          },
          scales: {
            x: {
              title: { display: true, text: 'Change in Daily Profit (SGD)', color: CHART_COLORS.text },
              grid: { color: CHART_COLORS.grid },
              ticks: { 
                color: CHART_COLORS.ticks,
                callback: (value) => fmtCurrency(value)
              }
            },
            y: {
              grid: { display: false },
              ticks: { color: CHART_COLORS.ticks }
            }
          }
        };
      }
      
      function getLineChartData() {
        const xVar = state.viz.xAxis;
        const yVar = state.viz.yAxis;
        const visibleScenarios = state.scenarios.filter(s => state.viz.visibleScenarioIds.includes(s.id));
        
        const datasets = [];
        let labels = [];
        const STEPS = 30;

        for (const [index, scenario] of visibleScenarios.entries()) {
          const data = [];
          const baseInputs = scenario.inputs;
          
          if (labels.length === 0) {
            if (xVar === 'spend') {
              const maxSpend = Math.max(...state.scenarios.map(s => s.inputs.spend), 150);
              const sweepMax = maxSpend * 2;
              for (let i = 0; i <= STEPS; i++) labels.push((sweepMax / STEPS) * i);
            } else {
              const refScenario = visibleScenarios[0];
              const baseValue = refScenario.inputs[xVar];
              let min, max;
              if (xVar === 'cvr') { min = 0.002; max = 0.5; }
              else if (xVar === 'close') { min = 0.01; max = 0.9; }
              else if (xVar === 'cpc') { min = 0.01; max = baseValue * 2 + 10; }
              else if (xVar === 'aov') { min = 20; max = baseValue * 2 + 100; }
              const sweepMin = clamp(baseValue * 0.5, min, max);
              const sweepMax = clamp(baseValue * 1.5, min, max);
              for (let i = 0; i <= STEPS; i++) {
                const val = sweepMin + (i * (sweepMax - sweepMin) / STEPS);
                labels.push(val);
              }
            }
          }
          
          for (const xValue of labels) {
            const tempInputs = { ...baseInputs, [xVar]: xValue };
            const metrics = computeMetrics(tempInputs);
            data.push(metrics[yVar]);
          }
          
          datasets.push({
            label: scenario.name,
            data: data,
            borderColor: scenario.color || SCENARIO_COLORS[index],
            backgroundColor: scenario.color || SCENARIO_COLORS[index],
            fill: false,
            tension: 0.1,
            pointRadius: 0,
            borderWidth: 3
          });
        }
        
        let formattedLabels;
        if (xVar === 'cvr' || xVar === 'close') {
          formattedLabels = labels.map(l => fmtPercent(l, 1));
        } else if (xVar === 'spend' || xVar === 'cpc' || xVar === 'aov') {
          formattedLabels = labels.map(l => fmtCurrency(l));
        } else {
          formattedLabels = labels.map(l => fmtNumber(l, 2));
        }

        return { labels: formattedLabels, datasets };
      }
      
      function getTornadoChartData() {
        let scenario = state.scenarios.find(s => s.id === state.viz.sensitivityScenarioId);
        if (!scenario) {
            scenario = state.scenarios[0];
            if (!scenario) return { labels: [], datasets: [] };
            state.viz.sensitivityScenarioId = scenario.id;
        }
        
        const baseMetrics = computedMetricsCache.get(scenario.id);
        if (!baseMetrics) return { labels: [], datasets: [] };
        const baseProfit = baseMetrics.profit;
        
        const factors = [
          { key: 'spend', label: 'Budget' }, { key: 'cpc',   label: 'CPC' },
          { key: 'cvr',   label: 'CVR' }, { key: 'close', label: 'Closing' },
          { key: 'aov',   label: 'AOV' },
        ];
        
        let deltas = [];
        for (const factor of factors) {
          const plusInputs = { ...scenario.inputs, [factor.key]: scenario.inputs[factor.key] * 1.1 };
          const deltaPlus = computeMetrics(plusInputs).profit - baseProfit;
          deltas.push({ label: `${factor.label} +10%`, value: deltaPlus });
          
          const minusInputs = { ...scenario.inputs, [factor.key]: scenario.inputs[factor.key] * 0.9 };
          const deltaMinus = computeMetrics(minusInputs).profit - baseProfit;
          deltas.push({ label: `${factor.label} -10%`, value: deltaMinus });
        }
        
        deltas.sort((a, b) => Math.abs(b.value) - Math.abs(a.value));
        
        return {
          labels: deltas.map(d => d.label),
          datasets: [{
            label: 'Profit Impact',
            data: deltas.map(d => d.value),
            backgroundColor: deltas.map(d => d.value > 0 ? 'rgba(16, 185, 129, 0.7)' : 'rgba(239, 68, 68, 0.7)'),
            borderColor: deltas.map(d => d.value > 0 ? 'var(--success)' : 'var(--danger)'),
            borderWidth: 1
          }]
        };
      }
      
      
      // --- 8. SELF-TESTING ---

      function selfTest() {
        console.log("Running self-test...");
        const tolerance = 0.01;
        let failures = [];
        const check = (name, actual, expected) => {
          if (expected === 0 && actual !== 0) {
             failures.push(`${name} (Expected: 0, Got: ${actual.toFixed(4)})`);
          } else if (expected !== 0 && Math.abs((actual - expected) / expected) > tolerance) {
            failures.push(`${name} (Expected: ${expected.toFixed(4)}, Got: ${actual.toFixed(4)})`);
          }
        };

        const worst = computeMetrics(DEFAULT_INPUTS.worst);
        check('Worst Clicks', worst.clicks, 25.00);
        check('Worst Leads', worst.leads, 2.00);
        check('Worst CPL', worst.cpl, 75.00);
        check('Worst Sales', worst.sales, 0.20);
        check('Worst CAC', worst.cac, 750.00);
        check('Worst Profit', worst.profit, -10.00);
        check('Worst ROAS', worst.roas, 0.93333);
        check('Worst CPC_BE', worst.cpcBE, 5.60);
        check('Worst CVR_BE', worst.cvrBE, 0.08571);
        check('Worst Close_BE', worst.closeBE, 0.10714);

        const real = computeMetrics(DEFAULT_INPUTS.real);
        check('Real Clicks', real.clicks, 33.3333);
        check('Real Leads', real.leads, 5.00);
        check('Real CPL', real.cpl, 30.00);
        check('Real Sales', real.sales, 1.00);
        check('Real CAC', real.cac, 150.00);
        check('Real Profit', real.profit, 550.00);
        check('Real ROAS', real.roas, 4.66666);
        check('Real CPC_BE', real.cpcBE, 21.00);
        check('Real CVR_BE', real.cvrBE, 0.03214);
        check('Real Close_BE', real.closeBE, 0.04285);
        
        const best = computeMetrics(DEFAULT_INPUTS.best);
        check('Best Clicks', best.clicks, 42.8571);
        check('Best Leads', best.leads, 8.5714);
        check('Best CPL', best.cpl, 17.50);
        check('Best Sales', best.sales, 3.4285);
        check('Best CAC', best.cac, 43.75);
        check('Best Profit', best.profit, 2250.00);
        check('Best ROAS', best.roas, 16.0);
        check('Best CPC_BE', best.cpcBE, 56.00);
        check('Best CVR_BE', best.cvrBE, 0.0125);
        check('Best Close_BE', best.closeBE, 0.025);

        if (failures.length > 0) {
          console.error("--- SELF-TEST FAILED ---", failures);
          dom.selfTestBanner.textContent = `Self-test failed: ${failures.join(', ')}. Calculations may be incorrect.`;
          dom.selfTestBanner.style.display = 'block';
        } else {
          console.log("--- Self-test PASSED ---");
        }
      }

      
      // --- 9. INITIALIZATION ---

      function init() {
        buildTooltipDefinitions();
        selfTest(); 
        
        dom.xAxisSelect.value = state.viz.xAxis;
        dom.yAxisSelect.value = state.viz.yAxis;

        // Add event listeners
        dom.resetBtn.onclick = handleReset;
        dom.csvBtn.onclick = handleExportCSV;
        dom.pngBtn.onclick = handleExportPNG;
        dom.infoBtn.onclick = () => toggleModal(true);
        dom.modalCloseBtn.onclick = () => toggleModal(false);
        dom.modal.onclick = (e) => {
          if (e.target === dom.modal) toggleModal(false);
        };
        
        dom.xAxisSelect.onchange = handleChartControlsChange;
        dom.yAxisSelect.onchange = handleChartControlsChange;
        dom.sensitivitySelect.onchange = handleChartControlsChange;
        
        // Tooltip listeners
        dom.tableBody.addEventListener('mouseover', handleTooltipShow);
        dom.tableBody.addEventListener('mouseout', handleTooltipHide);
        
        render();
      }
      
      init();

    });
  </script>

</body>

</html>
